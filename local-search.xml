<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go是不是面向对象</title>
    <link href="/2023/09/01/Go%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/09/01/Go%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>Go允许OO的编程风格<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> walk() &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Go的Struct可以看做是其他语言的Class</li><li>Go缺乏其它语言的继承结构</li><li>Go的接口与其它语言有很大差异</li></ul><h2 id="Go的”类”"><a href="#Go的”类”" class="headerlink" title="Go的”类”"></a>Go的”类”</h2><ul><li>其它语言, 往往用class表示一类数据</li><li>class的每一个实例称作”对象”</li><li>Go中用struct表示一类数据</li><li>struct的每一个实例并不是对象, 而是此类型的值</li><li>struct也可以定义方法</li></ul><h2 id="Go的继承"><a href="#Go的继承" class="headerlink" title="Go的继承"></a>Go的继承</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>Person<br>&#125;<br>m := Man&#123;&#125;<br>m.walk() <span class="hljs-comment">// 语法糖, 实际上是 m.People.walk()</span><br></code></pre></td></tr></table></figure><ul><li>Go没有继承关系</li><li>所谓Go的继承只是组合</li><li>组合中的匿名字段, 通过语法糖达成了类似继承的效果</li></ul><h2 id="Go的接口"><a href="#Go的接口" class="headerlink" title="Go的接口"></a>Go的接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> alive <span class="hljs-keyword">interface</span> &#123;<br>walk()<br>&#125;<br><br><span class="hljs-comment">// 实现alive接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p Person)</span></span> walk() &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>接口可以定义Go中的一组行为相似的struct</li><li>struct并不显式实现接口, 而是隐式实现</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Go没有对象, 没有类, 没有继承</li><li>Go通过组合匿名字段来达到类似继承的效果</li><li>通过以上手段去掉了面向对象中复杂而冗余的部分</li><li>保留了基本的面向对象特性</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go是如何运行的</title>
    <link href="/2023/09/01/Go%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <url>/2023/09/01/Go%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>并非是main方法<br>runtime包, <code>_rt0_linux_amd64.s</code>. 汇编程序<br><code>asm_amd64.s</code>, </p><h2 id="读取命令行参数"><a href="#读取命令行参数" class="headerlink" title="读取命令行参数"></a>读取命令行参数</h2><ul><li>复制参数数量argc和参数值argv到栈上</li></ul><h2 id="初始化g0执行栈"><a href="#初始化g0执行栈" class="headerlink" title="初始化g0执行栈"></a>初始化g0执行栈</h2><ul><li>g0是为了调度协程而产生的的协程</li><li>g0是每个Go程序的第一个协程</li></ul><h2 id="运行时检测"><a href="#运行时检测" class="headerlink" title="运行时检测"></a>运行时检测</h2><ul><li>检查各种类型的长度</li><li>检查指针操作</li><li>检查结构体字段的偏移量</li><li>检查atomic原子类型</li><li>检查CAS操作</li><li>检查栈的大小是否为2的幂次</li></ul><h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><ul><li>对命令行中的参数进行处理</li><li>参数数量赋值给<code>argc int32</code></li><li>参数值赋值给<code>argv **byte</code></li></ul><h2 id="调度器初始化-runtime-schedinit"><a href="#调度器初始化-runtime-schedinit" class="headerlink" title="调度器初始化 runtime.schedinit"></a>调度器初始化 runtime.schedinit</h2><ul><li>全局栈空间内存分配</li><li>加载命令行参数到os.Args</li><li>堆内存空间初始化</li><li>加载操作系统环境变量</li><li>初始化当前系统线程</li><li>垃圾回收器的参数初始化</li><li>算法初始化(map&#x2F;hash)</li><li>设置process数量</li></ul><h2 id="创建主协程"><a href="#创建主协程" class="headerlink" title="创建主协程"></a>创建主协程</h2><ul><li>创建一个新的协程, 执行runtime.main(此前已经有一个g0协程)</li><li>放入调度器等待调度</li></ul><h2 id="初始化M"><a href="#初始化M" class="headerlink" title="初始化M"></a>初始化M</h2><ul><li>初始化一个M, 用来调度主协程</li></ul><h2 id="主协程执行主函数"><a href="#主协程执行主函数" class="headerlink" title="主协程执行主函数"></a>主协程执行主函数</h2><ul><li>执行runtime包中的init方法</li><li>启动GC垃圾收集器</li><li>执行用户包依赖的init方法</li><li>执行用户主函数main.main()</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go启动时经历了检查, 各种初始化, 初始化协程调度的过程<br>main.main()也是在协程中运行的<br>Go程序的启动过程像一个虚拟机, 或框架.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
