<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL中的索引</title>
    <link href="/2023/09/20/MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/09/20/MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>不管是什么存储引擎, 根据主键查询数据, 这个效率最高</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><ol><li>从磁盘加载4号索引页到Buffer Pool中</li><li>从内存的4号索引页二分查找id &#x3D; 100对应的子节点(37号索引页)</li><li>从磁盘加载37号索引页到Buffer Pool中</li><li>从内存的37号索引页二分查找id &#x3D; 100对应的子节点(5号数据页)</li><li>从磁盘加载5号数据页到Buffer Pool中</li><li>从内存的5号数据页中二分查找id &#x3D; 100对应的行记录<br>三次磁盘IO</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;90@163.com&#x27;</span>;<br></code></pre></td></tr></table></figure><p>从叶子结点的头部开始线性扫描.<br>全表扫描, 性能很差</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">400</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><pre><code class="hljs">找到id=400的记录, 往后遍历, 直到1000;</code></pre><h1 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h1><p>按照主键查询的话, 称为使用主键索引来查询数据<br>主键索引分为: 聚簇索引和非聚集索引<br>数据行和相邻的键值紧凑的存储在一起<br>eg. 数据r1和r2相邻, r1对应数据存储在a1, r2对应数据存储在a2<br>如果a1与a2相邻, 则是聚簇索引, 如果不相邻, 则是非聚簇索引</p><h1 id="EXPLAIN查看选择的索引"><a href="#EXPLAIN查看选择的索引" class="headerlink" title="EXPLAIN查看选择的索引"></a>EXPLAIN查看选择的索引</h1><ul><li>possible_keys 可能被选择的索引</li><li>key 选择的索引</li><li>type 访问类型<ul><li>const 最多只有一条记录匹配</li><li>all 全表扫描</li></ul></li><li>rows 估计出需要扫描的行数</li><li>filtered 通过条件可以筛选出的比例</li></ul><h1 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h1><p>Secondary Index - 二级索引<br>在查询数据的时候, 尽可能根据主键来查询数据; 但是, 很多时候并不能根据主键来查询数据.</p><ul><li>创建表的时候添加索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_user (<br>...<br>INDEX email_idx(email)<br>);<br></code></pre></td></tr></table></figure></li><li>如果已经创建, 则通过修改表结构完成<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引, 可以指定索引名称</span><br><span class="hljs-keyword">CREATE</span> INDEX email_idx <span class="hljs-keyword">ON</span> t_user(email);<br><span class="hljs-comment">-- 删除索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> t_user <span class="hljs-keyword">DROP</span> INDEX email_idx;<br><span class="hljs-comment">-- 执行, 无法指定索引名称</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> t_user <span class="hljs-keyword">ADD</span> INDEX (email);<br></code></pre></td></tr></table></figure></li></ul><h2 id="InnoDB的辅助索引"><a href="#InnoDB的辅助索引" class="headerlink" title="InnoDB的辅助索引"></a>InnoDB的辅助索引</h2><p>创建一棵B+树, 以索引字段为Key, 主键ID为Value</p><ul><li>索引页存储: key(email字段值), 主键(id值), 子节点所在的数据页页号. 按照Key(email字段值)升序排列</li><li>数据页中, 存储的是key(email的字段值)及其所在行的主键值(id字段值). 按照key(email字段值)升序排列</li></ul><p>辅助索引 vs 主键索引</p><ul><li>主键索引树上的叶子节点存储的是主键及其对应的行记录数据, 而辅助索引树上的节点存储的是索引字段值及其所在行的主键值</li><li>主键索引树的key(主键)不能重复, 而辅助索引树的key(email)是可以重复的, 这种key可以重复的索引, 我们也成为普通索引</li><li>主键索引是聚集索引, 相邻的主键对应的行记录是相邻的; 而辅助索引是非聚集索引, 相邻的key对应的行记录不一定相邻;</li></ul><h2 id="辅助索引查询的步骤"><a href="#辅助索引查询的步骤" class="headerlink" title="辅助索引查询的步骤"></a>辅助索引查询的步骤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;90@163.com&#x27;</span>;<br></code></pre></td></tr></table></figure><ol><li>到email索引树上找到email &#x3D; ‘<a href="mailto:&#x39;&#x30;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;">&#x39;&#x30;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;</a>‘的记录, 得到主键id &#x3D; 100</li><li>再回到主键索引树查找id &#x3D; 100对应的行记录</li><li>在email索引树上继续遍历(普通索引可能不唯一), 如果emai !&#x3D; ‘<a href="mailto:&#57;&#48;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;">&#57;&#48;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a>‘ 停止遍历<br>在查找的过程中, 从辅助索引树回到主键索引树搜索的过程, 称为回表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- EXPLAIN 后, extra包含using index, 说明只使用email索引树, 不需要回表查询</span><br><span class="hljs-keyword">SELECT</span> id, email <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;90@163.com&#x27;</span>;<br><span class="hljs-comment">-- extra为NULL</span><br><span class="hljs-keyword">SELECT</span> password <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;90@163.com&#x27;</span>;<br></code></pre></td></tr></table></figure><p>范围查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- extra: using index condition</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;149844@163.com&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;149846@163.com&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>在email索引树上找到email &#x3D; ‘<a href="mailto:&#49;&#52;&#x39;&#56;&#52;&#x34;&#x40;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#52;&#x39;&#56;&#52;&#x34;&#x40;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a>‘ 的记录, 取得id &#x3D; 149854</li><li>再回到id主键索引树查找id &#x3D; 149854对应的记录</li><li>在email索引树上找到email &#x3D; ‘<a href="mailto:&#49;&#52;&#x39;&#x38;&#52;&#53;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;">&#49;&#52;&#x39;&#x38;&#52;&#53;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a>‘ 的记录, 取得id &#x3D; 149855</li><li>再回到id主键索引树查找id &#x3D; 149855对应的记录</li><li>在email索引树上找到email &#x3D; ‘<a href="mailto:&#49;&#x34;&#x39;&#56;&#x34;&#x36;&#x40;&#49;&#54;&#x33;&#46;&#99;&#111;&#109;">&#49;&#x34;&#x39;&#56;&#x34;&#x36;&#x40;&#49;&#54;&#x33;&#46;&#99;&#111;&#109;</a>‘ 的记录, 取得id &#x3D; 149855</li><li>再回到id主键索引树查找id &#x3D; 149856对应的记录</li><li>在email索引树上取下一个值email &#x3D; ‘<a href="mailto:&#49;&#52;&#57;&#x38;&#52;&#x37;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109;">&#49;&#52;&#57;&#x38;&#52;&#x37;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109;</a>‘ , 不满足条件, 结束</li></ul><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>Index Condition Pushdown</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- extra: using where</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;100&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Server层的优化器不会选择任何索引, 因为WHERE子句中没有索引列<br>Server层的执行器调用存储引擎的读数据接口, 存储引擎读取表t_user的所有数据, 并返回给Server层的执行器;<br>Server层的执行器得到数据后, 根据WHERE子句后面的条件进行过滤, 将符合条件的数据返回给客户端<br><code>using where</code>的意思是: 将数据从存储引擎的表空间读取数据到Server层, 在Server层根据Where过滤数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- extra: using where</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;10@163.com&#x27;</span>;<br></code></pre></td></tr></table></figure><p>只过滤掉了较少部分的数据, 因此优化器选择不使用索引, 而采用全表扫描<br>如果强制走索引, 会更慢</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> FORCE INDEX(email) <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;10@163.com&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- extra: using index condition</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;990000@163.com&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>不开启索引下推:<br>搜索email整棵索引树, 存储引擎不断地拿到下一条email索引树中的索引, 回表查询后将行记录返回给Server层, Server对数据进行过滤返回.</li><li>开启索引下推(条件下放到存储引擎, 过滤由存储引擎完成, 默认开启):<br>存储引擎根据条件email &gt; ‘<a href="mailto:&#x39;&#57;&#x30;&#x30;&#48;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;">&#x39;&#57;&#x30;&#x30;&#48;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a>‘搜索email整棵索引树,  将主键id回表到主键索引树查询对应行记录, 存储引擎将符合条件的记录返回给Server层.<br>可以减少大量的回表查询.</li></ul><p>using index condition: 需要回表查询数据, 但有部分数据是在二级索引过滤后, 再回表查询数据, 减少回表查询的数据行数.</p><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student (<br>...<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span>,<br>...<br>);<br></code></pre></td></tr></table></figure><p>普通索引 vs 唯一索引</p><ol><li>如果符合某一条件不存在的话, 唯一索引不会走索引, 普通索引会走.</li><li>普通索引找到满足条件的第一个记录后, 需要查找下一个记录, 知道碰到第一个不满足条件的记录; 对于唯一索引来说, 由于索引定义了唯一性, 查找到第一个满足条件的记录后, 就会停止继续检索.</li></ol><h2 id="EXPLAIN中的type字段"><a href="#EXPLAIN中的type字段" class="headerlink" title="EXPLAIN中的type字段"></a>EXPLAIN中的type字段</h2><ul><li>ALL<br>全表扫描. MySQL扫描全表来找到匹配的行</li><li>index<br>索引全扫描. MySQL遍历整个索引来查找匹配的行<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> title <span class="hljs-keyword">FROM</span> film;<br></code></pre></td></tr></table></figure>由于title建立了索引, 会直接使用title的索引树, 因为title的索引树比主键索引树小得多.</li><li>range<br>索引范围搜索, 常见于&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, BETWEEN等操作符</li><li>ref<br>使用普通索引或唯一索引的前缀扫描, 返回匹配某个单独值的记录行<br>普通索引等值查询 -&gt; ref<br>普通索引范围查询 -&gt; range</li><li>rq_ref<br>使用唯一索引或者主键进行关联查询</li><li>const<br>但表中最多只有一行记录匹配, 查询起来非常迅速, 所以这个匹配行中的其他列中的值可以被优化器在当前查询中当做常量来处理, 例如根据主键或者唯一索引进行的查询</li><li>NULL<br>表示MySQL不用访问表或者索引就可以直接得到结果的查询</li></ul><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>对表上的多个列进行索引.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhu&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br></code></pre></td></tr></table></figure><p>where条件中没有建立索引, 会走全表扫描.<br>给name加上普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student <span class="hljs-keyword">ADD</span> INDEX name_idx(name);<br></code></pre></td></tr></table></figure><p>这时候就可以走name索引, type&#x3D;ref.<br>先从name索引树找到id, 再回表查询主键索引树找到行记录, 通过age过滤数据.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bing&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br></code></pre></td></tr></table></figure><p>使用了name索引, 但因为需要排序, 使用了外部排序. 可以通过给name和age添加联合索引完成优化.<br>name和age作为key构建B+树, 全局按照name进行排序, 当name有序的时候按照key排序.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br></code></pre></td></tr></table></figure><p>会进行全表扫描, 因为并不是全局按照age有序排列.</p><h2 id="什么时候添加B树索引"><a href="#什么时候添加B树索引" class="headerlink" title="什么时候添加B树索引?"></a>什么时候添加B树索引?</h2><p>访问表中很少一部分数据时使用B+树索引才有意义.<br>索引的选择性: 不重复的索引值的个数和数据表的记录总数的比值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>(name)) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure><p>这个值越高, 使用索引查询的效率就越高, 因为可以让MySQL在查找时过滤掉更多的行.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 强制使用索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student FORCE INDEX(gender);<br><span class="hljs-comment">-- 忽略索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student IGNORE INDEX(gender);<br></code></pre></td></tr></table></figure><h2 id="索引顺序"><a href="#索引顺序" class="headerlink" title="索引顺序"></a>索引顺序</h2><p>使用两个或两个以上的字段来作为索引.<br>将选择性最高的列放在索引列最前面</p><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul><li>表达式计算<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> uid <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure></li><li>函数调用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(email, <span class="hljs-number">2</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;hi&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引包含(或者覆盖)所有需要查询的字段的值.<br>name, age创建了联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bing&#x27;</span>;<br></code></pre></td></tr></table></figure><p>会进行回表查询.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age, id <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bing&#x27;</span>;<br></code></pre></td></tr></table></figure><p>就只会在name, age这棵索引树查询, 不进行回表查询. </p><ul><li>查询数据少了很多</li><li>避免回表 </li><li>对某些统计而言有好处<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure>也会走索引, 因为辅助索引远小于主键索引树数据, 选择辅助索引树可以减少IO操作.<br>(a,b)联合索引, 一般不选择B作为查询条件, 因为全局无序.</li></ul><h2 id="B-Tree的优缺点"><a href="#B-Tree的优缺点" class="headerlink" title="B-Tree的优缺点"></a>B-Tree的优缺点</h2><p>优点</p><ul><li>索引大大减少mysqld需要扫描的数据量</li><li>索引可以帮助mysqld避免排序</li><li>索引可以将随机IO变成顺序IO<br>缺点</li><li>索引需要占用磁盘空间</li><li>新增和删除记录的话, 需要额外维护索引树, 有性能消耗</li></ul><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>如果索引很长的字符列, 那么这课索引树占用的空间也会很大, 因为书中的每一页的每个记录都需要存储索引字符串列的值<br>一旦磁盘空间大的话, 那么查询的时候就可能需要更多的磁盘IO, 这样会降低查询的性能.<br>索引字段长度越小, 普通索引的叶子结点就越小, 普通索引占用的空间也就越小<br>如果索引是字符串的话, 我们可以索引字符串的前缀, 这样可以大大节约索引空间, 从而提高索引效率.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student <span class="hljs-keyword">ADD</span> INDEX (email(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><p>可以通过SQL去看前缀取多少合适</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br><span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>(<span class="hljs-keyword">LEFT</span>(email, <span class="hljs-number">10</span>))) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) ten,<br><span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>(<span class="hljs-keyword">LEFT</span>(email, <span class="hljs-number">9</span>))) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) nine,<br><span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>(<span class="hljs-keyword">LEFT</span>(email, <span class="hljs-number">8</span>))) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) eight,<br><span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>(<span class="hljs-keyword">LEFT</span>(email, <span class="hljs-number">7</span>))) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) seven,<br><span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>(<span class="hljs-keyword">LEFT</span>(email, <span class="hljs-number">6</span>))) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) six,<br><span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure><h2 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h2><p>使用自增字段作为主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_1 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>...<br>);<br></code></pre></td></tr></table></figure><p>使用UUID作为主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入的时候使用 uuid 字段</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_2 (<br>uuid <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">36</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>...<br>);<br></code></pre></td></tr></table></figure><p>从空间上来看, 自增字段比较合理;<br>从插入性能来看, 自增主键的插入性能也比UUID的插入性能好. 随机插入会出现页分裂, 自增插入可以避免页分裂.</p><blockquote><p>页分裂: 往已经满了的数据页中插入数据, B+树会分裂, 数据移动多, 开销较大</p></blockquote><p>在业务中使用身份证号作为主键, 会导致主键ID过长, 如果建立索引, 每棵二级索引树还会存储身份证号, 浪费空间.</p><h2 id="MyISAM存储引擎中的索引"><a href="#MyISAM存储引擎中的索引" class="headerlink" title="MyISAM存储引擎中的索引"></a>MyISAM存储引擎中的索引</h2><p><code>*.MYD</code>数据文件, <code>*.MYI</code>索引文件<br>InnoDB中, 索引即数据, 在主键索引树的叶子节点中已经包含了表中所有的行记录数据.<br>MyISAM默认查询的顺序与插入顺序相同, InnoDB以主键有序排列</p><h3 id="等值查询"><a href="#等值查询" class="headerlink" title="等值查询"></a>等值查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><ol><li>在主键索引树中从根节点开始查询, 将根节点加载到内存(1次磁盘IO), 比较30 &lt; 56, 走左边</li><li>将左子树节点加载到内存(1次磁盘IO), 比较20 &lt; 30 &lt; 49, 向下查询</li><li>找到叶子结点, 将叶子结点加载到内存中(1次磁盘IO), 在叶节点中找到id &#x3D; 30的索引</li><li>从索引相中获取磁盘地址, 然后到数据文件user.MYD中获取对应的行记录(1次磁盘IO)</li><li>将记录返回个记客户端, 等值查询需要4次磁盘IO</li></ol><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">30</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">49</span>;<br></code></pre></td></tr></table></figure><ol><li>在主键索引树中从根节点开始查询, 将根节点加载到内存(1次磁盘IO), 比较30 &lt; 56, 走左边</li><li>将左子树节点加载到内存(1次磁盘IO), 比较20 &lt; 30 &lt; 49, 向下查询</li><li>加载叶子结点到内存, 找到值等于30的索引项, 根据磁盘地址从数据文件中获取行记录到结果集</li><li>在索引树中, 向后遍历叶子结点的链表, 一直到第一个不满足条件为止, 这里要加载下一个叶子结点到内存(1次磁盘IO), 然后找到49所在的索引项, 拿到磁盘地址, 根据磁盘地址从磁盘文件中获取行记录放到结果集(1次磁盘IO)</li><li>再遍历下一条索引项, 索引值为50, 不符合条件, 查询结束, 返回2条记录给客户端<br>两次非叶节点的加载, + 需要遍历的叶子结点总数 + 最终查找记录数</li></ol><p>MyISAM在查询的时候, 会将索引节点缓存在内存中, 而数据缓存依赖于操作系统自身的页面缓存.</p><p>MyISAM主键不允许重复, 必须唯一, 辅助索引的索引值可以重复. 除此之外, 都相同.<br>MyISAM辅助索引查询数据, 不需要回表查询, 直接拿到磁盘地址, 到数据文件直接拿去对应数据.</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文本处理工具GREP AWK SED TR</title>
    <link href="/2023/09/20/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7GREP-AWK-SED-TR/"/>
    <url>/2023/09/20/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7GREP-AWK-SED-TR/</url>
    
    <content type="html"><![CDATA[<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> bing&#123;01..100&#125;<br><span class="hljs-built_in">echo</span> bing&#123;a..z &#125;<br></code></pre></td></tr></table></figure><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>ctrl + a: 移动到行首<br>ctrl + e: 移动到行尾<br>ctrl + u: 删除光标之前的字符<br>ctrl + k: 删除光标之后的字符<br>ctrl + l:  清屏</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>sed &#x2F; awk &#x2F; grep 原生支持<br>grep: 文本过滤工具 模式工具<br>sed: stream editor 流编辑器 文本编辑工具<br>awk: Linux的文本报告生成器(格式化文本)<br>Linux上是gawk</p><h2 id="BRE集合"><a href="#BRE集合" class="headerlink" title="BRE集合"></a>BRE集合</h2><p>^ 模式最左侧 <code>^old</code>表示以<code>old</code>开头的行<br>$ 模式最右侧<code>$old</code>表示以<code>old</code>结尾的行<br><code>^$</code>组合符, 空行(以空开始 以空结尾)<br><code>.</code>匹配一个字符, 不能匹配空行<br><code>\</code>转义字符<code>\.</code>表示符号<code>.</code><br><code>*</code>匹配前一个字符0次或以上, <code>a*</code>匹配<code>a</code>零次或以上<br><code>.*</code>匹配所有内容<br><code>^.*</code>匹配任意多个字符开头的内容<br><code>.*$</code>匹配任意多个字符结尾的内容<br><code>[abc]</code>匹配<code>[]</code>集合内任意一个字符 a b或c, 也可以写成<code>[a-c]</code><br><code>[^abc]</code>匹配除了<code>^</code>后面的任意字符</p><h2 id="ERE集合"><a href="#ERE集合" class="headerlink" title="ERE集合"></a>ERE集合</h2><p>需要通过<code>grep -E</code>才能生效<br><code>+</code>匹配一个字符1次或多次<br><code>[:/]+</code>匹配括号内的<code>:</code>或<code>/</code>一次或多次<br><code>?</code>匹配前一个字符0次或1次<br><code>|</code>或者<br><code>()</code>分组过滤, 被括起来的内容表示一个整体<br><code>a&#123;m,n&#125;</code>匹配字符<code>a</code>最少m次, 最多n次<br><code>a&#123;m,&#125;</code>最少匹配m次<br><code>a&#123;m&#125;</code>正好匹配m次<br><code>a&#123;,m&#125;</code>最多匹配m次</p><h2 id="grep-global-search-regular-expression-and-print-out-the-line"><a href="#grep-global-search-regular-expression-and-print-out-the-line" class="headerlink" title="grep - global search regular expression and print out the line"></a>grep - global search regular expression and print out the line</h2><p>Global search REgular expression and Print out the line<br><code>grep [options] [pattern] file</code><br><code>-i</code> 忽略字符大小写<br><code>-o</code> 显示匹配到的字符串本身, 否则是搜索到的行<br><code>-v</code> 显示不能被匹配到的行<br><code>-E</code>支持拓展的正则表达式字符<br><code>-n</code>显示匹配到的行号<br><code>-c</code>统计匹配到的行数</p><ul><li><p>过滤掉注释行再过滤掉空白行<br><code>grep -v &#39;^#&#39; tmp.txt | grep -v &#39;^$&#39;</code><br>linux平台下, 所有文件的结尾都有一个<code>$</code> 字符</p></li><li><p><code>.s</code>匹配<code>is as bs</code>字符+s的组合</p></li><li><p><code>.*e</code> 贪婪匹配 e结尾的任意字符串 </p></li><li><p><code>[^0-5]</code>匹配6-9的所有数字</p></li><li><p><code>ch+</code>匹配ch开头的一次或多次</p></li><li><p><code>go?d</code>匹配<code>god gd</code></p></li><li><p><code>l|t</code>匹配含有l或t</p></li><li><p><code>(l..e).*\1</code> 匹配love my lovers, 不匹配like my lovers.</p></li></ul><h2 id="sed-stream-editor"><a href="#sed-stream-editor" class="headerlink" title="sed - stream editor"></a>sed - stream editor</h2><p>Stream EDitor<br><code>-n</code> 只输出匹配的行<br><code>-i</code> 原地编辑当前文件<br><code>-e</code> 不修改当前文件, 把修改结果输出到stdout<br><code>sed [选项] [sed内置命令字符] [输入文件] </code></p><p><code>$</code>表示最后一行<br><code>a</code>前面有数字表示append, 在当前行后面添加; 前面没数字表示全部all<br><code>i</code>前面有数字表示insert, 在当前行前面添加</p><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><ul><li>输出第2,3行<br><code>sed -n &quot;2,3p&quot; tmp.txt</code><br><code>-n</code> 没匹配到的不输出</li><li>从第二行输出三行<br><code>sed -n &quot;2,+3p&quot; tmp.txt</code></li><li>输出包含<code>linux</code>的字符串<br><code>sed -n &quot;/linux/p&quot; tmp.txt</code></li></ul><h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><ul><li>删除有<code>game</code>的行<br><code>sed -i &quot;/game/d&quot; tmp.txt</code></li><li>将第五行之后的数据进行删除<br><code>sed -i &quot;5,$d&quot; tmp.txt</code></li><li>将<code>My</code>替换成<code>His</code><br><code>sed -i &quot;s/My/His/g&quot; tmp.txt</code></li><li>加<code>-e</code> 可以多次替换</li><li>在第二行之后加<br><code>sed -i &quot;2a My linux is good.&quot; tmp.txt</code></li><li>在第二行之前加<br><code>sed -i &quot;2i My linux is good.&quot; tmp.txt</code></li><li>在每一行后面添加<br><code>sed -i &quot;a --------&quot;</code></li></ul><h2 id="获取Linux-IP"><a href="#获取Linux-IP" class="headerlink" title="获取Linux IP"></a>获取Linux IP</h2><p><code>ifconfig en0 | sed -n &quot;5p&quot; | sed &quot;s/^.*inet//g&quot; | sed &quot;s/net.*$//&quot;</code></p><ul><li>&#96;ifconfig en0<br>查看en0网卡信息</li><li><code>sed -n &quot;5p&quot;</code><br>只看第六行</li><li><code>sed &quot;s/^.*inet//g&quot;</code><br>将inet及以前的字符去除, 将<code>^.*inet</code>替换成无</li><li><code>sed &quot;s/net.*$//&quot;</code><br>将net及以后的字符去除<br>或者使用-e多重过滤<br><code>ifconfig en0 | sed -n -e &quot;5s/^.*inet//&quot; -e &quot;5s/net.*$//p&quot;</code></li></ul><h2 id="ifconfig-en0-awk-NR-5-print-2-awk默认按空格分隔NR-number-of-record-指定行-NR-1-NR-5-第一行到第五行-NR-1-NR-3-第一行或第三行-n指定列-NF-number-of-field-1-第一列-NF最后一列gnu-awk默认以空格为分隔符-多个空格也可作为分隔-输出全部数据awk-print-0-tmp-txt-输出第n列数据awk-print-n-tmp-txt-输出最后一列-number-of-fieldsawk-print-NF-tmp-txt-输出倒数第二列awk-print-NF-1-tmp-txt-NR-number-of-records-输出多列-可以自定义格式awk-print-Col1-1-Col2-2-tmp-txt-指定分隔符为-awk-F-print-0-tmp-txt-输出第二到五行awk-NR-2-NR-5-print-0-tmp-txt-输出第一行和第三行awk-NR-1-NR-3-print-0-tmp-txt-添加行号awk-print-NR-0-tmp-txt-修改默认输出分隔符awk-F-v-OFS-print-1-NF-tmp-txt-输出两个文件的行号awk-print-FNR-0-tmp1-txt-tmp2-txt-开始操作前进行输出-awk-BEGINP-print-Begin-operation-print-0"><a href="#ifconfig-en0-awk-NR-5-print-2-awk默认按空格分隔NR-number-of-record-指定行-NR-1-NR-5-第一行到第五行-NR-1-NR-3-第一行或第三行-n指定列-NF-number-of-field-1-第一列-NF最后一列gnu-awk默认以空格为分隔符-多个空格也可作为分隔-输出全部数据awk-print-0-tmp-txt-输出第n列数据awk-print-n-tmp-txt-输出最后一列-number-of-fieldsawk-print-NF-tmp-txt-输出倒数第二列awk-print-NF-1-tmp-txt-NR-number-of-records-输出多列-可以自定义格式awk-print-Col1-1-Col2-2-tmp-txt-指定分隔符为-awk-F-print-0-tmp-txt-输出第二到五行awk-NR-2-NR-5-print-0-tmp-txt-输出第一行和第三行awk-NR-1-NR-3-print-0-tmp-txt-添加行号awk-print-NR-0-tmp-txt-修改默认输出分隔符awk-F-v-OFS-print-1-NF-tmp-txt-输出两个文件的行号awk-print-FNR-0-tmp1-txt-tmp2-txt-开始操作前进行输出-awk-BEGINP-print-Begin-operation-print-0" class="headerlink" title="ifconfig en0 | awk &#39;NR==5{print $2}&#39;## awk默认按空格分隔NR(number of record)指定行    NR &#x3D;&#x3D; 1, NR &#x3D;&#x3D; 5 第一行到第五行    NR &#x3D;&#x3D; 1|| NR &#x3D;&#x3D; 3 第一行或第三行$n指定列, NF(number of field)    $1 第一列    $NF最后一列gnu awk默认以空格为分隔符, 多个空格也可作为分隔- 输出全部数据awk &#39;{print $0}&#39; tmp.txt- 输出第n列数据awk &#39;{print $n}&#39; tmp.txt- 输出最后一列 number of fieldsawk &#39;{print $NF}&#39; tmp.txt- 输出倒数第二列awk &#39;{print $(NF-1)}&#39; tmp.txt- NR - number of records- 输出多列 可以自定义格式awk &#39;{print &quot;Col1:&quot;$1,&quot;Col2:&quot;$2}&#39; tmp.txt- 指定分隔符为:awk -F &quot;:&quot; &#39;{print $0}&#39; tmp.txt- 输出第二到五行awk &#39;NR==2,NR==5{print $0}&#39; tmp.txt- 输出第一行和第三行awk &#39;NR==1||NR==3{print $0}&#39; tmp.txt- 添加行号awk &#39;{print NR,$0}&#39; tmp.txt- 修改默认输出分隔符awk -F &quot;:&quot; -v OFS=&quot;===&quot; &#39;{print $1,$NF}&#39; tmp.txt- 输出两个文件的行号awk &#39;{print FNR,$0}&#39; tmp1.txt tmp2.txt - 开始操作前进行输出 awk &#39;BEGINP{print &quot;Begin operation&quot;} {print $0}&#39;"></a><code>ifconfig en0 | awk &#39;NR==5&#123;print $2&#125;&#39;</code><br>## awk<br>默认按空格分隔<br>NR(number of record)指定行<br>    NR &#x3D;&#x3D; 1, NR &#x3D;&#x3D; 5 第一行到第五行<br>    NR &#x3D;&#x3D; 1|| NR &#x3D;&#x3D; 3 第一行或第三行<br>$n指定列, NF(number of field)<br>    $1 第一列<br>    $NF最后一列<br>gnu awk<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk [option] <span class="hljs-string">&#x27;patternp[action]&#x27;</span> file ...<br></code></pre></td></tr></table></figure><br>默认以空格为分隔符, 多个空格也可作为分隔<br>- 输出全部数据<br><code>awk &#39;&#123;print $0&#125;&#39; tmp.txt</code><br>- 输出第n列数据<br><code>awk &#39;&#123;print $n&#125;&#39; tmp.txt</code><br>- 输出最后一列 number of fields<br><code>awk &#39;&#123;print $NF&#125;&#39; tmp.txt</code><br>- 输出倒数第二列<br><code>awk &#39;&#123;print $(NF-1)&#125;&#39; tmp.txt</code><br>- NR - number of records<br>- 输出多列 可以自定义格式<br><code>awk &#39;&#123;print &quot;Col1:&quot;$1,&quot;Col2:&quot;$2&#125;&#39; tmp.txt</code><br>- 指定分隔符为<code>:</code><br><code>awk -F &quot;:&quot; &#39;&#123;print $0&#125;&#39; tmp.txt</code><br>- 输出第二到五行<br><code>awk &#39;NR==2,NR==5&#123;print $0&#125;&#39; tmp.txt</code><br>- 输出第一行和第三行<br><code>awk &#39;NR==1||NR==3&#123;print $0&#125;&#39; tmp.txt</code><br>- 添加行号<br><code>awk &#39;&#123;print NR,$0&#125;&#39; tmp.txt</code><br>- 修改默认输出分隔符<br><code>awk -F &quot;:&quot; -v OFS=&quot;===&quot; &#39;&#123;print $1,$NF&#125;&#39; tmp.txt</code><br>- 输出两个文件的行号<br><code>awk &#39;&#123;print FNR,$0&#125;&#39; tmp1.txt tmp2.txt</code><br> - 开始操作前进行输出<br> <code>awk &#39;BEGINP&#123;print &quot;Begin operation&quot;&#125; &#123;print $0&#125;&#39;</code></h2><p> <code>awk -v name=&quot;bing&quot; &#39;BEGIN&#123;print &quot;My name is &quot;,name&#125;&#39; tmp.txt</code>  可以引用外部环境变量</p><ul><li>格式化输出<br> <code>awk &#39;&#123;printf &quot;%s\t%s\n&quot;,$0&#125;&#39; tmp.txt</code></li><li>制表符输出<br><code>awk &#39;BEGIN&#123;printf &quot;%-20s\t %-20s\t %-20s\n&quot;,&quot;参数1&quot;,&quot;参数2&quot;,&quot;参数3&quot;&#125;&#123;printf &quot;%-20s\t %-20s\t %-20s\n&quot;,$1,$2,$3&#125;&#39; tmp.txt</code></li><li>结束钩子<br><code>awk &#39;BEGIN&#123;print &quot;---Begin operation---&quot;&#125;&#123;print $0&#125;END&#123;print &quot;---Operation complete---&quot;&#125;&#39; tmp.txt</code></li><li>使用正则<br><code>awk &#39;/^game/&#123;print $1,$NF&#125;&#39; tmp.txt</code></li></ul><h2 id="tr-translate"><a href="#tr-translate" class="headerlink" title="tr - translate"></a>tr - translate</h2><p><code>tr</code>命令用于字符转换或删除。它的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tr</span> [选项] SET1 [SET2]<br></code></pre></td></tr></table></figure><p>其中，<code>SET1</code>表示要进行转换或删除的字符集，<code>SET2</code>表示要转换成的字符集。</p><p>以下是一些常用的选项和参数：</p><ul><li><code>-c</code>：取反，将不在<code>SET1</code>中的字符进行转换。</li><li><code>-d</code>：删除<code>SET1</code>中的字符，不进行转换。</li><li><code>-s</code>：压缩连续重复的字符为一个字符。</li><li><code>-t</code>：指定字符集<code>SET2</code>，用于转换<code>SET1</code>中的字符。</li></ul><p>例如，假设我们有一个文本文件<code>example.txt</code>，内容如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> World!<br></code></pre></td></tr></table></figure><p>现在，我们想将所有的大写字母转换为小写字母。可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> example.txt | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span> <span class="hljs-string">&#x27;[:lower:]&#x27;</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">hello,</span> world!<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>&#39;[:upper:]&#39;</code>表示大写字母集合，<code>&#39;[:lower:]&#39;</code>表示小写字母集合。<code>tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;</code>将大写字母转换为小写字母。</p><p>还可以使用<code>tr</code>命令删除字符。例如，我们想删除文本中的逗号和感叹号，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> example.txt | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;,!&#x27;</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello World</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>-d &#39;,!&#39;</code>表示删除逗号和感叹号。</p><p>这只是<code>tr</code>命令的一些常见用法，你可以根据需要使用不同的选项和参数来实现更多的字符转换或删除操作。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题:"></a>练习题:</h1><h2 id="打印进程PID-123的所有CPU占用率大于10-的线程名称"><a href="#打印进程PID-123的所有CPU占用率大于10-的线程名称" class="headerlink" title="打印进程PID&#x3D;123的所有CPU占用率大于10%的线程名称"></a>打印进程PID&#x3D;123的所有CPU占用率大于10%的线程名称</h2><p>要打印进程PID为123的所有CPU占用率大于10%的线程名称，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top -p 123 -H | awk &#x27;$9 &gt; 10 &#123;print $1, $12&#125;&#x27;<br></code></pre></td></tr></table></figure><p>这个命令使用了<code>top</code>命令来获取进程的线程信息，并使用<code>awk</code>命令来筛选出CPU占用率大于10%的线程。具体解释如下：</p><ul><li><code>-p 123</code>：指定要监视的进程PID为123。</li><li><code>-H</code>：以线程的形式显示top的输出。</li><li><code>awk &#39;$9 &gt; 10 &#123;print $1, $12&#125;&#39;</code>：使用awk命令筛选出CPU占用率大于10%的线程，并打印出线程的ID（$1）和名称（$12）。</li></ul><p>请注意，这里的CPU占用率是指线程的CPU占用率，而不是整个进程的CPU占用率。</p><h2 id="统计一段文本里各个单词的出现频次（不区分大小写）"><a href="#统计一段文本里各个单词的出现频次（不区分大小写）" class="headerlink" title="统计一段文本里各个单词的出现频次（不区分大小写）"></a>统计一段文本里各个单词的出现频次（不区分大小写）</h2><p>在Linux中，你可以使用<code>grep</code>、<code>tr</code>和<code>sort</code>命令结合来统计一段文本中各个单词的出现频次。以下是一个示例命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;文件名&gt; | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span> <span class="hljs-string">&#x27;[:lower:]&#x27;</span> | grep -oE <span class="hljs-string">&#x27;\w+&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr<br></code></pre></td></tr></table></figure><p>请将<code>&lt;文件名&gt;</code>替换为你要统计的文本文件的路径。</p><p>这个命令的工作原理如下：</p><ol><li><code>cat &lt;文件名&gt;</code>：将文件内容输出到标准输出。</li><li><code>tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;</code>：将所有字母转换为小写，以实现不区分大小写的统计。</li><li><code>grep -oE &#39;\w+&#39;</code>：使用正则表达式匹配每个单词，并将其输出到标准输出。</li><li><code>sort</code>：按字母顺序对单词进行排序。</li><li><code>uniq -c</code>：统计每个单词的出现次数。</li><li><code>sort -nr</code>：按出现次数逆序排序，以便最常见的单词显示在前面。</li></ol><p>运行该命令后，你将会看到每个单词及其出现的频次。</p><h2 id="统计状态码为404的所有IP（对结果去重）"><a href="#统计状态码为404的所有IP（对结果去重）" class="headerlink" title="统计状态码为404的所有IP（对结果去重）"></a>统计状态码为404的所有IP（对结果去重）</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">10.1.1.201</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">200</span><br><span class="hljs-number">10.1.1.202</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">200</span><br><span class="hljs-number">10.1.1.201</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">404</span><br><span class="hljs-number">10.1.1.201</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">404</span><br><span class="hljs-number">10.1.1.201</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">404</span><br><span class="hljs-number">10.1.1.201</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">404</span><br><span class="hljs-number">10.1.1.204</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">500</span><br><span class="hljs-number">10.1.1.203</span> <span class="hljs-string">[09/Feb/2020:22:41:28 +0800]</span> GET <span class="hljs-number">404</span><br></code></pre></td></tr></table></figure><p>答案:<br>grep ‘GET 404’ a.log | awk ‘{print $1}’ | sort | uniq -c</p><h2 id="统计日志里面出现次数top3的URL"><a href="#统计日志里面出现次数top3的URL" class="headerlink" title="统计日志里面出现次数top3的URL"></a>统计日志里面出现次数top3的URL</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">hello?<span class="hljs-attribute">arg</span>=1<br>world?<span class="hljs-attribute">arg</span>=2<br>world?<span class="hljs-attribute">arg</span>=2<br>world?<span class="hljs-attribute">arg</span>=2<br>world?<span class="hljs-attribute">arg</span>=3<br>world?<span class="hljs-attribute">arg</span>=3<br>world?<span class="hljs-attribute">arg</span>=3<br>world?<span class="hljs-attribute">arg</span>=3<br>world?<span class="hljs-attribute">arg</span>=3<br>world?<span class="hljs-attribute">arg</span>=2<br>world?<span class="hljs-attribute">arg</span>=2<br>world?<span class="hljs-attribute">arg</span>=2<br>world?<span class="hljs-attribute">arg</span>=3<br>hello?<span class="hljs-attribute">arg</span>=1<br>hello?<span class="hljs-attribute">arg</span>=1<br>hello?<span class="hljs-attribute">arg</span>=1<br>world?<span class="hljs-attribute">arg</span>=4<br>world?<span class="hljs-attribute">arg</span>=5<br>world?<span class="hljs-attribute">arg</span>=6<br></code></pre></td></tr></table></figure><p><code>uniq</code> : 去重, <code>uniq -c</code> 去重后, 并统计重复次数<br>答案: <code>cat ./url | sort | uniq -c | sort -nr | head -n 3</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据单机处理</title>
    <link href="/2023/09/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8D%95%E6%9C%BA%E5%A4%84%E7%90%86/"/>
    <url>/2023/09/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8D%95%E6%9C%BA%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="位图-存在-排序-去重"><a href="#位图-存在-排序-去重" class="headerlink" title="位图 - 存在, 排序, 去重"></a>位图 - 存在, 排序, 去重</h1><h3 id="T1-在40亿个QQ号中-判断一个QQ号是否存在"><a href="#T1-在40亿个QQ号中-判断一个QQ号是否存在" class="headerlink" title="T1: 在40亿个QQ号中, 判断一个QQ号是否存在"></a>T1: 在40亿个QQ号中, 判断一个QQ号是否存在</h3><p>在内存中, 用bit表示是否存在即可. 维护QQ与二进制位之间的关系<br>key是QQ号, value是这个整数对应的bit位</p><ul><li>申请长度为43亿的二进制位数组</li><li>对磁盘文件中的40亿条数据进行预处理(把对应QQ对应的位设置为1) - O(n)</li><li>拿到要判断的QQ, 以它为索引, 去查看它二进制位值 - O(1)</li></ul><p>优点: 可以节省内存<br>缺点: 只能处理有范围的正整数</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>对有范围 &#x2F; 没有重复的正整数进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-comment">// 申请8个比特位</span><br><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-comment">// 从左到右遍历</span><br></code></pre></td></tr></table></figure><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-comment">// 申请8个比特位</span><br><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-comment">// 从左到右遍历</span><br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BitMap</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] data;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BitMap</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br><span class="hljs-built_in">this</span>.size = size;<br><span class="hljs-comment">// 为了向上取整, 凑足一个byte</span><br><span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(size + <span class="hljs-number">7</span>)/ <span class="hljs-number">8</span>];<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-comment">// 有效范围是 0 ~ size-1</span><br><span class="hljs-keyword">if</span>(num &gt;= size) <span class="hljs-keyword">return</span> ;<br><br><span class="hljs-comment">// 找到整数所在的字节</span><br><span class="hljs-type">int</span> <span class="hljs-variable">byteIndex</span> <span class="hljs-operator">=</span> num / <span class="hljs-number">8</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> data[byteIndex];<br><br><span class="hljs-comment">// 找到整数所在的位</span><br><span class="hljs-type">int</span> <span class="hljs-variable">bitIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> - num % <span class="hljs-number">8</span>; <span class="hljs-comment">// 存在大小端的问题</span><br>data[byteIndex] = (<span class="hljs-type">byte</span>)(b | (<span class="hljs-number">1</span> &lt;&lt; bitIndex));<br>&#125;<br><span class="hljs-keyword">public</span> bool <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-keyword">if</span>(num &gt;= size) <span class="hljs-keyword">return</span> ;<br><span class="hljs-comment">// 找到整数所在的字节</span><br><span class="hljs-type">int</span> <span class="hljs-variable">byteIndex</span> <span class="hljs-operator">=</span> num / <span class="hljs-number">8</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> data[byteIndex];<br><br><span class="hljs-comment">// 找到整数所在的位</span><br><span class="hljs-type">int</span> <span class="hljs-variable">bitIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> - num % <span class="hljs-number">8</span>; <span class="hljs-comment">// 存在大小端的问题</span><br><span class="hljs-keyword">return</span> (b &amp; (<span class="hljs-number">1</span> &lt;&lt; bitIndex)) != <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2-40亿个QQ号码-限制1GB内存-如何快速去重"><a href="#T2-40亿个QQ号码-限制1GB内存-如何快速去重" class="headerlink" title="T2: 40亿个QQ号码, 限制1GB内存, 如何快速去重?"></a>T2: 40亿个QQ号码, 限制1GB内存, 如何快速去重?</h2><ol><li>初始化一个43亿大小的位图</li><li>遍历40亿个QQ号, 分别存储在位图中, 时间复杂度O(m)</li><li>遍历位图每一个位, 然后去除元素值为1对应的QQ号, 时间复杂度O(n)</li></ol><h2 id="T3-40一个QQ中找出不重复的QQ"><a href="#T3-40一个QQ中找出不重复的QQ" class="headerlink" title="T3: 40一个QQ中找出不重复的QQ"></a>T3: 40一个QQ中找出不重复的QQ</h2><p>2 bitmap<br>位图每位只能表达两种状态, 如果用两位bit表示的话, 就可以拿到4种状态.<br>但需要表示: 0次 &#x2F; 1次 &#x2F; 多次</p><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>外部排序: 借助磁盘文件的排序算法<br>内部排序: 基于内存的排序算法</p><h2 id="T4-限制1M内存-如何给1000万个整数进行排序"><a href="#T4-限制1M内存-如何给1000万个整数进行排序" class="headerlink" title="T4: 限制1M内存, 如何给1000万个整数进行排序?"></a>T4: 限制1M内存, 如何给1000万个整数进行排序?</h2><p>问题: 给定一个文件, 里面最多包含有n个不重复的正整数, 且每个数都小于等于10^7. 按从小到大升序排列该整数列表.</p><p>单纯使用位图, 会超出内存</p><ol><li>把大文件(1个文件, 1000万个整数)切分成小文件(50个文件, 每个文件20万个整数)</li><li>使用小文件进行内部排序(直接调用标准库算法即可)</li><li>将多个小文件进行多路归并排序(使用优先级队列, 每一路就是一个小文件, 进行归并)</li></ol><p>如果有四个文件需要按升序合并, 就初始化一个大小为4的小顶堆</p><h2 id="T5-1GB单词-如何拿到出现频率最高的100个单词"><a href="#T5-1GB单词-如何拿到出现频率最高的100个单词" class="headerlink" title="T5: 1GB单词, 如何拿到出现频率最高的100个单词?"></a>T5: 1GB单词, 如何拿到出现频率最高的100个单词?</h2><p><strong>内存足够</strong> -&gt; HashMap统计出现次数 -&gt; 按照出现次数排序 -&gt; 拿到频率最高的100个单词</p><p>求出现最多的100个单词 -&gt; 大小为100的小顶堆</p><blockquote><p>如果小于堆顶(100个元素中最小的), 根本不可能是最大的1&#x2F;100</p></blockquote><p><strong>内存不足</strong> -&gt; 排序后, 三个字段计算词频(prevWord, prevCnt, currWord), 并建立大小为100的小顶堆</p><ol><li>把大文件(1个文件, 1GB)进行切分, 分成多个小文件(2048个, 每512KB)</li><li>小文件进行内部排序</li><li>多路归并排序, 将小文件合并成一个有序的大文件</li><li>统计每个单词出现的次数</li><li>建立大小为100的小顶堆, 统计top100的频次</li></ol><p>因为有很多的文件操作, 太慢, 为了使相同的单词排在一起, 进行三次磁盘IO<br>如果一次文件读写, 就将相同的单词放到同一个小文件中, 那么就可以减少文件读写的次数</p><h1 id="哈希分治"><a href="#哈希分治" class="headerlink" title="哈希分治"></a>哈希分治</h1><p>通过哈希函数切分大文件, 更快, 但也有问题: 有一个单词出现很多次, 会放到一个文件中, 进而超过内存限制</p><p>如果<br>出现重复的单词数不多, 那么可以使用哈希分治 + HashMap + 小顶堆<br>出现重复的单词数很多, 可以使用外部排序 + 小顶堆</p><h3 id="T6-对100亿的URL进行查重-内存限制4GB"><a href="#T6-对100亿的URL进行查重-内存限制4GB" class="headerlink" title="T6: 对100亿的URL进行查重, 内存限制4GB"></a>T6: 对100亿的URL进行查重, 内存限制4GB</h3><p>问题: 给定a和b两个文件, 各存放50亿个URL, 每个URL占64B, 内存限制是4GB. 找出a和b中的共同的URL</p><p>一个文件的URL需要的内存: 50亿 * 64B &#x3D; 298GB, 远大于4GB</p><p>假设, 一个文件中相同的URL不会太多 -&gt; 哈希分治</p><p>50亿 * 64B &#x2F; 200 ~&#x3D;  1.5GB &lt; 4GB</p><ul><li>对大文件a中每一行进行哈希运算 hash(URL)%200, 将其放到不同的文件中(a1 ~ a200)</li><li>对大文件b中每一行进行哈希运算 hash(URL)%200, 将其放到不同的文件中(b1 ~ b200)</li><li>将其放到HashSet中</li></ul><p>问题: 太慢了, 读写大量的文件, 导致非常慢<br>使用布隆过滤器</p><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>有一定误判率<br>在位图上存储字符串<br>但存在问题: 哈希冲突, 不同字符串的哈希值可能相同</p><ul><li>判断成存在, 可能存在误判</li><li>判断成不存在, 一定是不存在</li></ul><p>冲突:</p><ul><li>不同字符串可能相同, 概率低 -&gt; 增加哈希函数, 得到多个哈希值 但仍可能存在冲突</li><li>不同字符串哈希值不同, 但取模的时候会冲突 -&gt; 扩大位图的大小</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式共识算法 - Raft</title>
    <link href="/2023/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Raft/"/>
    <url>/2023/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Raft/</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="如何提高大规模数据的读写性能"><a href="#如何提高大规模数据的读写性能" class="headerlink" title="如何提高大规模数据的读写性能"></a>如何提高大规模数据的读写性能</h2><ul><li>纵向拓展 - 更好的机器</li><li>横向拓展 - 更多的机器</li></ul><h3 id="横向分布式"><a href="#横向分布式" class="headerlink" title="横向分布式"></a>横向分布式</h3><ul><li>优势<br>数据备份 - 避免单点故障导致数据丢失或服务不可用<br>负载均衡 - 多个节点共同分担总任务</li><li>问题<br>多节点如何保持一致性<br>如何保证分布式系统的秩序(正常提供服务, 不出现脑裂&#x2F;崩溃&#x2F;耗时过长)</li></ul><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>一致性 Consistency &#x2F; 可用性 availability &#x2F; 分区容错性 partition tolerance<br>CAP三项性质中至多满足其二<br>单机系统, 自身就满足P; 分布式系统下, P是一定要保证的;<br>CP(Etcd) &#x2F; AP(Redis)</p><h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><h3 id="即时一致性"><a href="#即时一致性" class="headerlink" title="即时一致性"></a>即时一致性</h3><ul><li>主从备份(主节点接收写操作, 异步同步给从从节点, 从节点接收读操作)</li></ul><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>因为网络延迟, 前序的写操作没有同步完成就同步了后续的写操作<br>更严重, 因为记录了错误的数据, 后续客户端读取都是错误的数据</p><h2 id="可用性问题"><a href="#可用性问题" class="headerlink" title="可用性问题"></a>可用性问题</h2><p>每次写操作, 先同步到所有从节点后, 再回复客户端ACK</p><h2 id="木桶效应"><a href="#木桶效应" class="headerlink" title="木桶效应"></a>木桶效应</h2><p>CP也会尽可能保证A, 让A在及格的层面, AP也是如此<br>调和CA之间的矛盾</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h3><p>领导者 Leader - 发起提议, 提交多数派认可的决断<br>跟随者 Follower - 对提议, 提交与竞选进行响应<br>候选者 Candidate - 竞选流程的临时状态, 多数派投票后切为leader或follower</p><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>中强一致性, 最终可以提供正确的结果, 但需要时间进行同步</p><h3 id="即时一致性-1"><a href="#即时一致性-1" class="headerlink" title="即时一致性"></a>即时一致性</h3><p>强一致性, 服务端要求做到写入立即可以读到正确结果</p><h3 id="预写日志"><a href="#预写日志" class="headerlink" title="预写日志"></a>预写日志</h3><p>WAL 写记录前先写日志</p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>节点存储数据的介质</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>提议 - proposal, leader向所有阶段发起日志同步请求的过程<br>提交 - commit, leader认可一笔写请求被系统采纳的过程</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>将预写日志的内容写到状态机的过程</p><h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p>标识leader更迭, 每个任期至多只有一个leader</p><h3 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h3><p>日志在预写日志数组的位置</p><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>同一任期内出现两个leader</p><h2 id="多数派原则"><a href="#多数派原则" class="headerlink" title="多数派原则"></a>多数派原则</h2><p>多数派, 一个群体数量的一半以上<br>系统决断无需全员参与, 多数派达成的共识即可视为整个系统的答复.<br>提升容错率, 5个节点里, 如果有两个宕机了, 也可以正常完成.</p><h2 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h2><p>一个leader, 多个follower</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读操作, 由集群的任意节点提供服务;<br>写操作, 统一由leader处理, 并向follower同步, 如果follower接收到客户端的写操作, 也要转发给leader进行处理;</p><h2 id="预写日志-状态机"><a href="#预写日志-状态机" class="headerlink" title="预写日志 &#x2F; 状态机"></a>预写日志 &#x2F; 状态机</h2><p>先记录写请求的明细添加到日志数组, 当日志得到多数派认可后, 才能提交, 将变更应用到状态机当中<br>日志会有idx, 因此可以保证顺序一致性</p><h2 id="两阶段提交-1"><a href="#两阶段提交-1" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>流程</p><ol><li>leader接收客户端写请求</li><li>[提议, proposal]leader将写请求添加到本地预写日志, 并向其它节点广播同步</li><li>其它节点收到请求后, 校验是否可以同步</li><li>[提交, commit]集群中半数以上节点都添加了预写日志, 并返回ack, leader会提交请求, 并返回客户端ack</li><li>其它节点感知到提交, 也会在预写日志提交请求</li><li>最终一致性 -&gt; 异步应用; 立即一致性 -&gt; 先应用到状态机, 再返回客户端ack</li></ol><h2 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h2><p>leader挂了, follower补位成为leader<br>如何感知leader挂了? leader需要定期给follower发送心跳, follower会建立心跳检测定时器, 超时就认为已死, 自身切换成candidate发起竞选, 补位成为新的leader<br>什么样的follower有资格成为leader? follower成为candidate后, 会广播向所有节点拉票, 赞同达到多数派时, candidate会胜任, 成为新的leader</p><h2 id="任期与日志索引"><a href="#任期与日志索引" class="headerlink" title="任期与日志索引"></a>任期与日志索引</h2><p>发起竞选, 在当前term+1, 如果成为新的leader,  </p><p>term, 标识哪个任期的leader在位时同步时写入的<br>index, 标识预写日志数组的位置<br>通过{term, index} 可以组成一个全局唯一键, 定位到一则日志.</p><h1 id="角色流转"><a href="#角色流转" class="headerlink" title="角色流转"></a>角色流转</h1><h2 id="定义及切换"><a href="#定义及切换" class="headerlink" title="定义及切换"></a>定义及切换</h2><h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><p>两阶段提交<br>leader需要周期性地向所有节点发送自己的心跳, 告知自身健康情况<br>    让follower重置心跳检测定时器, 避免其切换成candidate发起竞选<br>    在心跳请求中带上leader最新已提交日志的id{term + index}, 推动follower更新日志提交进度</p><p>心跳是双向的, 发送心跳, 得到follower回复可以检查当前term是否合法</p><h2 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h2><p>同步leader传过来二等写请求<br>接收leader心跳, 获取commitIndex信息, 及时完成多数派认可的预写日志的提交, 推进器写入状态机的进度<br>为candidate进行投票<br>通过心跳检测定时器关注leader健康状态<br>candidate</p><h1 id="请求链路"><a href="#请求链路" class="headerlink" title="请求链路"></a>请求链路</h1><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><h3 id="整体链路"><a href="#整体链路" class="headerlink" title="整体链路"></a>整体链路</h3><h3 id="新的预写日志在末尾-commit-index之后"><a href="#新的预写日志在末尾-commit-index之后" class="headerlink" title="新的预写日志在末尾(commit index之后)"></a>新的预写日志在末尾(commit index之后)</h3><p>同步时, 会带上最后一笔日志的{term, index}; 前一笔日志的{term, index}; 以及自身的任期<br>follower接收到日志后, 会对比已有的最后一笔日志的标识是否和leader发过来的最后一笔一样<br>    如果一样才会接受, 接受后, 在自己的预写日志中追加日志, 回复ACK.<br>    如果不同, 会要求leader先把缺失部分的日志补齐, 返回具体的错误原因.<br>如果多数认可, leader就会commit请求[commitIndex后移, 将新日志放入commit].<br>    leader在同步心跳的时候, 会把新commit index进行同步</p><h3 id="bad-case"><a href="#bad-case" class="headerlink" title="bad case"></a>bad case</h3><p>case 1 - leader任期滞后<br>    follower拒绝同步请求, 并告知leader最新的term; leader感知到新term的存在, 会主动退位</p><p>case 2 - follower日志滞后<br>    follower要求已写入的日志和leader已写入的日志完全一致, 会追溯之前的日志</p><p>case 3 - follower日志超前<br>    证实leader的term合法性后, 将超前的日志移除, 之后同步leader传送的日志</p><p>case 4 - 将最终一致性提升为即时一致性<br>    把日志commit后, 要立即apply到状态机, 应用完成后再给ACK</p><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>整体链路<br>预写日志 + 二阶段提交 + 多数派原则 -&gt; 日志最终一致性 -&gt; 状态机最终一致性<br>最终一致性 -&gt; 即时一致性<br>    applied index校验<br>        写请求后, leader会把最新的applied index反馈给客户端;<br>        读请求时<br>            如果follower发现自身的applied index落后于客户端applied index, 说明数据存在滞后, 则拒绝请求, 由客户端发送给其它节点处理.<br>            如何大于, 则直接处理.</p><p>强制读主<br>    follower收到读请求时, 通过转发给leader处理.<br>    leader压力过大, 其它follower节点只能沦为备份数据的节点<br>    需要额外发起一次合法性身份证明, 如果得到多数派认可, 说明身份合法, 则对读请求进行响应.</p><p>内部请求链路<br>    日志同步请求<br>        请求参数<br>            term - leader的任期<br>            leaderID - leader的节点ID, 方便后续follower转发写请求<br>            leaderCommit - leader最新提交的日志index{term, index }, 方便follower更新数据进度<br>            prevLogIndex - 当前同步日志的前一条日志的index<br>            prevLogTerm - 当前同步日志的前一条日志的term<br>            log[] - 同步的日志, 可能为多笔, 因为follower可能滞后了多笔</p><pre><code class="hljs">心跳 &amp; 提交同步请求    请求参数        term - leader的任期        leaderID - leader的节点ID, 方便后续follower转发写请求        leaderCommit - leader最新提交的日志index 方便follower更新数据进度竞选拉票请求    整体流程    参数        term - candidate的竞选任期, 如果上位, 就采用次任期        candidateID - 方便follower标记自己将票投给了谁        lastLogIndex - 最后一笔预写日志的index        lastLogTerm - 最后一笔预写日志的term    candidate后处理        获得多数票, 晋升为leader, 竞选term为新的term        反对多数票, 退回follower        反对票中出现更高的term, 退回follower, 更新任期        形成决议前, 收到了任期大于等于自己的leader的请求, 退回follower, 更新term        拉票超时, 自增竞选任期, 发起新一轮竞选.</code></pre><p>集群变更<br>    集群新增节点<br>        leader统一处理<br>        laeder发起提议(proposal), 吧配置变更的日志广播给所有节点<br>        配置变更得到老结点的多数派认可, leader才会提交配置变更, 在配置参数中将新老两部分节点合并到一起<br>        配置变更期间, 需要老结点多数派的赞同票才可以当选<br>        配置变更期间, 处理写请求时,  需要在提议阶段得到老结点的多数派的认可, 才能提交.</p><pre><code class="hljs">bad case    脑裂问题 - 不遵循老结点多数派会遇到的问题</code></pre>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>共识算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的层式数据结构</title>
    <link href="/2023/09/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%82%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/09/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%82%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>应用: MySQL, MongoDB<br><img src="/img/Pasted%20image%2020230920231201.png"><br>多路平衡搜索树</p><p>特征:</p><ul><li>非叶子结点只存储索引信息</li><li>叶子结点存储数据信息</li><li>叶子节点之间依次相连</li></ul><p>为什么要多路<br>一个节点多条链路, 相较于平衡二叉树更是一个矮胖的结构, 树的高度比较低, 较少的磁盘IO次数来索引树中数据</p><p>为什么非叶子节点只存储索引信息<br>B+树节点映射固定大小的磁盘数据，可以包含更多的索引信息，能快速锁定数据所在叶子节点位置</p><p>为什么叶子节点依次<br>相连便于范围查询，避免中序遍历回溯去查找下一个节点</p><p>索引信息和数据信息的分层管理，便于高效地组织磁盘数据、快速实现单点和范围查询</p><h2 id="跳表-SkipList"><a href="#跳表-SkipList" class="headerlink" title="跳表 SkipList"></a>跳表 SkipList</h2><p>应用: Redis中的zset实现, rocksdb内存数据库<br><img src="/img/Pasted%20image%2020230920231040.png"><br>多层级有序链表</p><p>跳表特征:<br>1.基于链表实现的二分查找跳表特征<br>2.最底层链表包含所有数据信息</p><p>为什么增加链表层级</p><ul><li>实现跳跃查询，从而提升搜索性能节点</li></ul><p>什么时侯增加层高</p><ul><li>插入节点时随机层高</li></ul><p>为什么不选用红黑树</p><ul><li>范围查询</li><li>跳表范围查询遍历的节点更少</li></ul><p>通过增加链表层级, 实现二分查找, 同时底部链表包含所有数据, 便于范围查询</p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p>应用: kafka, netty, skynet<br><img src="/img/Pasted%20image%2020230920231129.png"><br>多层级时间轮<br>秒 0 1 … 59<br>分 0 1 … 59<br>时 0 1 … 23<br>每一层是一个循环数组, 通过链表指向不同的任务.</p><p>时间轮的特征:</p><ul><li>每层时间轮都有一个时间指针，按照当前层级的时间精度移动<ul><li>第1层级移动到哪，说明该时刻的任务到期该执行</li><li>其他层级时间指针移动到哪，需要往上一层级重新映射</li></ul></li><li>相同时的任务，通过链表链接起来</li></ul><p>通过增加层级，针对延时任务到期的轻重缓急进行分层管理，有效降低空间占用</p><h2 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h2><p>应用: RocksDB<br><img src="/img/Pasted%20image%2020230920230616.png"><br>LSM-Tree特征:</p><ol><li>内存分为memtable和immutable memtable(用于持久化)</li><li>磁盘分为L0~L6, SST</li></ol><p>冷热数据分离, 越热的数据越上面, 越冷的数据越下面</p><p>通过对数据的分层管理，实现磁盘顺序IO,有效解决磁盘写密集场景问题：<br>磁盘中文件分层，通过compaction进行数据合并压缩，实现更加紧凑的存储</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>B+Tree</category>
      
      <category>LSM</category>
      
      <category>SkipList</category>
      
      <category>TimeWheel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis - 缓存应用</title>
    <link href="/2023/09/05/Redis-%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8/"/>
    <url>/2023/09/05/Redis-%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/cache_all.png" alt="缓存一致性与缓存异常"><br>如何保证Redis中只存放1%的热点商品数据?</p><ol><li>LRU算法</li><li>设置key的过期时间</li></ol><h2 id="缓存例子"><a href="#缓存例子" class="headerlink" title="缓存例子"></a>缓存例子</h2><p> 无缓存的Web服务器<img src="/img/20230518164742.png" alt="20230518164742.png"><br>以Spring Boot为Web服务框架<br>模板引擎: 解析HTML中的动态数据<br>控制器(Controller): 接收并解析前端请求, 调用业务层获取数据, 并将数据给模板引擎<br>业务层(Service): 调用Dao拿到数据库数据, 并根据业务计算需要的数据<br>数据访问层(Dao): 操作数据库(MySQL)</p><h3 id="Spring-Boot操作Redis"><a href="#Spring-Boot操作Redis" class="headerlink" title="Spring Boot操作Redis"></a>Spring Boot操作Redis</h3><p>RedisTemplate<br>三个客户端:</p><ol><li>Jedis<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 建立TCP连接</span><br><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>jedis.auth(<span class="hljs-string">&quot;123456&quot;</span>);<br>jedis.select(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 操作Redis</span><br>jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;bing&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(res);<br><span class="hljs-comment">// 释放连接</span><br>jedis.close();<br></code></pre></td></tr></table></figure></li><li>Lettuce<br>可同步, 也可以异步</li><li>Redisson</li></ol><p>Spring Boot中的RedisTemplate封装了Jedis和Lettuce两种客户端, 默认使用Lettuce</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class="hljs-comment">// 操作字符串</span><br>stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;bing&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(val);<br><br><span class="hljs-comment">// 操作list, opsForType</span><br>stringRedisTemplate.optsForList().rightPushAll(<span class="hljs-string">&quot;list1&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForList().rightPop(<span class="hljs-string">&quot;list1&quot;</span>);<br>System.out.println(res);<br></code></pre></td></tr></table></figure><h3 id="引入Redis作为MySQL缓存"><a href="#引入Redis作为MySQL缓存" class="headerlink" title="引入Redis作为MySQL缓存"></a>引入Redis作为MySQL缓存</h3><p><img src="/img/20230518172535.png" alt="20230518172535.png"><br>数据库容易达到瓶颈, 引入Redis后<br><img src="/img/20230518173137.png" alt="20230518173137.png"></p><ul><li>以JSON string进行存储<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 先容Redis缓存查询</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shop:&quot;</span> + id;<br><span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span> &amp;&amp; !shopJson.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> JSON.parseObject(shopJson, Shop.class);<br>&#125;<br><span class="hljs-comment">// 2. 未命中, 从数据库查询</span><br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> shopDao.queryById(id);<br><span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 3. 将数据设置到redis中</span><br>stringRedisTemplate.opsForValue().set(key, JSON.toJSONString(shop));<br><span class="hljs-keyword">return</span> shop;<br></code></pre></td></tr></table></figure>每次访问都要访问到大多数字段; 对象里字段不会高频率更新; 对象数据比较大;</li><li>以Hash进行存储<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 先容Redis缓存查询</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shop:&quot;</span> + id;<br>Map&lt;Object, Object&gt; map = stringRedisTemplate.opsForHash().entries(key);<br><span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span> &amp;&amp; !map.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> Shop.buildFromMap(map);<br>&#125;<br><span class="hljs-comment">// 2. 未命中, 从数据库查询</span><br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> shopDao.queryById(id);<br><span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 3. 将数据设置到redis中</span><br>stringRedisTemplate.opsForHash().putAll(key, shop.genMap()); <span class="hljs-comment">// HMSET</span><br><span class="hljs-keyword">return</span> shop;<br></code></pre></td></tr></table></figure>每次访问都要访问到个别数字段; 对象里字段会高频率更新; 对象数据比较小, hash会采用ziplist的压缩结构, 空间占用和string一样;</li></ul><h2 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h2><p>只更新数据库, 但未更新缓存, 就会存在不一致问题</p><h3 id="定时器-定时同步MySQL数据到Redis中"><a href="#定时器-定时同步MySQL数据到Redis中" class="headerlink" title="定时器, 定时同步MySQL数据到Redis中"></a>定时器, 定时同步MySQL数据到Redis中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncShops2RedisTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>logger.info(<span class="hljs-string">&quot;[启动] 同步商铺数据定时任务&quot;</span>);<br><span class="hljs-comment">// quartz</span><br><span class="hljs-type">TimerTask</span>  <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>logger.info(<span class="hljs-string">&quot;[开始执行] 同步商铺数据&quot;</span>);<br><span class="hljs-comment">// 1. 从MySQL拿到所有的商铺数据</span><br>List&lt;Shop&gt; shops = shopDao.queryAll();<br><span class="hljs-comment">// 2. 写到Redis缓存</span><br>shops.forEach(shop -&gt; &#123;<br>stringRedisTemplate<br>.opsForValue()<br>.set(<span class="hljs-string">&quot;shop:&quot;</span>+shop.getId(), JSON.toJSONString(shop));<br>&#125;);<br>logger.info(<span class="hljs-string">&quot;[结束执行] 同步商铺数据&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().sceduleAtFixedRate(task, <span class="hljs-number">1000</span>, <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>适合数据量比较少的场景.<br>实时性不好, 在定时器间隔内, 仍不会更新缓存, 存在60s内的数据不一致.</p><h3 id="同时更新数据库和Redis缓存-“并发双写”"><a href="#同时更新数据库和Redis缓存-“并发双写”" class="headerlink" title="同时更新数据库和Redis缓存, “并发双写”"></a>同时更新数据库和Redis缓存, “并发双写”</h3><p>在更新MySQL的同时, 更新缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 更新MySQL</span><br><span class="hljs-comment">// 1.1 评论数加一</span><br>shopDao.incCommentsById(comment.getShopId());<br><span class="hljs-comment">// 1.2 将评论插入评论表</span><br>commentDao.insert(comment);<br><br><span class="hljs-comment">// 2. 更新redis缓存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shop:&quot;</span> + comment.getShopId();<br><span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span> &amp;&amp; !shopJson.isEmpty()) &#123;<br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSON.parseObject(shopJson, Shop.class);<br>shop.SetComments(shop.getComments() + <span class="hljs-number">1</span>);<br>stringRedisTemplate.opsForValue().set(key, JSON.toJSONString(shop));<br>&#125;<br></code></pre></td></tr></table></figure><p>单线程无所谓, 但高并发场景下就存在一致性问题: 并发双写<br><img src="/img/20230518204739.png" alt="20230518204739.png"><br>加锁, 会损失性能.</p><h3 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h3><p><img src="/img/20230518204857.png" alt="20230518204857.png"><br><img src="/img/20230518204927.png" alt="20230518204927.png"></p><h4 id="先删除Redis缓存-再更新数据库-“延迟双删”"><a href="#先删除Redis缓存-再更新数据库-“延迟双删”" class="headerlink" title="先删除Redis缓存, 再更新数据库, “延迟双删”"></a>先删除Redis缓存, 再更新数据库, “延迟双删”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 先删除缓存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shop:&quot;</span> + comment.getShopId();<br>stringRedisTemplate.delete(key);<br><span class="hljs-comment">// 2. 更新MySQL</span><br><span class="hljs-comment">// 2.1 评论数加一</span><br>shopDao.incCommentsById(comment.getShopId());<br><span class="hljs-comment">// 2.2 将评论插入评论表</span><br>commentDao.insert(comment);<br></code></pre></td></tr></table></figure><p>再次查询的时候, 缓存内无相关内容, 会进行缓存重建.<br><img src="/img/20230518205350.png" alt="20230518205350.png"><br>此时一致<br> <img src="/img/20230518205546.png" alt="20230518205546.png"><br> 此时数据不一致, 可以通过双删解决, 虽然也存在不一致, 但情况好很多.<br> <img src="/img/20230518205707.png" alt="20230518205707.png"><br> 但如果重建缓存时间比较长, 也会存在不一致情况<br> <img src="/img/20230518205914.png" alt="20230518205914.png"><br> 此时可以通过, 延迟双删解决, 延迟时间要大于线程2读取MySQL + 写入缓存的时间, 经验值1~5s.<br> <img src="/img/20230518205944.png" alt="20230518205944.png"><br> 一般不会使用, 高并发下做延迟太损失性能.</p><h4 id="先更新数据库-再删除Redis缓存-“异步更新缓存”"><a href="#先更新数据库-再删除Redis缓存-“异步更新缓存”" class="headerlink" title="先更新数据库, 再删除Redis缓存, “异步更新缓存”"></a>先更新数据库, 再删除Redis缓存, “异步更新缓存”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 更新MySQL</span><br><span class="hljs-comment">// 1.1 评论数加一</span><br>shopDao.incCommentsById(comment.getShopId());<br><span class="hljs-comment">// 1.2 将评论插入评论表</span><br>commentDao.insert(comment);<br><span class="hljs-comment">// 2. 删除缓存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shop:&quot;</span> + comment.getShopId();<br>stringRedisTempla te.delete(key);<br></code></pre></td></tr></table></figure><p><img src="/img/20230518210424.png" alt="20230518210424.png"><br>会有较短时间(几百毫秒)内的数据不一致.<br>先删除缓存, 数据不一致的情况比较严重写. 所以一般使用后删除缓存. 但在删除缓存失败时也会存在问题<br><img src="/img/20230518212010.png" alt="20230518212010.png"><br>这种情况, 可以通过给key添加过期时间解决.<br><img src="/img/20230518212823.png" alt="20230518212823.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">stringRedisTemplate.opsForValue()<br>.set(key, JSON.toJSONString(shop), <span class="hljs-number">30</span>, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><p>最长也就存在30分钟, 但概率极小, 但也不能忍受, 可以通过重试删除缓存.<br><img src="/img/20230518213555.png" alt="20230518213555.png"><br>但不能立马重试删除, 原因如下:</p><ol><li>立即重试大概率还会失败</li><li>重试次数的设置</li><li>重试会一直占用线程资源, 无法服务其他客户端请求<br>所以可以采用异步重试来解决, 或者直接发给消息队列, 让消息队列删除, 该线程不删除缓存.<br><img src="/img/20230518213741.png" alt="20230518213741.png"><br>但也不完美, 较为完美的方式是订阅MySQL的binlog, 后再删除缓存.<br><img src="/img/20230518214020.png" alt="20230518214020.png"><br>异步删除缓存期间, 数据会有短时间的不一致.</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/img/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="总结"></p><h2 id="缓存异常问题"><a href="#缓存异常问题" class="headerlink" title="缓存异常问题"></a>缓存异常问题</h2><h3 id="缓存穿透-布隆过滤器"><a href="#缓存穿透-布隆过滤器" class="headerlink" title="缓存穿透, 布隆过滤器"></a>缓存穿透, 布隆过滤器</h3><p>访问一个缓存和数据库都不存在的key,此时请求会直接访问到数据库并且查不到数据，没法写缓存，所以下次请求同样会访问到数据库上.<br>此时，缓存起不到作用，请求每次都会走到数据库，流量大时数据库可能会被打挂。此时缓存就好像被”穿透”了一样，起不到任何作用<br>三种方案</p><h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><p>有用户恶意攻击, 自增ID容易被攻击, 设计成不规则的会好些.</p><h4 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h4><p>访问缓存和数据库都没有的值时, 会将空值放入缓存<br><img src="/img/20230518221200.png" alt="20230518221200.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 先从Redis缓存查询</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shop:&quot;</span> + id;<br><span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 如果redis中存放的是空字符串, 则说明MySQL中不存在数据</span><br><span class="hljs-keyword">if</span> (shopJson.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> JSON.parseObject(shopJson, Shop.class);<br>&#125;<br><span class="hljs-comment">// 2. 未命中, 从数据库查询</span><br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> shopDao.queryById(id);<br><span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 数据库中也不存在, 缓存空值</span><br>stringRedisTemplate.opsForValue(<span class="hljs-string">&quot;shop:&quot;</span>+id, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 3. 将数据设置到redis中</span><br></code></pre></td></tr></table></figure><p>此种方案会导致Redis占用较大的内存</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>高效的判断商铺ID是否存在 – HashSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(!shopIDSet.containes(id)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>在Spring中, 实现<code>Initializing</code>接口, 实现<code>afterPropertiesSet</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在设置当前这个类的属性的时候, 会执行</span><br><span class="hljs-comment">// 1. 查询所有的ID</span><br>List&lt;Long&gt; ids = shopDao.queryAllIDs();<br><span class="hljs-comment">// 2. 将商铺ID设置到shopIDSet</span><br>shopIDSet.addAll(ids);<br></code></pre></td></tr></table></figure><p>动态修改<code>shopIDSet</code>.<br>新增商铺的时候 <code>shopIDSet.add(shopID);</code><br>当数据量大了之后, 假设有100k, HashSet效率很低. 每个ID需要8个字节, 如果1m, 要762MB, 可以通过布隆过滤器解决.</p><p>布隆过滤器: 有一个固定大小的二进制数组(位图, BitMap)和一系列哈希函数组成<br><img src="/img/20230518224634.png" alt="20230518224634.png"><br>布隆过滤器判断某个值存在, 小概率会误判. 如果误判对比一下字符串即可.<br>布隆过滤器判定某个值不存在, 则这个元素一定不存在.<br>布隆过滤器只能增加和查询, 不能删除<br>使用Guava创建布隆过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建BloomFilter</span><br>BloomFilter&lt;String&gt; bloomFilter = BloomFilter<br>.create(Funnels.stringFunnel(Charset.defaultCharset(), <span class="hljs-number">1000000</span>));<br><span class="hljs-comment">// 2. 往BloomFilter中添加值</span><br>bloomFilter.put(<span class="hljs-string">&quot;Bing&quot;</span>);<br><span class="hljs-comment">// 3. 判断某个值是否存在于BloomFilter中</span><br><span class="hljs-type">bool</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> blommFilter.mightContain(<span class="hljs-string">&quot;Bing&quot;</span>);<br></code></pre></td></tr></table></figure><p>缓冲空值可以为布隆过滤器兜底, 因为布隆过滤器可能存在误判.</p><blockquote><p>新增Shop和查询Shop可能不是一个系统, 因此需要通过中间件实现布隆过滤器<br><img src="/img/20230519155128.png" alt="20230519155128.png"><br>使用Redis创建布隆过滤器(基于BitMap), Redisson实现过</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">RBloomFilter&lt;String&gt; bloomFilter = redissonClient.getBloomFilter(<span class="hljs-string">&quot;bf&quot;</span>);<br>bloomFilter.tryInit(<span class="hljs-number">10</span>, <span class="hljs-number">0.03</span>); <span class="hljs-comment">// 预期插入的次数, 误差率</span><br>bloomFilter.add(<span class="hljs-string">&quot;bing1&quot;</span>);<br>bloomFilter.add(<span class="hljs-string">&quot;bing2&quot;</span>);<br><br><span class="hljs-type">bool</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> bloomFilter.contains(<span class="hljs-string">&quot;bing1&quot;</span>);<br></code></pre></td></tr></table></figure><p>Redis服务端也提供了BloomFilter, 以独立模块的形式存在, 下载源码, 进行编译, 得到redisbloom.so, <code>cp redisbloom.so /usr/local/bin</code>, 再修改<code>redis.conf</code>. 添加<code>loadmoudle /usr/local/bin/redisbloom.so</code><br><code>BF.ADD mybf 199</code> 向bloom filter里添加值<br><code>BF.EXISTS mybf 199</code>判断199在mybf中是否存在<br>在Java中, 可以通过lua脚本使用. </p><h3 id="缓存击穿-互斥锁-逻辑过期"><a href="#缓存击穿-互斥锁-逻辑过期" class="headerlink" title="缓存击穿, 互斥锁, 逻辑过期"></a>缓存击穿, 互斥锁, 逻辑过期</h3><p>少部分热点key过期, 这些热点key的重建业务比较复杂<br>缓存击穿: 一个缓存重建业务较复杂的热点key突然失效了, 无数的请求访问会在瞬间给数据库带来巨大的冲击<br><img src="/img/20230519161509.png" alt="20230519161509.png"></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>保证只有一个线程进行缓存重建<br><img src="/img/20230519161707.png" alt="20230519161707.png"><br><img src="/img/20230519161957.png" alt="20230519161957.png"><br>同时获取互斥锁, 只有一个成功, 成功后释放互斥锁, 其它线程加锁成功, 因此需要二次查缓存避免重复重建缓存. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行SETNX成功, 返回true则表示获取锁.</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br><span class="hljs-type">Boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> stringRedisTemplate<br>.opsForValue() <br>.setIfAbsent(key, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><span class="hljs-keyword">return</span> res == <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 释放锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>stringRedisTemplate.delete(key);<br>&#125;<br><br><span class="hljs-comment">// 业务</span><br><span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br><span class="hljs-keyword">if</span> (!isLock) &#123;<br><span class="hljs-comment">// 没有拿到互斥锁, 说明已经有一个线程在重建了</span><br><span class="hljs-comment">// 当前线程只需要休眠很小的一段时间, 然后尝试从缓存中拿</span><br>TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">60</span>);<br>shop = findShopFromCache(key);<br><span class="hljs-keyword">if</span> (shop != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> shop;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 再次检查商铺中是否有数据</span><br><span class="hljs-comment">// 用于处理这种场景：重建缓存的线程释放锁，当前线程拿到锁</span><br>shop = findShopFromCache(key);<br><span class="hljs-keyword">if</span> (shop != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> shop;<br>shop = shopDao.queryByID(id);<br><span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 将数据设置到Redis缓存</span><br>stringRedisTemplate.opsForValue()<br>.set(key, JSON.toJSONString(shop), <span class="hljs-number">300</span> + random.nextInt(<span class="hljs-number">5</span>), TimeUnit.MINUTES);<br><span class="hljs-keyword">return</span> shop;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>logger.error(<span class="hljs-string">&quot;重建商铺缓存失败&quot;</span>, e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>unlock(lockKey);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用互斥解决缓存穿透的话, 会有大量的线程处于等待, 可以通过逻辑过期解决</p></blockquote><p> <img src="/img/20230519172929.png" alt="20230519172929.png"><br> <img src="/img/20230519175021.png" alt="20230519175021.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_THREAD_POLL</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 判断是否过期</span><br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSON.parseObject(shopJson, Shop.class);<br><span class="hljs-type">LocalDatetime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> shop.getExpireTime();<br><span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;<br><span class="hljs-comment">// 没有过期, 直接返回</span><br><span class="hljs-keyword">return</span> shop; <br>&#125;<br><span class="hljs-comment">// 已经过期, 重建缓存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;<br><span class="hljs-keyword">if</span> (tryLock(lockKey)) &#123;<br><span class="hljs-type">Shop</span> <span class="hljs-variable">cacheShop</span> <span class="hljs-operator">=</span> findShopFromCache(key);<br><span class="hljs-keyword">if</span>(cacheShop != <span class="hljs-literal">null</span> <br>&amp;&amp; cacheShop.getExpireTime().isAfter(LocalDateTime.now()))  &#123;<br><span class="hljs-keyword">return</span> cacheShop;<br>&#125;<br><span class="hljs-comment">// 获取锁成功, 开启独立线程, 执行缓存重建</span><br>CACHE_REBUILD_THREAD_POOL.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> shopDao.queryByID(id);<br>shop.setExpireTime(LocalDateTime.now().plusSeconds(<span class="hljs-number">300</span>));<br>stringRedisTemplate.opsForValue().set(key, JSON.toJSONString(shop));<br>&#125; finnaly &#123;<br>unlock(lockKey);<br>&#125;<br>&#125;<br>&#125;);<br>&#125;<br><br><span class="hljs-comment">// 加锁不成功直接返回过期的数据</span><br><span class="hljs-keyword">return</span> shop;<br></code></pre></td></tr></table></figure><table><thead><tr><th>解决方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>互斥锁</td><td>1. 没有额外内存消耗 2. 保证数据一致性 3.实现简单</td><td>1.线程需要等待, 影响性能 2. 可能有死锁风险</td></tr><tr><td>逻辑过期</td><td>1.线程无需等待, 性能较好</td><td>1. 不能保证数据一致性 2. 有额外的内存消耗 3. 实现复杂</td></tr></tbody></table><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>热点key: 经常被大量用户访问的key.<br>这一类热点数据, 我们一般会提前将他们放到Redis中, 这一步叫数据的预热<br>缓存雪崩: 大量的热点key都设置了相同的过期时间, 导致缓存在同一时刻全部失效, 造成瞬时数据库请求量大, 压力骤增, 引起雪崩, 甚至数据库被打挂.<br>解决方案: 给不同的key的TTL添加随机值<br><img src="/img/20230519161152.png" alt="20230519161152.png"><br>Redis挂掉了, 解决方案: 利用Redis集群, 提高Redis的可用性</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT over QUIC</title>
    <link href="/2023/09/02/MQTT-over-QUIC/"/>
    <url>/2023/09/02/MQTT-over-QUIC/</url>
    
    <content type="html"><![CDATA[<h1 id="MQTT介绍"><a href="#MQTT介绍" class="headerlink" title="MQTT介绍"></a>MQTT介绍</h1><ul><li>物联网广泛应用车联网 &#x2F; 工业制造 &#x2F; 能源电力 &#x2F; 智能家居, </li><li>相比于HTTP这种文本协议报文紧凑, 对流量敏感场景友好</li><li>二进制协议, 可以承载任何数据, JSON &#x2F; Protobuf &#x2F; Ciphertext</li><li>发布订阅机制, 轻耦合, 更加专注于业务逻辑的开发, 开发效率提升, 灵活的新增减少主题, 增加发布者订阅者</li><li>三个QoS等级, 对网络质量要求比较宽容</li><li>生态成熟, 各个平台都有<br>传输层可以提供有序 &#x2F; 可靠 &#x2F; 双向字节流即可(TCP &#x2F; WebSocket)</li></ul><h1 id="TCP传输协议的不足"><a href="#TCP传输协议的不足" class="headerlink" title="TCP传输协议的不足"></a>TCP传输协议的不足</h1><h2 id="依靠四元组标识连接"><a href="#依靠四元组标识连接" class="headerlink" title="依靠四元组标识连接"></a>依靠四元组标识连接</h2><p>通过四元组区分报文属于哪个连接<br>回家: 基站到WiFi<br>车辆: 基站A到基站B<br>IP发生变更, 如果继续发送数据, 服务器收到后找不到对应的四元组, 直接丢弃该TCP报文. 如果要继续通信, 必须断开原有的四元组, 重新创建连接.</p><h3 id="连接耗时"><a href="#连接耗时" class="headerlink" title="连接耗时"></a>连接耗时</h3><p>TCP握手需要时间, MQTT握手也需要时间.<br>建立MQTT连接, 需要2 RTT (几十 ~ 几百ms)<br><img src="/img/Pasted%20image%2020230827211631.png"><br>为了通信安全还回引入TLS握手, 此时建立连接需要4 RTT<br><img src="/img/Pasted%20image%2020230827211729.png"><br>建立连接的时候, 无法传送数据, 但应用层还在不断地增加数据, 会产生堆积, 产生延迟</p><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><p>QoS &#x3D; 0, 数据直接丢失<br>QoS &#x3D; 1或2, 数据虽然不会丢失, 但是浪费带宽, 且增加了延迟</p><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>连接断开, 重连后, 无法立即获得重连前的传输速率<br><img src="/img/Pasted%20image%2020230827212426.png"><br>加入到新网络中, 还不了解, 就先不发送太多的数据.<br>如果重连后, 需要发送一个大报文, 就会把这个大报文拆成很多个小报文分成多次传输给对端.</p><h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><p>TCP按顺序到达, 同时传输多个消息, 传输路径不同. 后发送的可能先到达, 先到达的数据只能缓存下来.<br><img src="/img/Pasted%20image%2020230827212711.png"><br>有些情况下, 消息并没有先后顺序, 但受限于队头阻塞, 紧急消息无法及时到达</p><h2 id="TCP单流"><a href="#TCP单流" class="headerlink" title="TCP单流"></a>TCP单流</h2><p><img src="/img/Pasted%20image%2020230827212935.png"></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>网络比较差的时候, 不能发送太大的报文, 进一步增加网络拥堵.<br>Reno, CUBIC, BBR<br>很难升级, 定制化变更.</p><h2 id="重传的序列号"><a href="#重传的序列号" class="headerlink" title="重传的序列号"></a>重传的序列号</h2><p>重传的时候是相同的序列号, 无法区分是原始报文, 还是重传报文, 会导致错误的估计RTT.<br><img src="/img/Pasted%20image%2020230827213446.png"><br>RTT偏小, 过于乐观, 加剧拥堵; RTT偏大, 无法有效利用.<br>为了解决这个问题, 增加了10字节的时间戳.<br><img src="/img/Pasted%20image%2020230827213613.png"><br>对带宽敏感的场景并不友好, 关闭时间戳可以减少1%</p><h1 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h1><p>quick udp internet connections. Google 2013年推出<br><img src="/img/Pasted%20image%2020230827213743.png"><br>HTTP&#x2F;3弃用TCP, 选择QUIC<br><img src="/img/Pasted%20image%2020230827221538.png"><br>首次连接, 1 RTT<br>恢复连接, 0 RTT<br>TLS 1.3 无降级风险<br>密码套件 AES256-GCM-SHA256<br>可插拔的拥塞控制算法 - 运行时可以调整<br>无重传歧义<br><img src="/img/Pasted%20image%2020230827221803.png"><br>连接迁移</p><ul><li>避免消息音链接断开而丢失</li><li>NAT重绑定导致端口变化时, 传输速率将不受影响<br><img src="/img/Pasted%20image%2020230827221917.png"><br>多路复用<br>极大改善队头阻塞问题<br><img src="/img/Pasted%20image%2020230827222044.png"><br>紧急数据可以优先发送<br><img src="/img/Pasted%20image%2020230827222119.png"><br>可以设置优先级<br><img src="/img/Pasted%20image%2020230827222205.png"><br>多路复用<br><img src="/img/Pasted%20image%2020230827222341.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>QUIC</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 4</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-4/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-4/</url>
    
    <content type="html"><![CDATA[<p>Quality Of Service 服务等级</p><ul><li>QoS 0 最多交付一次</li><li>QoS 1 至少交付一次</li><li>QoS 2 仅交付一次</li></ul><h3 id="为什么QoS-0消息会丢失"><a href="#为什么QoS-0消息会丢失" class="headerlink" title="为什么QoS 0消息会丢失"></a>为什么QoS 0消息会丢失</h3><ol><li>调用API发送消息</li><li>消息被拷贝到内核层的发送缓冲区</li><li>在合适的时机, 消息被发送到网络中</li><li>经过几个路由的跳转后, 消息来到对端的接收缓冲区, 通知上层应用</li><li>消息被读取到应用</li></ol><p>任何一步骤出现问题, 消息都会丢失</p><h3 id="QoS1-通过Puback报文进行重传"><a href="#QoS1-通过Puback报文进行重传" class="headerlink" title="QoS1 通过Puback报文进行重传"></a>QoS1 通过Puback报文进行重传</h3><p><img src="/img/20230427123116.png" alt="20230427123116.png"><br><img src="/img/20230427123136.png" alt="20230427123136.png"><br>消息可能重复 </p><h3 id="为什么QoS1的消息会重复"><a href="#为什么QoS1的消息会重复" class="headerlink" title="为什么QoS1的消息会重复"></a>为什么QoS1的消息会重复</h3><p><img src="/img/20230427123315.png" alt="20230427123315.png"><br>为什么被当做新消息处理</p><ul><li>情况一, 确实是需要重传的消息<br><img src="/img/20230427123358.png" alt="20230427123358.png"></li><li>情况二, Packet ID被重用. 消息确实是一个全新的消息.<br><img src="/img/20230427123511.png" alt="20230427123511.png"></li></ul><p>也可能出现多次重传<br><img src="/img/20230427123605.png" alt="20230427123605.png"></p><h3 id="如何为QoS-1去重"><a href="#如何为QoS-1去重" class="headerlink" title="如何为QoS 1去重"></a>如何为QoS 1去重</h3><p>时间戳 或者 单调递增的计数</p><h3 id="重传不等于乱序"><a href="#重传不等于乱序" class="headerlink" title="重传不等于乱序"></a>重传不等于乱序</h3><p>发送 ABC<br>实际到达 AABC &#x2F; ABABC 但不可能出现BAC</p><h3 id="QoS-2报文"><a href="#QoS-2报文" class="headerlink" title="QoS 2报文"></a>QoS 2报文</h3><ul><li>PUBLISH</li><li>PUBREC<br>publish receive, 表示收到了publish报文; 与PUBACK类似, 但PUBACK用于QoS1</li><li>PUBREL<br>publish release, 表示准备释放本次的QoS 2消息</li><li>PUBCOMP<br>publish complete, 表示本次QoS 2的消息即将完成<br><img src="/img/20230427124231.png" alt="20230427124231.png"></li></ul><h3 id="不同QoS使用场景"><a href="#不同QoS使用场景" class="headerlink" title="不同QoS使用场景"></a>不同QoS使用场景</h3><ul><li>QoS 0<br>优点: 投递效率高<br>缺点: 消息可能丢失<br>适用场景: 传输高频且不那么重要的数据, 例如传感器数据</li><li>QoS 1<br>优点: 保证消息到达<br>缺点: 消息可能重复<br>适用场景: 传输较为重要的数据, 例如下达关键指令, 更新重要的实时性要求的状态等<br>注意事项: 能够处理重复消息, 或者允许重复消息, eg: 扫码签收包裹</li><li>QoS 2<br>优点: 保证消息到达且不会重复<br>缺点: 拥有最高的开销<br>适用场景: 传输重要数据, 并且能够接受QoS2带来的额外开销<br>开销几乎是QoS1的两倍</li></ul>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 3</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-3/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-3/</url>
    
    <content type="html"><![CDATA[<p>MQTT会话</p><ul><li>什么是会话</li><li>会话能够解决什么问题</li><li>不同生命周期会话的区别</li></ul><p><img src="/img/20230413203229.png" alt="20230413203229.png"><br>对应话题没有订阅者, 就会丢弃已发送的消息<br><img src="/img/20230413203317.png" alt="20230413203317.png"><br>不应该随着连接断开而消失, 应该缓存下来<br><img src="/img/20230413203410.png" alt="20230413203410.png"><br>持久会话:<br><img src="/img/20230413203418.png" alt="20230413203418.png"><br>通常还会和ClientID进行关联<br><img src="/img/20230413203455.png" alt="20230413203455.png"><br>服务端还需要存储:</p><ol><li><p>客户端的订阅信息</p><blockquote><p>重连后不需要重新进行订阅</p></blockquote></li><li><p>已发送, 但还没未完成确认的QoS 1和QoS 2消息</p></li><li><p>等待发送的QoS 0, QoS 1和QoS 2消息<br><img src="/img/20230413203657.png" alt="20230413203657.png"></p><blockquote><p>包含上次连接未发送的消息, 以及在离线时收到的消息</p></blockquote></li><li><p>从客户端收到的, 还没有完全确认的QoS 2消息</p></li><li><p>遗嘱消息和遗嘱延迟间隔</p></li><li><p>会话是否存在<br>客户端需要存储:</p></li><li><p>已经发送给服务端但还未确认的QoS 1, QoS 2消息</p></li><li><p>收到但未确认的QoS 2消息</p></li></ol><p> 两个字段</p><ul><li>Clean Start<br>Clean Start &#x3D; 0<blockquote><p>尝试从已经存在的会话中恢复通信, 如果不存在则创建全新的会话<br><img src="/img/20230413204131.png" alt="20230413204131.png"><br>Clean Start &#x3D; 1<br>即使存在对应的会话, 也会丢弃, 创建全新的会话<br><img src="/img/20230413204218.png" alt="20230413204218.png"></p></blockquote></li><li>Session Expiry Interval<br>指定会话在连接断开后能够保留的最长时间</li></ul><ol><li>val &#x3D; 0<br>会话将在网络连接断开时结束</li><li>val &gt; 0<br>会话将在连接断开的多少秒后过期</li><li>val &#x3D; 0xFFFFFFFF<br>会话永不过期</li></ol><p>要求建立全新的会话<br><img src="/img/20230413204522.png" alt="20230413204522.png"><br>因为网络波动, 导致异常断开连接, 客户端能够保留会话状态<br><img src="/img/20230413204653.png" alt="20230413204653.png"><br>上述都是在MQTT 5.0中的特性, 在MQTT 3.1.1中, 只有Clean Session字段</p><ul><li>Clean Session &#x3D; 0<br>等价于<br>Clean Start &#x3D; 0, 尝试复用已存在的会话;<br>Session Expiry Interval &#x3D; 0xFFFFFFFF, 会话永不过期</li><li>Clean Session &#x3D; 1<br>Clean Start &#x3D; 1, 永远创建全新的会话;<br>Session Expiry Interval &#x3D; 0, 会话的声明周期与网络连接相同</li></ul><p>在MQTT 3.1.1中, 如果要丢弃之前的会话, 并且建立新链接的会话要保持, 必须先用Clean Session &#x3D; 1 丢弃之前的连接, 之后断开连接, 再用Clean Session &#x3D; 0 建立新的保持会话的连接.</p><p>持久会话:</p><ol><li>不希望错过离线期间的消息</li><li>不希望QoS 1和QoS 2消息丢失</li><li>不希望每次连接都要重新建立订阅</li><li>设备定期休眠, 不希望长时间维护连接<br>不需要持久会话:</li><li>只对外发布QoS 0消息, 不会接收任何消息</li><li>只订阅QoS 0消息, 不关心离线期间的消息</li></ol>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 2</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-2/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-2/</url>
    
    <content type="html"><![CDATA[<h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p><img src="/img/20230323223119.png" alt="20230323223119.png"><br>Topic Name: UTF-8 String<br>QoS: Integer</p><blockquote><p>QoS 0: 消息可能丢失<br>QoS 1: 消息不会丢失但可能重复<br>QoS 2: 消息不会丢失也不会重复</p></blockquote><p>Payload: Binary<br><img src="/img/20230323223329.png" alt="20230323223329.png"><br>保留消息<br><img src="/img/20230323223622.png" alt="20230323223622.png"><br>正常转发的同时, 也会在本地保存副本, 当有新的客户端建立订阅时, 保留消息就会下发给客户端.<br><img src="/img/20230323223744.png" alt="20230323223744.png"></p><h3 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h3><p><img src="/img/20230323223826.png" alt="20230323223826.png"><br>Packet ID<br><img src="/img/20230323223904.png" alt="20230323223904.png"><br>Subscription List</p><blockquote><p>可以一次订阅多个报文<br><img src="/img/20230323223936.png" alt="20230323223936.png"><br>Topic Filter 可以使用主题通配符<br><img src="/img/20230323224020.png" alt="20230323224020.png"><br> <strong>但发布时不能使用主题通配符</strong></p></blockquote><p>发布QoS &#x3D; 2的消息, 但接收端QoS &#x3D; 1, QoS &#x3D; 2的消息将会被降级<br><img src="/img/20230323224214.png" alt="20230323224214.png"><br>如果没有超过最大QoS, 则保持不变<br><img src="/img/20230323224301.png" alt="20230323224301.png"><br>使用相同主题过滤器的新订阅将覆盖旧订阅<br>消息将转发给所有匹配的订阅<br><img src="/img/20230323224425.png" alt="20230323224425.png"><br>订阅回复报文<br><img src="/img/20230323224451.png" alt="20230323224451.png"><br>Reason Codes<br><img src="/img/20230323224515.png" alt="20230323224515.png"><br>Granted Maximum QoS - 可能小于订阅时的Maximum QoS<br><img src="/img/20230323224614.png" alt="20230323224614.png"><br><img src="/img/20230323224628.png" alt="20230323224628.png"></p><h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p><img src="/img/20230323224648.png" alt="20230323224648.png"><br>想要取消订阅的Topic Filter-&gt; 完全的文本匹配 -&gt; 实际订阅的Topic Filter<br><img src="/img/20230323224713.png" alt="20230323224713.png"><br><img src="/img/20230323224804.png" alt="20230323224804.png"></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>类型 UTF-8字符串<br>最大长度 65535字节<br>区分大小写</p><h3 id="主题通配符"><a href="#主题通配符" class="headerlink" title="主题通配符"></a>主题通配符</h3><ul><li>单层通配符<br><img src="/img/20230323224919.png" alt="20230323224919.png"><br><img src="/img/20230323224938.png" alt="20230323224938.png"><br><img src="/img/20230323225024.png" alt="20230323225024.png"><br>一个单层通配符不能匹配多个层级, 但可以通过多个通配符实现<br><img src="/img/20230323225127.png" alt="20230323225127.png"></li><li>多层通配符<br> <code>#</code>可以匹配任意数量个层级<br> <img src="/img/20230323225312.png" alt="20230323225312.png"><br> <img src="/img/20230323225326.png" alt="20230323225326.png"><br> 单层和多层可以搭配使用<br> <img src="/img/20230323225354.png" alt="20230323225354.png"><br>主题名 在发布时不支持主题通配符<br>主题过滤器 在订阅和取消订阅时使用, 支持主题通配符</li><li>特殊主题<br>以<code>$</code>开头的主题, 由服务器使用, 客户端只能订阅, 不能发布.<br><img src="/img/20230323225600.png" alt="20230323225600.png"><br><code>#</code>并不包含<code>$SYS</code>主题, 需要明确指定<code>$SYS/#</code></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>不建议主题以<code>/</code>开头或结尾</li><li>尽量仅使用ASCII字符</li><li>不建议在主题使用空格</li><li>不建议使用<code>#</code>订阅所有主题</li><li>尽量使用简洁的主题</li><li>在主题中包含标识信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 1</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-1/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-1/</url>
    
    <content type="html"><![CDATA[<p>MQTT 3.1.1 全解</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>基于发布订阅模型的轻量级的消息传输协议</p><ul><li>发布订阅<br>发布者 - 代理(接收订阅, Broker) - 订阅者</li><li>轻量<br>集成简单 &#x2F; 传输编解码友好</li></ul><p>专为受限设备和低带宽&#x2F;高延迟&#x2F;不可靠网络设计<br>发布订阅 &#x2F; 简单 &#x2F; 轻量 &#x2F; 可靠交付</p><p>MQTT 1.0 IBM内部使用<br>MQTT 3.1 开放给所有人使用<br>MQTT 3.1.1 提交给OASIS进行标准修订<br>MQTT 5.0 2019年发布, MQTT最新版本, 最重要的一次升级</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="通信模式"><a href="#通信模式" class="headerlink" title="通信模式"></a>通信模式</h3><p><img src="/img/20230323121323.png" alt="20230323121323.png"><br>不同与HTTP的请求响应模式, MQTT采用发布订阅模式<br>因此, MQTT可以实现多种通信模式<br><img src="/img/20230323121351.png" alt="20230323121351.png"></p><h3 id="可靠网络"><a href="#可靠网络" class="headerlink" title="可靠网络"></a>可靠网络</h3><p>为了实现消息可靠, 在传输层选择了TCP协议.<br>如果简单的密码验证无法满足需求, 还是建立在TLS之上, 实现消息的加密.<br>如果需要在Web上进行使用, MQTT还可以建立在WebSocket之上</p><h3 id="服务质量-QoS"><a href="#服务质量-QoS" class="headerlink" title="服务质量 QoS"></a>服务质量 QoS</h3><ul><li>QoS 0 - 消息可能丢失 &lt;&#x3D; 1</li><li>QoS 1 - 消息不会丢失, 但可能重复 &gt;&#x3D; 1</li><li>QoS 2- 消息不会丢失, 也不会重复 &#x3D;&#x3D; 1</li></ul><h3 id="心跳保活-KeepAlive"><a href="#心跳保活-KeepAlive" class="headerlink" title="心跳保活 KeepAlive"></a>心跳保活 KeepAlive</h3><p>链接很容易进入假死状态, 为了减少对上层的影响, 需要尽快的感知到连接的异常状态.<br>但TCP的KeepAlive时间过长, 所以MQTT也自定义了心跳机制</p><h3 id="遗嘱-Will-Message"><a href="#遗嘱-Will-Message" class="headerlink" title="遗嘱 Will Message"></a>遗嘱 Will Message</h3><p>通讯双方无法感知到设备是否在线, 为了解决该问题引入遗嘱机制.<br>连接时会设置好遗嘱内容, 一旦代理发现链接异常断开, 就会向订阅了这个遗嘱Topic的客户端发送信息.</p><h3 id="保留消息-Retained-Message"><a href="#保留消息-Retained-Message" class="headerlink" title="保留消息 Retained Message"></a>保留消息 Retained Message</h3><p>如果客户端不在线, 就会错过该消息, 如果不想这样, 就可以设置保留消息, 会让Broker保留向某个主题发送的最后一条消息. 订阅者上线, Broker就会把消息发送给它.</p><h2 id="报文基础"><a href="#报文基础" class="headerlink" title="报文基础"></a>报文基础</h2><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p>连接</p><ul><li>CONNECT<blockquote><p>包含客户端标识&#x2F;用户名&#x2F;密码&#x2F;遗嘱消息</p></blockquote></li><li>CONNACK</li><li>DISCONNECT<br>发布</li><li>PUBLISH<blockquote><p>主题&#x2F;QoS&#x2F;Payload</p></blockquote></li><li>PUBACK</li><li>PUBREC</li><li>PUBREL</li><li>PUBCOMP<br>订阅</li><li>SUBSCRIBE<blockquote><p>主题&#x2F;QoS</p></blockquote></li><li>SUBACK</li><li>UNSUBSCRIBE</li><li>UNSUNACK<br>心跳</li><li>PINGREQ</li><li>PINGRESP</li></ul><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>固定报头Fixed Header - 所有控制报文</p><ul><li>报文类型</li><li>标志</li><li>剩余报文长度<br>可变报头Variable Header - 部分控制报文</li><li>内容视报文类型而定<br>有效载荷Payload - 不分控制论文</li><li>内容视报文类型而定</li></ul><p>Publish报文<br><img src="/img/20230323123059.png" alt="20230323123059.png"><br>心跳报文仅需两个字节<br><img src="/img/20230323123029.png" alt="20230323123029.png"></p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p><img src="/img/20230323123925.png" alt="20230323123925.png"><br>发布者并不知道订阅者是否收到了消息, 为了解决该问题, 需要在业务层面确认消息<br><img src="/img/20230323124104.png" alt="20230323124104.png"></p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>先通过三次握手建立TCP连接 至少2 RTT<br> <img src="/img/20230323124205.png" alt="20230323124205.png"><br> Client ID唯一标识了一个会话, 因此必须全局唯一<br> <img src="/img/20230323124252.png" alt="20230323124252.png"><br> MQTT连接的建立<br> <img src="/img/20230323124447.png" alt="20230323124447.png"><br> 如果client id为0, broker会分配一个全局唯一的cleint id, 通过connack报文返回, 但由于是临时分配的, 后续无法使用持久会话.<br>  <img src="/img/20230323124640.png" alt="20230323124640.png"><br>协议名<br><img src="/img/20230323124718.png" alt="20230323124718.png"><br>协议级别<br><img src="/img/20230323124740.png" alt="20230323124740.png"><br>用户名和密码<br>User Name &amp; Password<br>认证 &amp; 授权<br><img src="/img/20230323124846.png" alt="20230323124846.png"><br><img src="/img/20230323124857.png" alt="20230323124857.png"><br>保活 Keep Alive<br><img src="/img/20230323124958.png" alt="20230323124958.png"><br>1.5倍的Keep Alive Interval没有收到心跳包 则断开连接<br><img src="/img/20230323125033.png" alt="20230323125033.png"><br><img src="/img/20230323125100.png" alt="20230323125100.png"><br>最大允许的保活间隔 18H12M15S</p><p>断开连接 DISCONNECT<br>客户端发起, 因此不会发布遗嘱信息<br><img src="/img/20230323125207.png" alt="20230323125207.png"><br>超时也会断开连接<br><img src="/img/20230323125237.png" alt="20230323125237.png"><br>Broker主动断开<br><img src="/img/20230323125332.png" alt="20230323125332.png"></p>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化与自动内存管理</title>
    <link href="/2023/09/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/09/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="性能优化是什么？"><a href="#性能优化是什么？" class="headerlink" title="性能优化是什么？"></a>性能优化是什么？</h2><ul><li>提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力</li></ul><p> 为什么要做性能优化？</p><ul><li>用户体验：带来用户体验的提升 – 让刷抖音更丝滑，让双十一购物不再卡顿</li><li>资源高效利用：降低成本，提高效率 – 很小的优化乘以海量机器会是显著的性能提升和成本节约</li></ul><h3 id="性能优化的层面"><a href="#性能优化的层面" class="headerlink" title="性能优化的层面"></a>性能优化的层面</h3><ul><li>业务层优化<br>针对特定场景，具体问题，具体分析<br>容易获得较大性能收益</li><li>语言运行时优化<br>解决更通用的性能问题<br>考虑更多场景<br>Tradeoffs</li><li>数据驱动<br>自动化性能分析工具 – pprof<br>依靠数据而非猜测<br>首先优化最大瓶颈</li></ul><h3 id="性能优化与软件质量"><a href="#性能优化与软件质量" class="headerlink" title="性能优化与软件质量"></a>性能优化与软件质量</h3><ul><li>软件质量至关重要</li><li>在保证接口稳定的前提下改进具体实现</li><li>测试用例：覆盖尽可能多的场景，方便回归</li><li>文档：做了什么，没做什么，能达到怎样的效果</li><li>隔离：通过选项控制是香开启优化</li><li>可观测：必要的日志输出<br><img src="/img/20230515193448.png" alt="20230515193448.png"></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>性能优化的基本问题</li><li>性能优化的两个层面</li><li>性能优化的可维护性</li></ul><h2 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h2><ul><li>动态内存<ul><li>程序在运行时根据需求动态分配的内存：malloc()</li></ul></li><li>自动内存管理(垃圾回收)：由程序语言的运行时系统管理动态内存<ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的<strong>正确性</strong>和<strong>安全性</strong>：double-free problem,use-after–free problem</li></ul></li><li>三个任务<ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul></li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Mutator: 业务线程, 分配新对象, 修改对象指向关系<br>Collector: GC线程, 找到存活对象, 回收死亡对象的内存空间<br>Serial GC: 只有一个collector<br>Parallel GC: 支持多个collectors 同时回收的GC算法<br><img src="/img/20230515194758.png" alt="20230515194758.png"><br>Concurrent GC: mutator(s)和collector(s)可以<strong>同时执行</strong><br>    - <strong>Collectors必须感知对象指向关系的改变!</strong><br><img src="/img/20230515194403.png" alt="20230515194403.png"><br>a. 会有暂停 b.只有一个collector<br><img src="/img/20230515194411.png" alt="20230515194411.png"><br>a. 会有暂停 b.有多个collector<br><img src="/img/20230515194425.png" alt="20230515194425.png"><br>a. 不需要暂停 b.有多个collector</p><p>评价GC</p><ul><li>安全性(Safety): 不能回收存活的对象 <strong>基本要求</strong></li><li>吞吐率(Throughput): 1 - (GC时间 &#x2F; 程序执行时间) <strong>花在GC上的时间</strong></li><li>暂停时间(Pause Time): stop the word(STW) <strong>业务是否感知</strong></li><li>内存开销(Space Overhead) GC原数据开销</li></ul><h3 id="追踪垃圾回收-Tracing-garbage-collection"><a href="#追踪垃圾回收-Tracing-garbage-collection" class="headerlink" title="追踪垃圾回收(Tracing garbage collection)"></a>追踪垃圾回收(Tracing garbage collection)</h3><p>对象被回收的条件</p><ol><li>指针指向关系不可达的的对象<blockquote><p>静态变量, 全局变量, 常量, 线程栈等</p></blockquote></li><li>标记: 找到可达对象<blockquote><p>求指针指向关系的传递闭包: 从跟对象出发, 找到所有可达对象 </p></blockquote></li><li>清理: 所有不可达对象<blockquote><p>不同的清理策略(根据对象的生命周期, 使用不同的标记和清理策略)</p><ul><li>将存活对象复制到另外的内存空间(Copying GC)<br>  <img src="/img/20230515200449.png" alt="20230515200449.png"></li><li>将死亡对象的内存标记为”可分配”(Mark-sweep GC)<br>  使用free list管理空闲内存<br>  <img src="/img/20230515200423.png" alt="20230515200423.png"></li><li>移动并整理存活对象(Mark-compack GC)<br>  原地整理对象<br>  <img src="/img/20230515200409.png" alt="20230515200409.png"><br><img src="/img/20230515200006.png" alt="20230515200006.png"></li></ul></blockquote></li></ol><h3 id="分代GC-Generational-GC"><a href="#分代GC-Generational-GC" class="headerlink" title="分代GC(Generational GC)"></a>分代GC(Generational GC)</h3><ul><li>分代假说(Generational hypothesis): most objects die young</li><li>很多对象在分配出来后很快就不再使用了</li><li>每个对象都有年龄: 经历过GC的次数</li><li>目的: 对年轻的和老年的对象, 制定不同的GC策略, 降低整体内存管理的开销</li><li>不同年龄的对象处于heap的不同区域<br><img src="/img/20230515201220.png" alt="20230515201220.png"></li><li>年轻代(Young generation)<ul><li>常规的对象分配</li><li>由于存活对象很少, 可以采用copying collection</li><li>GC吞吐率很高</li></ul></li><li>老年代(Old Generation)<ul><li>对象趋向于一直或者, 反复复制开销比较大</li><li>可以采用 mark-sweep collection</li></ul></li></ul><h3 id="引用计数-Reference-counting"><a href="#引用计数-Reference-counting" class="headerlink" title="引用计数(Reference counting)"></a>引用计数(Reference counting)</h3><ul><li>每个对象都有一个与之关联的引用数目</li><li>对象存活的条件: 当且仅当引用数大于0</li><li>优点<ul><li>内存管理的操作被平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节: C++智能指针(smart pointer)</li></ul></li><li>缺点<ul><li>维护引用计数的开销较大: 通过原子操作保证对引用计数操作的原子性和可见性</li><li>无法回收环形数据结构 - weak reference</li><li>内存开销: 每个对象都引入的额外内存空间存储引用数目</li><li>回收内存时依然可能引发暂停</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>垃圾回收</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾回收</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的单例模式</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用场景:</p><ul><li>只允许存在一个实例的类 - 全局统一的监控统计模块</li><li>实例化很耗费资源的类 - 连接池, 客户端登</li><li>入参繁杂的系统模块组件 - controller, service, dao等</li></ul><h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><p>从一开始就完成单例的初始化工作;<br>不够智能, 如果一直不被用到, 但初始化了, 就造成了浪费.</p><p>步骤</p><ul><li>单例类和构造方法不可导出</li><li>代码启动之初就初始化全局单一的实例</li><li>暴露一个可导出的单例获取方法GetXXX()</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-comment">// singleton是需要被单例模式保护的类型</span><br><span class="hljs-comment">// 首字母小写, 不可导出, 避免被外界直接获取</span><br><span class="hljs-keyword">var</span> s *singleton<br><br><span class="hljs-comment">// 完成singleton的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>s = newSingleton()<br>&#125;<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Working...&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 创建singleton</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 外部获取单一实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码导出了私有的类</p><ul><li>不符合规范, 私有还要导出?</li><li>只能拿到实例, 执行实例的方法, 无法传参, 比较鸡肋<br>以下是更为规范的写法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-comment">// singleton是需要被单例模式保护的类型</span><br><span class="hljs-comment">// 首字母小写, 不可导出, 避免被外界直接获取</span><br><span class="hljs-keyword">var</span> s *singleton<br><br><span class="hljs-comment">// 完成singleton的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>s = newSingleton()<br>&#125;<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Working...&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 创建singleton</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// singleton 实现了Instance接口</span><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br>Work()<br>&#125;<br><br><span class="hljs-comment">// 外部获取单一实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *Instance &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// 外部获取单一实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p>需要被使用了, 才会执行单例的初始化;<br>只有用的时候才可能发现问题.</p><p>步骤</p><ul><li>单例类和构造方法不可导出</li><li>代码启动之初就初始化全局单一的实例</li><li>暴露一个可导出的单例获取方法GetXXX()</li><li>在这个获取方法被调用时, 会判断单例是否被初始化过, 倘若没有, 则在此时才完成初始化工作</li></ul><h3 id="并发不安全"><a href="#并发不安全" class="headerlink" title="并发不安全"></a>并发不安全</h3><p>并发访问GetInstance方法, 导致实例可能被创建多次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">var</span> s *singleton<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br>    <span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() &#123;<br>&#125;<br><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br>    Work()<br>&#125;<br><br><span class="hljs-comment">// 并发访问的时候, 单例可能创建多次</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>        s = newSingleton()<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一加锁"><a href="#统一加锁" class="headerlink" title="统一加锁"></a>统一加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>s *singleton<br>mu sync.Mutex<br>)<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Working...&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br>Work()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br>mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br><span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>s = newSingleton()<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是否完成初始化, 都需要先获取锁, 造成了浪费.</p><h3 id="未初始化再加锁"><a href="#未初始化再加锁" class="headerlink" title="未初始化再加锁"></a>未初始化再加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br><span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>mu.Lock()<br>defere mu.Unlock()<br>s = newSingleton()<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>但存在bad case.  多个协程在未初始化的时候同时到达, 但只有一个获取了锁, 进行了初始化, 之后释放. 其它等待锁的协程获得了锁, 再次进行初始化. 导致类被实例化多次</p><h3 id="二次检查"><a href="#二次检查" class="headerlink" title="二次检查"></a>二次检查</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br><span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br><span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>s = newSingleton()<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用Golang的sync-Once"><a href="#使用Golang的sync-Once" class="headerlink" title="使用Golang的sync.Once"></a>使用Golang的sync.Once</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>s = newSingleton()<br>&#125;)<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Golang单例工具-sync-Once源码"><a href="#Golang单例工具-sync-Once源码" class="headerlink" title="Golang单例工具 sync.Once源码"></a>Golang单例工具 sync.Once源码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sync<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 通过一个整型变量标识，once 保护的函数是否已经被执行过</span><br>    done <span class="hljs-type">uint32</span><br>    <span class="hljs-comment">// 一把锁，在并发场景下保护临界资源 done 字段只能串行访问</span><br>    m    Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>    <span class="hljs-comment">// 锁外的第一次 check，读取 Once.done 的值</span><br>    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>        o.doSlow(f)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>    <span class="hljs-comment">// 加锁</span><br>    o.m.Lock()<br>    <span class="hljs-keyword">defer</span> o.m.Unlock()<br>    <span class="hljs-comment">// double check</span><br>    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 任务执行完成后，将 Once.done 标识为 1</span><br>        <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 保证全局唯一一次执行用户注入的任务</span><br>        f()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁</title>
    <link href="/2023/09/02/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2023/09/02/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<ul><li>主动轮询型: Redis &#x2F; MySQL<br>类似单机锁的主动轮询 + cas乐观锁模型, 取锁房会持续对分布式锁发出尝试获取操作, 如果锁已经被占用则会不断发起重试, 直到获取锁成功为止</li></ul><p>优势: 无需阻塞操作, 短期来看操作比较轻<br>劣势: 长时间抢不到锁, 会浪费CPU时间片<br>适合场景: 并发竞争强度低的场景</p><ul><li>watch回调型: etcd &#x2F; zookeeper<br>在取锁方发现锁已经他人占用时, 会创建watcher监听订阅锁的释放时间, 随后不再主动发起获取锁的尝试; 当锁被释放后, 取锁方能通过之前创建的watcher感知到这一变化, 然后再重新发起获取锁的尝试动作</li></ul><p>优势: 精准打击, 不浪费CPU时间片<br>劣势: 需要挂起协程, 进行上下文切换, 操作比较重<br>适合场景: 并发竞争激烈的场景</p><p>在分布式场景下, 轮询式会存在大量网络IO, 代价比较高.</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>核心性质</p><ol><li>独占: 统一时刻只能被一个取锁方占有</li><li>健壮: 不能产生死锁, 某有持锁者因宕机不能释放锁, 锁也应该被正常传承下去, 被其他适用方使用</li><li>对称: 加锁和解锁必须是同一身份, 不允许非法释放他人持有的分布式锁</li><li>高可用: 基础组件少量节点出现故障时, 不能影响到分布式锁的稳定性</li></ol><h2 id="主动轮询型"><a href="#主动轮询型" class="headerlink" title="主动轮询型"></a>主动轮询型</h2><ul><li>加锁<br>SETNX(set only if not exist, deprecated)<br>将value设置为持有者标识</li><li>解锁<br>对称性:  先检查锁标识, 是持有者才可以解锁. 通过Lua脚本实现<ul><li>检查释放锁动作执行者的身份</li><li>身份合法才可以进行解锁</li></ul></li></ul><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>Redis设置一个过期时间, 进行兜底.<br>但, 可能存在操作时间长, 但锁被提前自动释放, 导致出现一锁多方持有.</p><h2 id="Redis-AP流派"><a href="#Redis-AP流派" class="headerlink" title="Redis - AP流派"></a>Redis - AP流派</h2><p>在分区容错的情况下, 着重保护可用性. 会存在若一致问题.<br>Redis肯定不是单点 -&gt; 主从复制;<br>可能存在问题</p><ol><li>master节点加锁成功, 完成数据写入;</li><li>master宕机, 数据还没有同步给slave; </li><li>其它请求者也可以获得锁<br>此问题有解决方案: Redis红锁(redis distribution lock)</li></ol><h2 id="watch回调型"><a href="#watch回调型" class="headerlink" title="watch回调型"></a>watch回调型</h2><p>取锁失败后, 不会持续轮询, 而是会watch监听锁的删除事件</p><p>不仅需要支持对数据的存和去重, 还需要利用其中的watch监听回调功能进行锁释放事件的订阅感知<br>支持的常用组件: etcd, zookeeper</p><h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>适用于共享配置 &#x2F; 服务发现的分布式kv存储组件, 底层基于分布式共识算法Raft协议, 保证了存储服务的强一致性和高可用性.<br>也可提供持续续约, 秩序取锁的统筹协调能力</p><h4 id="死锁问题-租约-续约"><a href="#死锁问题-租约-续约" class="headerlink" title="死锁问题 - 租约 &#x2F; 续约"></a>死锁问题 - 租约 &#x2F; 续约</h4><p>租约机制,  具有时效性的协议, 一旦达到组约上规定的截止时间, 租约失去效力. 同时, etcd也提供了续约机制(keepAlive), 用户可以通过续约操作来延迟租约过期时间. 与Redisson中的watch dog很像.</p><ul><li>用户现申请一个租约, 设定好租约截止时间(可以短一些, 乐观一些)</li><li>一步启动一个续约协程, 负责业务逻辑处理完成前, 按照一定的时间节奏持续进行续约操作</li><li>执行取锁动作, 将对应于锁的kv数据和租约进行关联绑定, 使得锁数据和租约拥有相同的过期时间属性</li></ul><h4 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h4><p>如果锁的竞争比较激烈, 锁的释放事件被多个取锁方监听, 一旦锁真的被释放, 所有取锁方都会尝试加锁, 但只有一个可以成功, 因此会存在大量无意义的性能损耗.</p><p>etcd中通过prefix机制以及版本revision机制</p><ul><li>对于一把分布式锁, 锁记录数据的key拥有共同的前缀, 作为锁的标识</li><li>每个取锁方都会以锁前缀prefix拼接上自身的身份标识(id), 生成完整的lock key, 因此各个取锁方完整的lock key都不相同, 理论上所有的取锁方都能成功把所记录插入etcd中</li><li>每个取锁方插入锁记录时, 会获得自身lock key处在锁前缀prefix返回下唯一且递增的版本号revision</li><li>取锁方插入加锁记录并不意味着成功, 而是需要在插入数据后, 查询一个锁前缀prefix下的记录列表, 判定自身lock key对应的revision是不是其中最小的, 如果是, 才加锁成功</li><li>如果锁被其它人占用, 取锁方会watch监听revision小于自己但最接近自己的那个lock key的删除事件.</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中Context的实现原理</title>
    <link href="/2023/09/02/Go%E4%B8%ADContext%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/02/Go%E4%B8%ADContext%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>主要用在异步场景中用于实现并发协调以及对Goroutine的生命周期控制, 兼有一定的数据存储能力.</p><h1 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h1><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">// 返回ctx过期的时间</span><br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 返回用以标识ctx是否结束的</span><br>Err() <span class="hljs-type">error</span> <span class="hljs-comment">// 返回ctx的错误</span><br>Value(key any) any <span class="hljs-comment">// 返回ctx存放的对应于key的value</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标准error"><a href="#标准error" class="headerlink" title="标准error"></a>标准error</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Canceled = errors.New(<span class="hljs-string">&quot;context canceled&quot;</span>) <span class="hljs-comment">// context被取消时报此错误</span><br><span class="hljs-keyword">var</span> DealineExceeded <span class="hljs-type">error</span> = deadlineExceededError&#123;&#125; <span class="hljs-comment">// context超时时报此错误</span><br><span class="hljs-keyword">type</span> deadlineExceededError <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;context deadline&quot;</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span></span> Timeout() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span></span> Temporary() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br></code></pre></td></tr></table></figure><h1 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h1><h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>根Context都是空Context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-type">int</span> <span class="hljs-comment">// 空context, 但本质上是一个整形</span><br><br><span class="hljs-comment">// 返回一个公元元年时间以及 false 的 flag，标识当前 context 不存在过期时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 返回一个 nil 值，用户无论往 nil 中写入或者读取数据，均会陷入阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// 读取信号 永远阻塞</span><br>&#125;<br><br><span class="hljs-comment">// 返回的错误永远为 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 返回的 value 同样永远为 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Value(key any) any &#123;<br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context-Background-与-context-TODO"><a href="#context-Background-与-context-TODO" class="headerlink" title="context.Background() 与 context.TODO()"></a>context.Background() 与 context.TODO()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    background = <span class="hljs-built_in">new</span>(emptyCtx)<br>    todo       = <span class="hljs-built_in">new</span>(emptyCtx)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span></span> Context &#123;<br>    <span class="hljs-keyword">return</span> background<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span> Context &#123;<br>    <span class="hljs-keyword">return</span> todo<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h1><p>一个父Ctx会有多个子Ctx, 子Ctx在父Ctx上添加能力<br>治理: 生命周期终止传递的单向性, 某一Context终止, 从上向下传递终止信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>    Context <span class="hljs-comment">// 内置Context, 指向父Context. cancelCtx必然是某个context的子context</span><br><br>    mu       sync.Mutex            <span class="hljs-comment">// protects following fields</span><br>    done     atomic.Value          <span class="hljs-comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span><br>    children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// set to nil by the first cancel call</span><br>    err      <span class="hljs-type">error</span>                 <span class="hljs-comment">// set to non-nil by the first cancel call</span><br>&#125;<br><br><span class="hljs-keyword">type</span> canceler <span class="hljs-keyword">interface</span> &#123;<br>    cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>)<br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现Context接口, 需要实现Deadline, Done, Err 和 Value方法</p><h2 id="Deadline方法"><a href="#Deadline方法" class="headerlink" title="Deadline方法"></a>Deadline方法</h2><p>cancelCtx没有实现该方法, 仅仅是内置了一个带有Deadline方法的Context Interface, 因此如果直接调用会报错</p><h2 id="Done方法"><a href="#Done方法" class="headerlink" title="Done方法"></a>Done方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>    d := c.done.Load()<br>    <span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br>    d = c.done.Load()<br>    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>        d = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>        c.done.Store(d)<br>    &#125;<br>    <span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>基于atomic包, 读取cancelCtx中的chan, 如果已经存在, 则直接返回</li><li>加锁后, 再次检查chan是否存在, 若存在则返回; (double check)</li><li>初始化chan存储到actomic.Value当中, 并返回. (懒加载机制)</li></ul><h2 id="Err方法"><a href="#Err方法" class="headerlink" title="Err方法"></a>Err方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br>    c.mu.Lock()<br>    err := c.err<br>    c.mu.Unlock()<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加锁</li><li>读取cancelCtx.err;</li><li>解锁</li><li>返回结果</li></ul><h2 id="Value方法"><a href="#Value方法" class="headerlink" title="Value方法"></a>Value方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Value(key any) any &#123;<br>    <span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br>        <span class="hljs-keyword">return</span> c<br>    &#125;<br>    <span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果key等于&amp;cancelCtxKey特定值, 则返回cancelCtx自身的指针</li><li>否则遵循valueCtx的思路取值返回</li></ul><h2 id="context-WithCancel"><a href="#context-WithCancel" class="headerlink" title="context.WithCancel()"></a>context.WithCancel()</h2><p>在父context的基础上添加取消</p><h3 id="context-WithCancel-1"><a href="#context-WithCancel-1" class="headerlink" title="context.WithCancel()"></a>context.WithCancel()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;<br>    <span class="hljs-comment">// 校验父 context 非空；</span><br>    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 注入父 context 构造好一个新的 cancelCtx</span><br>    c := newCancelCtx(parent)  <br>    <span class="hljs-comment">// 在 propagateCancel 方法内启动一个守护协程，以保证父 context 终止时，该 cancelCtx 也会被终止；</span><br>    propagateCancel(parent, &amp;c)<br>    <span class="hljs-comment">// 将 cancelCtx 返回，连带返回一个用以终止该 cancelCtx 的闭包函数.</span><br>    <span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="newCancelCtx"><a href="#newCancelCtx" class="headerlink" title="newCancelCtx"></a>newCancelCtx</h3><p>注入父 context 后，返回一个新的 cancelCtx.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCancelCtx</span><span class="hljs-params">(parent Context)</span></span> cancelCtx &#123;<br>    <span class="hljs-keyword">return</span> cancelCtx&#123;Context: parent&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="propagateCancel"><a href="#propagateCancel" class="headerlink" title="propagateCancel"></a>propagateCancel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br><span class="hljs-comment">// 父永远不会取消,  就不用实现传播特性</span><br>    done := parent.Done()<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span><br>    &#125;<br><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-done:<br>        <span class="hljs-comment">// parent is already canceled</span><br>        child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>    &#125;<br><span class="hljs-comment">// 如果父是cancelCtx, 只需要将自己添加到父亲的children中</span><br>    <span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>        p.mu.Lock()<br>        <span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// parent has already been canceled</span><br>            child.cancel(<span class="hljs-literal">false</span>, p.err)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>                p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>            &#125;<br>            p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        &#125;<br>        p.mu.Unlock()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果不是cancelCtx </span><br>        atomic.AddInt32(&amp;goroutines, +<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 守护协程</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-parent.Done(): <span class="hljs-comment">// 父亲是否终止</span><br>                child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br>            <span class="hljs-keyword">case</span> &lt;-child.Done(): <span class="hljs-comment">// 孩子终止, 无需做什么</span><br>            &#125;<br>        &#125;()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>校验parent是否为cancelCtx类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span></span> (*cancelCtx, <span class="hljs-type">bool</span>) &#123;<br>    done := parent.Done()<br>    <span class="hljs-keyword">if</span> done == closedchan || done == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    pdone, _ := p.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">if</span> pdone != done &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cancelCtx-cancel"><a href="#cancelCtx-cancel" class="headerlink" title="cancelCtx.cancel"></a>cancelCtx.cancel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>        c.mu.Unlock()<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span><br>    &#125;<br>    c.err = err<br>    <span class="hljs-comment">// 处理 cancelCtx 的 channel</span><br>    <span class="hljs-comment">// 若 channel 此前未初始化，则直接注入一个 closedChan，否则关闭该 channel</span><br>    d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>        c.done.Store(closedchan)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">close</span>(d)<br>    &#125;<br>    <span class="hljs-comment">// 遍历当前 cancelCtx 的 children set，依次将 children context 都进行 cancel</span><br>    <span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span><br>        child.cancel(<span class="hljs-literal">false</span>, err)<br>    &#125;<br>    c.children = <span class="hljs-literal">nil</span><br>    c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> removeFromParent &#123;<br>        removeChild(c.Context, c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将cancelCt从parent的children set中移除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeChild</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>    <span class="hljs-comment">// 如果 parent 不是 cancelCtx，直接返回（因为只有 cancelCtx 才有 children set）</span><br>    p, ok := parentCancelCtx(parent)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    p.mu.Lock()<br>    <span class="hljs-keyword">if</span> p.children != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">delete</span>(p.children, child)<br>    &#125;<br>    p.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>    cancelCtx<br>    timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br>    deadline time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>timerCtx 在 cancelCtx 基础上又做了一层封装，除了继承 cancelCtx 的能力之外，新增了一个 time.Timer 用于定时终止 context；另外新增了一个 deadline 字段用于字段 timerCtx 的过期时间.</p><h2 id="timerCtx-Dealine"><a href="#timerCtx-Dealine" class="headerlink" title="timerCtx.Dealine()"></a>timerCtx.Dealine()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">return</span> c.deadline, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="timerCtx-cancel"><a href="#timerCtx-cancel" class="headerlink" title="timerCtx.cancel"></a>timerCtx.cancel</h2><p>重写了父类cancelCtx的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br>    c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<br>    <span class="hljs-keyword">if</span> removeFromParent &#123;<br>        removeChild(c.cancelCtx.Context, c)<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>        c.timer.Stop()<br>        c.timer = <span class="hljs-literal">nil</span><br>    &#125;<br>    c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context-WithTimeout-context-WithDeadline"><a href="#context-WithTimeout-context-WithDeadline" class="headerlink" title="context.WithTimeout &amp; context.WithDeadline"></a>context.WithTimeout &amp; context.WithDeadline</h2><p>context.WithTimeout 方法用于构造一个 timerCtx，本质上会调用 context.WithDeadline 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;<br>    <span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;<br>    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br>        <span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br>        <span class="hljs-keyword">return</span> WithCancel(parent)<br>    &#125;<br>    c := &amp;timerCtx&#123;<br>        cancelCtx: newCancelCtx(parent),<br>        deadline:  d,<br>    &#125;<br>    propagateCancel(parent, c)<br>    dur := time.Until(d)<br>    <span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>        c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><br>        <span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br>    <span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>        c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>    Context <span class="hljs-comment">// 继承了一个 parent context</span><br>    key, val any <span class="hljs-comment">// 一个 valueCtx 中仅有一组 kv 对</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="valueCtx-Value"><a href="#valueCtx-Value" class="headerlink" title="valueCtx.Value()"></a>valueCtx.Value()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-comment">// 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value</span><br>    <span class="hljs-keyword">if</span> c.key == key &#123;<br>        <span class="hljs-keyword">return</span> c.val<br>    &#125;<br>    <span class="hljs-comment">// 假如不等，则从 parent context 中依次向上寻找.</span><br>    <span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(c Context, key any)</span></span> any &#123;<br><span class="hljs-comment">// 启动一个 for 循环，由下而上，由子及父，依次对 key 进行匹配</span><br>    <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 其中 cancelCtx、timerCtx、emptyCtx 类型会有特殊的处理方式；</span><br>        <span class="hljs-keyword">switch</span> ctx := c.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> *valueCtx:<br>            <span class="hljs-keyword">if</span> key == ctx.key &#123;<br>                <span class="hljs-keyword">return</span> ctx.val<br>            &#125;<br>            c = ctx.Context<br>        <span class="hljs-keyword">case</span> *cancelCtx:<br>            <span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br>                <span class="hljs-keyword">return</span> c<br>            &#125;<br>            c = ctx.Context<br>        <span class="hljs-keyword">case</span> *timerCtx:<br>            <span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br>                <span class="hljs-keyword">return</span> &amp;ctx.cancelCtx<br>            &#125;<br>            c = ctx.Context<br>        <span class="hljs-keyword">case</span> *emptyCtx:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> c.Value(key)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context-WithValue"><a href="#context-WithValue" class="headerlink" title="context.WithValue()"></a>context.WithValue()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val any)</span></span> Context &#123;<br>    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成本比较高, 每放入一个kv, 就要新建一个context</p><ul><li>一个 valueCtx 实例只能存一个 kv 对，因此 n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v. 由此得知，valueContext 的定位类似于请求头，只适合存放少量作用域较大的全局 meta 数据.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中可能的面试题</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E5%8F%AF%E8%83%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E5%8F%AF%E8%83%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="交替打印"><a href="#交替打印" class="headerlink" title="交替打印"></a>交替打印</h2><blockquote><p>使用两个Goroutine交替打印序列, 一个Goroutine打印数字, 另一个Goroutine打印字母<br>‘12AB34CD…..2526YZ’</p></blockquote><p>三个channel, 但WaitGroup有点问题…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>numChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>charChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>blockChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;aa&quot;</span>)<br>&#125;()<br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-numChan:<br>fmt.Print(i)<br>i++<br>fmt.Print(i)<br>i++<br>charChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-charChan:<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, i)<br>i++<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, i)<br>i++<br><span class="hljs-keyword">if</span> i &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &#123;<br>numChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>blockChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;()<br><br>numChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&lt;-blockChan<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串中的所有字符-是否全都不同"><a href="#字符串中的所有字符-是否全都不同" class="headerlink" title="字符串中的所有字符 是否全都不同"></a>字符串中的所有字符 是否全都不同</h2><blockquote><p>确定一个字符串所有字符是否全都不同, 不能使用额外存储结构, 给定一个string, 返回bool, 都是ascii码</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;ABCA&quot;</span><br>fmt.Println(IsRepeat(s))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsRepeat</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">for</span> ii, vv := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> vv == v &amp;&amp; ii != i &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="解析时-struct的字段名要大写"><a href="#解析时-struct的字段名要大写" class="headerlink" title="解析时, struct的字段名要大写"></a>解析时, struct的字段名要大写</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span> <span class="hljs-comment">// 字段名要大写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>js := <span class="hljs-string">`&#123;&quot;name&quot;: &quot;bing&quot;&#125;`</span><br>p := &amp;Person&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(js), &amp;p)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, p)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高并发下的锁与map的读写"><a href="#高并发下的锁与map的读写" class="headerlink" title="高并发下的锁与map的读写"></a>高并发下的锁与map的读写</h2><blockquote><p>在一个高并发的Web服务器中, 限制IP的频繁访问, 现模拟100个IP同时访问并发服务器, 每个IP要重复访问1000次, 每个IP三分钟之内只能访问一次. </p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Ban <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 需要加锁访问map</span><br>visitIPs <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBan</span><span class="hljs-params">()</span></span> *Ban &#123;<br><span class="hljs-keyword">return</span> &amp;Ban&#123;visitIPs: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Ban)</span></span> visit(ip <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> _, ok := o.visitIPs[ip]; ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>o.visitIPs[ip] = time.Now()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>success := <span class="hljs-number">0</span> <span class="hljs-comment">// 也是并发对象</span><br>ban := NewBan()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ip := fmt.Sprintf(<span class="hljs-string">&quot;192.168.1.%d&quot;</span>, j)<br><span class="hljs-keyword">if</span> !ban.visit(ip) &#123;<br>success++<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;success&quot;</span>, success)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会报错, 因为map不能并发读写. 需要加锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Ban <span class="hljs-keyword">struct</span> &#123;<br>visitIPs <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br>sync.RWMutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBan</span><span class="hljs-params">()</span></span> *Ban &#123;<br><span class="hljs-keyword">return</span> &amp;Ban&#123;visitIPs: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Ban)</span></span> visit(ip <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>o.Lock()<br><span class="hljs-keyword">defer</span> o.Unlock()<br><span class="hljs-keyword">if</span> _, ok := o.visitIPs[ip]; ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>o.visitIPs[ip] = time.Now()<br><span class="hljs-keyword">go</span> o.delIP(ip)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Ban)</span></span> delIP(ip <span class="hljs-type">string</span>) &#123;<br>timer := time.NewTicker(time.Minute * <span class="hljs-number">3</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-timer.C:<br>o.Lock()<br><span class="hljs-keyword">defer</span> o.Unlock()<br><span class="hljs-built_in">delete</span>(o.visitIPs, ip)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>success := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)<br>ban := NewBan()<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>ip := fmt.Sprintf(<span class="hljs-string">&quot;192.168.1.%d&quot;</span>, j)<br><span class="hljs-keyword">if</span> !ban.visit(ip) &#123;<br>atomic.AddInt32(&amp;success, <span class="hljs-number">1</span>)<br>&#125;<br>&#125;(j)<br>&#125;<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;success&quot;</span>, success)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交替打印dog-cat-fish"><a href="#交替打印dog-cat-fish" class="headerlink" title="交替打印dog cat fish"></a>交替打印dog cat fish</h2><p>有三个函数，分别打印”cat”, “fish”,”dog”要求每一个函数都用一个goroutine，按照顺序打印100次。<br>此题目考察channel，<strong>用三个无缓冲channel</strong>，如果一个channel收到信号则通知下一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>chDog := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>chCat := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>chFish := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(<span class="hljs-number">300</span>)<br><br>dog := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-chDog<br>fmt.Println(<span class="hljs-string">&quot;dog&quot;</span>)<br>wg.Done()<br>chCat &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br>cat := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-chCat<br>fmt.Println(<span class="hljs-string">&quot;cat&quot;</span>)<br>wg.Done()<br>chFish &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br>fish := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-chFish<br>fmt.Println(<span class="hljs-string">&quot;fish&quot;</span>)<br>wg.Done()<br>chDog &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> cat()<br><span class="hljs-keyword">go</span> dog()<br><span class="hljs-keyword">go</span> fish()<br>&#125;<br>chCat &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两个协程交替打印10个字母和数字"><a href="#两个协程交替打印10个字母和数字" class="headerlink" title="两个协程交替打印10个字母和数字"></a>两个协程交替打印10个字母和数字</h2><p>思路：采用channel来协调goroutine之间顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>chChar := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>chNum := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>wg := sync.WaitGroup&#123;&#125;<br><br>wg.Add(<span class="hljs-number">2</span>)<br><br>printNum := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>&lt;-chNum<br>fmt.Println(i)<br>chChar &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br><br>printChar := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;a&#x27;</span>; i &lt; <span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">10</span>; i++ &#123;<br>&lt;-chChar<br>fmt.Printf(<span class="hljs-string">&quot;%c\n&quot;</span>, i)<br>chNum &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">go</span> printNum()<br><span class="hljs-keyword">go</span> printChar()<br>chNum &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现阻塞map"><a href="#实现阻塞map" class="headerlink" title="实现阻塞map"></a>实现阻塞map</h2><p>实现一个map</p><ol><li>面向高并发: map本身并不支持高并发, 可能会抛出fatal error杀掉进程, 无法recover.</li><li>只存在插入和查询操作 O(1)</li><li>查询时, 若key存在返回val; 若key不存在, 阻塞直到key, val对被放入后, 获取val返回; 等待指定时长仍未放入, 返回超市错误</li><li>写出真实代码, 不能有死锁或者pannic风险.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyChan <span class="hljs-keyword">struct</span> &#123;<br>sync.Once<br>ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyChan)</span></span> Close &#123;<br>m.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyChan</span><span class="hljs-params">()</span></span> *MyChan &#123;<br><span class="hljs-keyword">return</span> &amp;MyChan&#123;<br>ch : <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> MyConcurrentMap <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex<br>mp <span class="hljs-keyword">map</span> [<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">// keyToCh map[int]chan struct&#123;&#125; // key是int, value是 chan struct&#123;&#125;</span><br>keyToCh <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*MyChan<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyConcurrentMap</span><span class="hljs-params">()</span></span> *MyConcurrentMap &#123;<br><span class="hljs-keyword">return</span> &amp;MyConcurrentMap &#123;<br>mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>),<br><span class="hljs-comment">// keyToCh: make(map[int]chan struct&#123;&#125;),</span><br>keyToCh: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*MyChan), <br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Put(k,v <span class="hljs-type">int</span>) &#123;<br>m.Lock()<br><span class="hljs-keyword">defer</span> m.Unlock()<br>m.mp[k] = v<br><br>ch, ok := m.keyToCh[k]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// ch &lt;- struct&#123;&#125;&#123;&#125;  // 不知道有多少个读Goroutine在等待, 放一个信号可能直接被消耗, 造成读死锁</span><br><span class="hljs-comment">// close(ch) // 直接关闭, 读channel会被唤醒, 写会panic; 会存在多次关闭ch的可能</span><br><br><span class="hljs-comment">// 方案1, 确保ch不会被重复关闭</span><br><span class="hljs-comment">/* select &#123;</span><br><span class="hljs-comment">case &lt;- ch:</span><br><span class="hljs-comment">return // 读到了数据, 说明channel关闭了</span><br><span class="hljs-comment">default:</span><br><span class="hljs-comment">close(ch) // 没有读到数据, channel没有关闭</span><br><span class="hljs-comment">&#125; */</span><br><span class="hljs-comment">// 方案2, 实现仅关闭一次的channel</span><br>ch.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Get(k <span class="hljs-type">int</span>, maxWaitingDuration time.Duration) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span> ) &#123;<br> m.Lock()<br> v, ok := m.mp[k]<br> <span class="hljs-keyword">if</span> ok &#123;<br> m.Unlock()<br> <span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br> &#125;<br><br> ch, ok := m.keyToCh[k]<br> <span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-comment">// ch = make(chan struct&#123;&#125;) // 对应的channel没有创建过, 创建这个channel</span><br>ch = NewMyChan()<br>m.keyToCh[k] = ch<br> &#125;<br><br> tCtx, canncel := context.WithTimeout(context.Background(), maxWaitingDuration)<br> <span class="hljs-keyword">defer</span> cancel()<br> <br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- tCtx.Done():<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>, tCtx.Err()<br><span class="hljs-keyword">case</span> &lt;- ch:<br>&#125;<br><br>m.Lock();<br>v = m.mp[k]<br>m.Unlock()<br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现一个读写锁"><a href="#实现一个读写锁" class="headerlink" title="实现一个读写锁"></a>实现一个读写锁</h2><p>五个方法</p><ul><li>Lock&#x2F;Unlock - 写操作时调用的方法<ul><li>如果已经被reader或者writer持有, 那么lock方法会一直阻塞, 获取锁</li><li>Unlock: 配对的释放锁的方法</li></ul></li><li>Rlock &#x2F; RUnlock - 读操作时调用的方法<ul><li>如果锁已经被writer持有的话, RLock方法会一直被阻塞, 直到获取锁, 否则直接返回</li><li>Runlock: 配对的释放锁的方法</li></ul></li><li>RLocker - 读操作时返回的Locker接口的对象</li></ul><p>RWMutex的5个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>w Mutex<br>writerSem <span class="hljs-type">uint32</span><br>readerSem <span class="hljs-type">uint32</span><br>readerCount <span class="hljs-type">int32</span><br>readerWait <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的其它高级特性</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="cgo-Go调用C代码"><a href="#cgo-Go调用C代码" class="headerlink" title="cgo - Go调用C代码"></a>cgo - Go调用C代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int sum(int a,  int b) &#123;</span><br><span class="hljs-comment">return a + b;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-comment">// 以上述注释为源代码 生成二进制C方法</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(C.sum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在内存中开辟一个结构体</li><li>结构体中含有参数和返回值</li><li>结构体地址传入C方法</li><li>C方法将结果写入返回值的位置<br>需要调度器的配合</li><li>协程需要抢占式调度</li><li>进入C程序之后, 调度器无法抢占携程</li><li>调度器停止对此协程的调度<br>协程栈的切换</li><li>C的栈不受Runtime管理</li><li>进入C时, 需要将当前栈切换到线程的系统栈上<br>优缺点</li><li>cgo可以让Go调用现成的C实现</li><li>cgo限制了Go语言的跨平台特性</li><li>cgo并不能提高Go语言的性能</li></ul><h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><h2 id="协程记录defer信息-函数退出时调用"><a href="#协程记录defer信息-函数退出时调用" class="headerlink" title="协程记录defer信息, 函数退出时调用"></a>协程记录defer信息, 函数退出时调用</h2><p>解锁, 关闭资源等</p><h3 id="堆上分配"><a href="#堆上分配" class="headerlink" title="堆上分配"></a>堆上分配</h3><ul><li>1.12之前使用</li><li>在堆上开辟一个sched.deferpool</li><li>遇到defer语句, 将信息放入deferpool(p结构体中)</li><li>函数返回时, 从deferpool取出执行</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul><li>1.13之后出现</li><li>遇到defer语句, 将信息放入栈上 </li><li>函数返回时, 从栈中取出执行</li><li>只能保存一个defer信息(栈空间优先, 过大会导致扩容, 影响性能)</li></ul><h3 id="开放编码-性能最高"><a href="#开放编码-性能最高" class="headerlink" title="开放编码 - 性能最高"></a>开放编码 - 性能最高</h3><ul><li>1.14之后出现</li><li>如果defer语句在编译时就可以固定</li><li>直接改写用户代码, defer语句放入函数末尾</li></ul><h1 id="recover-拯救程序"><a href="#recover-拯救程序" class="headerlink" title="recover - 拯救程序"></a>recover - 拯救程序</h1><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><ul><li>抛出错误</li><li>终止协程运行</li><li>带崩整个Go程序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer main g&quot;</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer g&quot;</span>) <span class="hljs-comment">// 只有此会被调用</span><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;end g&quot;</span>)<br>&#125;()<br><br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;end main g&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>panic在退出协程之前会执行所有本协程已注册的defer</li><li>不会执行其它协程的defer</li></ul><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer main&quot;</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">recover</span>()<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;end g&quot;</span>)<br>&#125;()<br><br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;end main g&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>添加了recover之后, 可以恢复panic</p><ul><li>如果设计recover, defer会使用堆上分配(deferpool)</li><li>遇到panic, panic会从deferpool取出的defer语句执行</li><li>defer中调用recover, 可以终止panic的过程</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>panic终止当前协程的运行</li><li>panic在退出协程之前会执行所有已注册的defer在defert中执行recover,可以拯救panic的协程</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>不同类型执行不同逻辑</p><ul><li>获取对象的类型</li><li>对任意类型变量赋值</li><li>调用任意方法</li></ul><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><ul><li>元数据就是数据的数据</li><li>把对象的类型表示成一个数据类型</li><li>把对象的值表示成一个数据类型</li></ul><h2 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h2><ul><li>接口reflect.type</li><li>把对象的类型表示成一个接口</li><li>就能对类型做各种操作</li></ul><h2 id="对象的值"><a href="#对象的值" class="headerlink" title="对象的值"></a>对象的值</h2><ul><li>结构体 reflect.Value</li><li>把对象的值表示成一个结构体</li><li>就能对值做各种操作</li></ul><h2 id="对象到反射对象"><a href="#对象到反射对象" class="headerlink" title="对象到反射对象"></a>对象到反射对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Bing&quot;</span><br>fmt.Println(reflect.TypeOf(s))<br>sv := reflect.ValueOf(s)<br>fmt.Println(sv)<br><br><span class="hljs-comment">// 从值恢复到变量</span><br>s2 := sv.Interface().(<span class="hljs-type">string</span>)<br>fmt.Println(s2)<br></code></pre></td></tr></table></figure><h2 id="使用反射调用方法"><a href="#使用反射调用方法" class="headerlink" title="使用反射调用方法"></a>使用反射调用方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyAdd</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyAdd2</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallAdd</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) &#123;<br>v := reflect.ValueOf(f)<br><span class="hljs-keyword">if</span> v.Kind() != reflect.Func &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>argv := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-number">2</span>)<br>argv[<span class="hljs-number">0</span>] = reflect.ValueOf(<span class="hljs-number">1</span>)<br>argv[<span class="hljs-number">1</span>] = reflect.ValueOf(<span class="hljs-number">2</span>)<br>res := v.Call(argv)<br>fmt.Println(res[<span class="hljs-number">0</span>].Int())<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>CallAdd(MyAdd)<br>CallAdd(MyAdd2)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过反射调用方法, 可以将框架和用户方法解耦</li><li>往往需要用户注册方法 , 框架调用</li><li>很多框架的HTTP调用处理使用此思路</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的内存模型与垃圾回收</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="栈内存-协程栈-调用栈"><a href="#栈内存-协程栈-调用栈" class="headerlink" title="栈内存(协程栈, 调用栈)"></a>栈内存(协程栈, 调用栈)</h1><h2 id="Go协程栈的作用"><a href="#Go协程栈的作用" class="headerlink" title="Go协程栈的作用"></a>Go协程栈的作用</h2><p><img src="/img/Pasted%20image%2020230524101355.png"></p><ul><li>协程的执行路径</li><li>局部变量</li><li>函数传参</li><li>函数返回值</li></ul><h2 id="Go协程栈的位置"><a href="#Go协程栈的位置" class="headerlink" title="Go协程栈的位置"></a>Go协程栈的位置</h2><ul><li>Go的协程栈位于堆内存上</li><li>Go堆内存位于操作系统虚拟内存上</li></ul><h2 id="Go栈帧的结构"><a href="#Go栈帧的结构" class="headerlink" title="Go栈帧的结构"></a>Go栈帧的结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br>sum = a + b<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">3</span><br>b := <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(<br>sum(a, b)<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230524102337.png"></p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li>Go使用参数拷贝传递(值传递)</li><li>传递结构体时: 会拷贝结构体中全部内容</li><li>传递结构体指针时: 会拷贝结构体指针</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>协程栈记录了协程的执行现场</li><li>协程栈还负责记录局部变量，传递参数和返回值</li><li>Go使用参数拷贝传递</li></ul><h2 id="栈的扩增"><a href="#栈的扩增" class="headerlink" title="栈的扩增"></a>栈的扩增</h2><p>初始栈帧大小: 2k~4k </p><h3 id="局部变量太大"><a href="#局部变量太大" class="headerlink" title="局部变量太大"></a>局部变量太大</h3><p>可以通过逃逸分析解决<br>逃逸分析</p><ul><li>不是所有的变量都能放在协程栈上</li><li>栈帧回收后, 需要继续使用的变量</li><li>太大的变量<br>三种情形:</li><li>指针逃逸<br>函数返回了对象的指针<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>v := <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> &amp;v<br>&#125;<br></code></pre></td></tr></table></figure></li><li>空接口逃逸<br>如果函数参数为interface{}, 函数的实参很可能会逃逸<br>因为interface{}类型的函数往往会使用反射(要求对象在堆上)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">1</span><br>fmt.Println(i) <span class="hljs-comment">// 空接口逃逸</span><br></code></pre></td></tr></table></figure></li><li>大变量逃逸<br>过大的变量会导致栈空间不足<br>在64位的机器中, 一般超过64KB的变量会逃逸</li></ul><h3 id="栈帧太多"><a href="#栈帧太多" class="headerlink" title="栈帧太多"></a>栈帧太多</h3><p>栈扩容</p><ul><li>Go初始栈空间大小为2kb</li><li>在函数调用前判断栈空间(morestack)</li><li>必要时对栈进行扩容</li><li>早期使用分段栈, 后期使用连续栈</li></ul><h4 id="分段栈"><a href="#分段栈" class="headerlink" title="分段栈"></a>分段栈</h4><ul><li>1.13之前使用</li><li>优点: 没有空间浪费</li><li>缺点: 栈指针会在不连续的空间跳转<br><img src="/img/Pasted%20image%2020230524104520.png"></li></ul><h4 id="连续栈"><a href="#连续栈" class="headerlink" title="连续栈"></a>连续栈</h4><p>直接开辟一块大小为原来两倍的新栈空间, 将老的全部拷贝过来;<br>空间使用率不足1&#x2F;4是缩容, 变为原来1&#x2F;2;</p><ul><li>优点: 空间一直连续</li><li>缺点: 伸缩时开销大</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>三种特殊情况(逃逸)下, 变量可能会分配到堆上</li><li>1.13之前, Go使用可伸缩的分段栈</li><li>1.14以后, Go使用连续栈, 伸缩时直接使用新栈</li></ul><h1 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1><h2 id="操作系统的虚拟内存"><a href="#操作系统的虚拟内存" class="headerlink" title="操作系统的虚拟内存"></a>操作系统的虚拟内存</h2><ul><li>不是Win的”虚拟内存”(交换区, Linux下的Swap)</li><li>操作系统给应用提供的虚拟内存空间</li><li>背后是物理内存, 也有可能是磁盘</li><li>Linux获取虚拟内存: mmap, madvice<br> <img src="/img/Pasted%20image%2020230524111556.png"></li></ul><h2 id="heapArena"><a href="#heapArena" class="headerlink" title="heapArena"></a>heapArena</h2><ul><li>Go每次申请的虚拟内存单元为64MB</li><li>最多有2^20个虚拟内存单元</li><li>所有的heapArena组成了mheap(Go堆内存)</li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ul><li><p>线性分配: 没分配满的时候, 一直向后分配<br><img src="/img/Pasted%20image%2020230524112720.png"></p></li><li><p>链表分配: 使用链表串联起所有空闲内存块<br><img src="/img/Pasted%20image%2020230524112807.png"></p><blockquote><p>线性分配或者链表分配很容易出现空间碎片</p></blockquote></li><li><p>分级分配<br>找到比要分配对象的最小内存块<br><img src="/img/Pasted%20image%2020230524113122.png"><br>外部碎片比较少<br>级 -&gt; mspan</p></li></ul><h2 id="内存管理单元mspan"><a href="#内存管理单元mspan" class="headerlink" title="内存管理单元mspan"></a>内存管理单元mspan</h2><ul><li>根据隔离适应策略，使用内存时的最小单位为mspan</li><li>每个mspan为N个相同大小的“格子” </li><li>Go中一共有67种mspan<br><img src="/img/Pasted%20image%2020230524113424.png"></li><li>每个heapArena中的mspan都不确定</li><li>如何快速找到所需的mspan级别? 中心索引mcenteral</li></ul><h2 id="中心索引mcentral"><a href="#中心索引mcentral" class="headerlink" title="中心索引mcentral"></a>中心索引mcentral</h2><ul><li>136个mcentral结构体, 其中<ul><li>68个需要扫描的mspan()</li><li>68个不需要扫描的mspan(常量等)<br><img src="/img/Pasted%20image%2020230524123452.png"></li></ul></li></ul><h2 id="mcentral的性能问题"><a href="#mcentral的性能问题" class="headerlink" title="mcentral的性能问题"></a>mcentral的性能问题</h2><ul><li>mcentral实际是中心索引, 使用互斥锁保护</li><li>高并发场景下, 锁冲突问题严重</li><li>参考协程GMP模型, 增加线程本地缓存</li></ul><h2 id="线程缓存mcache"><a href="#线程缓存mcache" class="headerlink" title="线程缓存mcache"></a>线程缓存mcache</h2><ul><li>每个P拥有一个mcache</li><li>一个mcache拥有136个mspan, 其中<ul><li>68个需要GC扫描的mspan</li><li>68个不需要GC扫描的mspan<br><img src="/img/Pasted%20image%2020230524124322.png"></li></ul></li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>Go魔方TCmalloc, 建立了自己的堆内存架构</li><li>使用heapArena向操作系统申请内存</li><li>使用heapArena时, 以mspan为单位, 防止碎片化</li><li>mcentral是mspan们的中心索引</li><li>mcache记录了分配给各个P的本地mspan</li></ul><h2 id="对象分级"><a href="#对象分级" class="headerlink" title="对象分级"></a>对象分级</h2><ul><li>Tiny微对象(0, 16B) 无指针</li><li>Small小对象<code>[16B, 32KB]</code></li><li>Large大对象(32KB, +inf)</li></ul><p>微小对象分配到普通mspan, class 1 ~ class 67<br>大对象量身定做mspan</p><h2 id="微小对象分配"><a href="#微小对象分配" class="headerlink" title="微小对象分配"></a>微小对象分配</h2><ul><li>从mcache拿到2级mspan</li><li>将多个微对象合并成一个16Byte存入<br><img src="/img/Pasted%20image%2020230524125614.png"></li></ul><h2 id="mcache的替换"><a href="#mcache的替换" class="headerlink" title="mcache的替换"></a>mcache的替换</h2><ul><li>mcache中, 每个级别的mspan只有一个</li><li>当mspan满了之后, 会从mcentral中换一个新的</li></ul><h2 id="mcentral的扩容"><a href="#mcentral的扩容" class="headerlink" title="mcentral的扩容"></a>mcentral的扩容</h2><ul><li>mcentral中, 只有有限数量的mspan</li><li>当mspan缺少时, 会从heapArena开辟新的mspan</li></ul><h2 id="大对象分配"><a href="#大对象分配" class="headerlink" title="大对象分配"></a>大对象分配</h2><ul><li>直接从heapArena开辟0级的mspan</li><li>0级的mspan为大对象定制</li></ul><h2 id="heapArena的扩容"><a href="#heapArena的扩容" class="headerlink" title="heapArena的扩容"></a>heapArena的扩容</h2><ul><li>当heapArena空间不足时</li><li>向操作系统申请新的heapArena</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul><li>Go将对象按照大小分为3种</li><li>微小对象使用mcache</li><li>mcache中的mspan填满后, 与mcentral交换新的</li><li>mcentral不足时, 在heapArena开辟新的mspan</li><li>大对象直接在heapArena开辟新的mspan</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>“标记-清除”</li><li>“标记-整理”</li><li>复制</li></ul><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p><img src="/img/Pasted%20image%2020230524145303.png"><br>标记之后, 清除即可.</p><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><p><img src="/img/Pasted%20image%2020230524145711.png"><br>标记完成后, 进行整理, 都向前放.</p><h2 id="标记复制"><a href="#标记复制" class="headerlink" title="标记复制"></a>标记复制</h2><p><img src="/img/Pasted%20image%2020230524145837.png"><br>把有用的复制到新的地方<br><img src="/img/Pasted%20image%2020230524145908.png"></p><h2 id="Go中"><a href="#Go中" class="headerlink" title="Go中"></a>Go中</h2><ul><li>由于堆内存结构的独特优势, 选择最简单的标记-清除</li><li>找到有引用的对象, 剩下的就是没有引用的</li></ul><h2 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h2><p>Root Set(GC Root)</p><ul><li>被栈上的指针引用</li><li>被全局变量指针引用</li><li>被寄存器中的指针引用<br>可达性分析标记法 - Root节点进行广度优先搜索<br><img src="/img/Pasted%20image%2020230524150440.png"><br>只有G, H会被回收</li></ul><h2 id="串行GC"><a href="#串行GC" class="headerlink" title="串行GC"></a>串行GC</h2><p>步骤</p><ol><li>Stop The World, 暂停其它所有协程</li><li>通过可达性分析, 找到无用的堆内存</li><li>释放堆内存</li><li>恢复所有其它协程<br>问题</li></ol><ul><li>串行对业务性能影响较大</li></ul><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul><li>从GC Root出发，寻找被引用对象</li><li>没有被引用的就是无用对象</li><li>串行GC需要STW,对性能景影响大</li></ul><h2 id="并发GC"><a href="#并发GC" class="headerlink" title="并发GC"></a>并发GC</h2><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><ul><li>黑色: 有用, 已经分析扫描</li><li>灰色: 有用, 还未分析扫描</li><li>白色: 暂时无用</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>起初所有的对象都是白色的<br><img src="/img/Pasted%20image%2020230524151440.png"></li><li>从根对象出发扫描可达对象, 标记为灰色<br><img src="/img/Pasted%20image%2020230524152123.png"></li><li>扫描灰色对象, 将其引用的对象标记为灰色, 自身标记为黑色<br><img src="/img/Pasted%20image%2020230524152407.png"><br><img src="/img/Pasted%20image%2020230524152451.png"></li><li>清除白色对象.</li><li>再次标记时, 所有对象恢复为白色.</li></ol><h3 id="并发标记问题-删除"><a href="#并发标记问题-删除" class="headerlink" title="并发标记问题(删除)"></a>并发标记问题(删除)</h3><ul><li>并发标记进行中<br><img src="/img/Pasted%20image%2020230524152925.png"></li><li>在业务协程中, B指向C的指针释放<br><img src="/img/Pasted%20image%2020230524152836.png"></li><li>在业务协程中, E的一个指针成员指向了C<br><img src="/img/Pasted%20image%2020230524153024.png"></li><li>持续扫描<br><img src="/img/Pasted%20image%2020230524153142.png"><br><strong>C将会被错误清除</strong> -&gt; Yuasa删除屏障</li></ul><h3 id="Yuasa删除屏障"><a href="#Yuasa删除屏障" class="headerlink" title="Yuasa删除屏障"></a>Yuasa删除屏障</h3><ul><li>并发标记时, 对指针释放的白色对象置为灰色<br><img src="/img/Pasted%20image%2020230524155130.png"></li><li>删除屏障: C被置为灰色 </li><li>删除屏障可以杜绝在GC标记中释放的指针被清理</li></ul><h3 id="并发标记问题-插入"><a href="#并发标记问题-插入" class="headerlink" title="并发标记问题(插入)"></a>并发标记问题(插入)</h3><ul><li>并发标记进行中<br><img src="/img/Pasted%20image%2020230524155350.png"></li><li>在业务协程中, E的一个指针成员指向了C<br><img src="/img/Pasted%20image%2020230524155501.png"><br>此时则出现了问题, C会被错误删除 -&gt; Dijkstra插入屏障</li></ul><h3 id="Dijkstra插入屏障"><a href="#Dijkstra插入屏障" class="headerlink" title="Dijkstra插入屏障"></a>Dijkstra插入屏障</h3><p>并发标记时, 对指针新指向的白色对象置为灰色<br><img src="/img/Pasted%20image%2020230524155904.png"><br>插入屏障可以杜绝在GC标记中被插入的指针被清理</p><h3 id="混合屏障"><a href="#混合屏障" class="headerlink" title="混合屏障"></a>混合屏障</h3><ul><li>被删除的堆对象被标记为灰色</li><li>被添加的堆对象标记为灰色</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul><li>并发垃圾回收的关键在于标记安全</li><li>混合屏障机制兼顾了安全与效率</li></ul><h1 id="如何优化GC效率"><a href="#如何优化GC效率" class="headerlink" title="如何优化GC效率"></a>如何优化GC效率</h1><h2 id="GC触发的时机"><a href="#GC触发的时机" class="headerlink" title="GC触发的时机"></a>GC触发的时机</h2><h3 id="系统定时触发"><a href="#系统定时触发" class="headerlink" title="系统定时触发"></a>系统定时触发</h3><ul><li>sysmon定时检查(g0协程)</li><li>如果2分钟内没有过GC, 触发</li><li>谨慎调整</li></ul><h3 id="用户显式触发"><a href="#用户显式触发" class="headerlink" title="用户显式触发"></a>用户显式触发</h3><ul><li>用户调用runtime.GC方法</li><li>并不推荐调用</li></ul><h3 id="申请内存时触发"><a href="#申请内存时触发" class="headerlink" title="申请内存时触发"></a>申请内存时触发</h3><ul><li>给对象申请堆空间时, 可能导致GC</li></ul><h2 id="GC优化原则"><a href="#GC优化原则" class="headerlink" title="GC优化原则"></a>GC优化原则</h2><ul><li>尽量少在堆上产生垃圾<ul><li>内存池化</li><li>减少逃逸</li><li>使用空结构体</li></ul></li></ul><h3 id="内存池化"><a href="#内存池化" class="headerlink" title="内存池化"></a>内存池化</h3><ul><li>缓存性质的对象</li><li>频繁创建和删除</li><li>使用内存池, 不GC</li></ul><h3 id="减少逃逸"><a href="#减少逃逸" class="headerlink" title="减少逃逸"></a>减少逃逸</h3><ul><li>逃逸会使原本在栈上的对象进入堆中</li><li>fmt包</li><li>返回了指针而不是拷贝</li></ul><h3 id="使用空结构体"><a href="#使用空结构体" class="headerlink" title="使用空结构体"></a>使用空结构体</h3><ul><li>空结构体指向一个固定地址</li><li>不占用堆空间</li><li>比如channel传递空结构体</li></ul><h3 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h3><ul><li>go tool pprof</li><li>go tool trace</li><li>go build -gcflags&#x3D;” -m”</li><li>GODEBUG&#x3D;”gctrace&#x3D;1”</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul><li>GC主要由系统定时触发或者申请内存触发</li><li>GC优化的原则是减少在堆上产生垃圾</li><li>使用GC分析工具可以帮助分析GC问题</li></ul><h1 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h1><h2 id="协程栈"><a href="#协程栈" class="headerlink" title="协程栈"></a>协程栈</h2><ul><li>协程栈记录了协程的执行现场</li><li>G0协程栈位于G0堆内存上</li><li>Go使用参数拷贝传递</li><li>3种特殊情况下，变量可能会逃逸到堆上</li><li>1.14以后，G0使用连续栈，伸缩时直接使用新栈</li></ul><h2 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h2><p><img src="/img/Pasted%20image%2020230524124322.png"></p><ul><li>Go模仿TCmalloc,建立了自己的堆内存架构</li><li>使用heapArena向操作系统申请内存</li><li>使用heapArena时，以mspan为单位，防止碎片化</li><li>mcentral是mspan们的中心索引</li><li>mcache记录了分配给各个P的本地mspan</li></ul><h3 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h3><ul><li>G0将对象按照大小分为3种</li><li>微小对象使用mcache</li><li>mcache中的mspan填满后，与mcentral交换新的</li><li>mcentral不足时，在heapArena开辟新的mspan</li><li>大对象直接在heapArena开辟新的mspan</li></ul><h2 id="堆内存回收-GC"><a href="#堆内存回收-GC" class="headerlink" title="堆内存回收(GC)"></a>堆内存回收(GC)</h2><ul><li>“标记-清除”法<ul><li>标记有用对象，清除无用对象</li></ul></li><li>“可达性分析”标记法<ul><li>从GC Root出发，寻找被引用对象</li></ul></li></ul><h2 id="并发GC-1"><a href="#并发GC-1" class="headerlink" title="并发GC"></a>并发GC</h2><ul><li>并发垃圾回收的关键在于标记安全</li><li>混合屏障机制兼顾了安全与效率</li></ul><h2 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h2><ul><li>GC主要由系统定时触发或者申请内存触发</li><li>GC优化的原则是减少在堆上产生垃圾</li><li>使用GC分析工具可以帮助分析GC问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>垃圾回收</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的TCP网络编程</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP通讯基本原理"><a href="#TCP通讯基本原理" class="headerlink" title="TCP通讯基本原理"></a>TCP通讯基本原理</h1><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p><img src="/img/Pasted%20image%2020230523202540.png"> </p><h2 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程"></a>TCP通信过程</h2><p> <img src="/img/Pasted%20image%2020230523202721.png"></p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li>很多系统都提供Socket作为TCP网络连接的抽象</li><li>Linux -&gt; Internet domain -&gt; SOCK_STRE</li><li>AM</li><li>Linux中Socket以”文件描述符”FD作为标识</li></ul><h2 id="Socket通信过程"><a href="#Socket通信过程" class="headerlink" title="Socket通信过程"></a>Socket通信过程</h2><p><img src="/img/Pasted%20image%2020230523202927.png"><br><img src="/img/Pasted%20image%2020230523203134.png"></p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO模型指的是同时操作Socket的方案</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><img src="/img/Pasted%20image%2020230523203714.png"><br>同步读写Socket时，线程陷入内核态; 当读写成功后，切换回用户态，继续执行;<br>优点：开发难度小，代码简单</p><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p><img src="/img/Pasted%20image%2020230523203941.png"><br>如果暂时无法收发数据，会返回错误; 应用会不断轮询，直到Socketi可以读写;<br>优点：不会陷入内核态，自由度高; 缺点：需要自旋轮询</p><h3 id="多路复用-Linux-epoll"><a href="#多路复用-Linux-epoll" class="headerlink" title="多路复用 - Linux epoll"></a>多路复用 - Linux epoll</h3><p> <img src="/img/Pasted%20image%2020230523204128.png"><br> 注册多个Socket事件; 调用epool,当有事件发生，返回<br> 优点：提供了事件列表，不需要查询各个Scoket;  缺点：开发难度大，逻辑复杂<br> Mac: kqueue, Windows: IOCP</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>操作系统提供了Socket作为TCP通信的抽象</li><li>IO模型指的是操作Socket的方案</li><li>阻塞模型最利于业务编写，但是性能差</li><li>多路复用性能好，但业务编写麻烦</li></ul><h1 id="net包对TCP通信的实现"><a href="#net包对TCP通信的实现" class="headerlink" title="net包对TCP通信的实现"></a>net包对TCP通信的实现</h1><h2 id="阻塞模型-多路复用"><a href="#阻塞模型-多路复用" class="headerlink" title="阻塞模型 + 多路复用"></a>阻塞模型 + 多路复用</h2><ul><li>在底层使用操作系统的多路复用IO</li><li>在协程层次使用阻塞模型</li><li>阻塞协程时，休眠协程</li></ul><h2 id="epoll抽象层"><a href="#epoll抽象层" class="headerlink" title="epoll抽象层"></a>epoll抽象层</h2><p>epoll抽象层是为了统一各个操作系统对多路复用器的实现<br>各个系统的多路复用都有一下功能(以linux epoll为例):</p><ul><li>新建多路复用器 epoll_create()</li><li>往多路复用器里插入需要监听的时间 epoll_ctl()</li><li>查询发生了什么事件 epoll_wait()</li></ul><h2 id="Go-Network-Poller多路复用器的抽象"><a href="#Go-Network-Poller多路复用器的抽象" class="headerlink" title="Go Network Poller多路复用器的抽象"></a>Go Network Poller多路复用器的抽象</h2><p>Go Network Poller对多路复用器的抽象和适配</p><h3 id="新建多路复用器-netpollinit-epoll-create"><a href="#新建多路复用器-netpollinit-epoll-create" class="headerlink" title="新建多路复用器 netpollinit() -&gt; epoll_create()"></a>新建多路复用器 netpollinit() -&gt; epoll_create()</h3><ol><li>调用epollcreate(汇编实现, 底层是epoll_create) 新建epoll</li><li>新建一个pipe管道用于中断epoll</li><li>将”管道有数据到达”时间注册到epoll中<br>最重要的是拿到<code>epfd</code></li></ol><h3 id="插入事件-netpollopen-epoll-ctl"><a href="#插入事件-netpollopen-epoll-ctl" class="headerlink" title="插入事件 netpollopen() -&gt; epoll_ctl()"></a>插入事件 netpollopen() -&gt; epoll_ctl()</h3><p>EPOLL_IN EPOLL_OUT EPOLL_RDHUP EPOLL_ET </p><ul><li>传入一个Socket的FD, 和pollDesc指针</li><li>pollDesc指针记录了<ul><li>Socket相关详细信息</li><li>哪个协程在等待此Socket</li></ul></li><li>将Socket可读&#x2F;可写&#x2F;断开注册到Epoll当中</li></ul><h3 id="查询事件-netpoll-epoll-wait"><a href="#查询事件-netpoll-epoll-wait" class="headerlink" title="查询事件 netpoll -&gt; epoll_wait()"></a>查询事件 netpoll -&gt; epoll_wait()</h3><ul><li>调用epoll_wait(), 查询有哪些时间发生</li><li>根据Socket相关的pollDesc信息, 返回哪些协程可以唤醒</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>Go将多路复用器的操作进行了抽象和适配<ul><li>将新建多路复用器抽象为了netpollinit()</li><li>将插入监听事件抽象为了netpollopen()</li><li>将查询事件抽象为了netpoll()</li><li>但不是返回事件，而是返回等待事件的协程列表</li></ul></li></ul><h2 id="Network-Poller-如何工作"><a href="#Network-Poller-如何工作" class="headerlink" title="Network Poller 如何工作"></a>Network Poller 如何工作</h2><h3 id="Network-Poller初始化"><a href="#Network-Poller初始化" class="headerlink" title="Network Poller初始化"></a>Network Poller初始化</h3><ul><li>poll_runtime_pollServerInit()</li><li>使用原子操作保证只初始化一次</li><li>调用netpollinit()</li></ul><h3 id="pollcache与pollDesc"><a href="#pollcache与pollDesc" class="headerlink" title="pollcache与pollDesc"></a>pollcache与pollDesc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pollCache <span class="hljs-keyword">struct</span> &#123;<br>lock mutex<br>first *pollDesc <span class="hljs-comment">// 放链表头</span><br>&#125;<br><br><span class="hljs-keyword">type</span> pollDesc <span class="hljs-keyword">struct</span> &#123;<br>link *pollDesc <span class="hljs-comment">// 后续指针</span><br><span class="hljs-comment">// ...</span><br>fd <span class="hljs-type">uintptr</span> <span class="hljs-comment">// socket的ID</span><br>rg <span class="hljs-type">uintptr</span> <span class="hljs-comment">// pdReady(1), pdWait(2), 等待读的协程的地址</span><br>wg <span class="hljs-type">uintptr</span> <span class="hljs-comment">// pdReady(1), pdWait(2), 等待写的协程的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>pollcache: 一个带锁的链表头</li><li>polDesc: 链表的成员</li><li>pollDesc是runtime包对Socket的详细描述(记录了哪些协程对该socket感兴趣)</li><li>rg, rw: 初始(0), pdReady(1), pdWait(2), 或者等待协程G的地址<br><img src="/img/Pasted%20image%2020230523214244.png"></li></ul><h3 id="Network-Poller新增监听Socket"><a href="#Network-Poller新增监听Socket" class="headerlink" title="Network Poller新增监听Socket"></a>Network Poller新增监听Socket</h3><ul><li>poll_runtime_pollOpen()</li><li>在pollcache链表中分配一个pollDesc</li><li>初始化pollDesc(rg, rw为0)</li><li>调用netpollopen(见上节, 注册各种epoll事件)</li></ul><h2 id="Network-Poller收发数据"><a href="#Network-Poller收发数据" class="headerlink" title="Network Poller收发数据"></a>Network Poller收发数据</h2><p>收发数据分为两个场景:</p><ul><li>协程需要收发数据时, Socket已经可读可写</li><li>协程需要收发数据时, Socket暂时无法读写</li></ul><h3 id="场景1-Socket已经可读可写"><a href="#场景1-Socket已经可读可写" class="headerlink" title="场景1: Socket已经可读可写"></a>场景1: Socket已经可读可写</h3><ul><li>runtime循环调用netpoll()方法(g0协程, 最终是通过垃圾回收器调用, gcStart, 一个hook)</li><li>发现Socket可读写时, 给对应的rg或者wg置为pdReady(1)</li><li>协程调用poll_runtime_pollWait()</li><li>判断rg或者wg已经置为pdReady(1), 返回0</li></ul><h3 id="场景2-Socket暂时无法读写"><a href="#场景2-Socket暂时无法读写" class="headerlink" title="场景2: Socket暂时无法读写"></a>场景2: Socket暂时无法读写</h3><ul><li>runtime循环调用netpoll()方法</li><li>协程调用poll_runtime_pollWait()</li><li>发现对应的rg或者wg为0</li><li>给对应的rg或者wg置为协程地址</li><li>休眠等待</li><li>runtime循环调用netpoll方法</li><li>发现Socket可读写时, 查看对应的rg或者wg</li><li>若为协程地址, 返回协程地址(有协程在监听)</li><li>调度器开始调度对应协程</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>Network Poller是Runtime的强大工具</li><li>抽象了多路复用器的操作</li><li>Network Poller可以自动监测多个Socket状态</li><li>在Socket状态可用时，快速返回成功</li><li>在Socket状态不可用时，休眠等待</li></ul><h2 id="Go-抽象Socket"><a href="#Go-抽象Socket" class="headerlink" title="Go 抽象Socket"></a>Go 抽象Socket</h2><h3 id="net包"><a href="#net包" class="headerlink" title="net包"></a>net包</h3><ul><li>net包是go原生的网络包</li><li>net包支持了TCP, UDP, HTTP等网络操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>) <span class="hljs-comment">// 监听8888端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">var</span> body [<span class="hljs-number">100</span>]<span class="hljs-type">byte</span><br><span class="hljs-keyword">for</span> &#123;<br>_, err := conn.Read(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;收到消息: %s\n&quot;</span>, body)<br>_, err = conn.Write(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="net-Listen"><a href="#net-Listen" class="headerlink" title="net.Listen()"></a>net.Listen()</h3><ul><li>新建Socket, 并执行bind操作</li><li>新建一个FD(net包对Socket的详情描述)</li><li>返回一个TCPListener对象</li><li>将TCPListener的FD信息加入监听</li><li>TCPListener对象本质上是一个Listen状态的Socket</li></ul><h3 id="TCPListener-Accept"><a href="#TCPListener-Accept" class="headerlink" title="TCPListener.Accept()"></a>TCPListener.Accept()</h3><ul><li>直接调用Socket的accept()</li><li>如果失败，休眠等待新的连接</li><li>将新的Socket包装为TCPConn变量返回</li><li>将TCPConn的FD信息加入监听</li><li>TCPConn本质上是一个ESTABLISHED状态的Socket</li></ul><h3 id="TCPConn-Read-Write"><a href="#TCPConn-Read-Write" class="headerlink" title="TCPConn.Read() &#x2F; Write()"></a>TCPConn.Read() &#x2F; Write()</h3><ul><li>直接调用Socket原生读写方法</li><li>如果失败，休眠等待可读&#x2F;可写</li><li>被唤醒后调用系统Socket</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>net包抽象了TCP网络操作</li><li>使用net.Listen()得到TCPListener(LISTEN状态的Socket)</li><li>使用TCPListener..Accept()得到TCPConn(ESTABLISHED)</li><li>TCPConn.Read() &#x2F; Write() 进行读写Socket的操作</li><li>Network Poller 作为上述功能的底层支撑</li></ul><h1 id="Go搭建TCP-Server"><a href="#Go搭建TCP-Server" class="headerlink" title="Go搭建TCP Server"></a>Go搭建TCP Server</h1><p>结合阻塞模型和多路复用<br><img src="/img/Pasted%20image%2020230523230339.png"></p><ul><li>用主协程监听Listener</li><li>每个Conn使用一个新携程处理<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := conn.Close(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> body [<span class="hljs-number">100</span>]<span class="hljs-type">byte</span><br><span class="hljs-keyword">for</span> &#123;<br>_, err := conn.Read(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;收到消息: %s\n&quot;</span>, body)<br>_, err = conn.Write(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>) <span class="hljs-comment">// 监听8888端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">go</span> handleConnection(conn)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><h2 id="系统IO模型"><a href="#系统IO模型" class="headerlink" title="系统IO模型"></a>系统IO模型</h2><ul><li>操作系统提供了Socket作为TCP通信的抽象</li><li>lO模型指的是操作Socket的方案</li><li>阻塞模型最利于业务编写，但是性能差</li><li>多路复用性能好，但业务编写麻烦</li></ul><h2 id="Epoll的抽象"><a href="#Epoll的抽象" class="headerlink" title="Epoll的抽象"></a>Epoll的抽象</h2><ul><li>Go将多路复用器的操作进行了抽象和适配：<ul><li>将新建多路复用器抽象为了netpollinit()</li><li>将插入监听事件抽象为了netpollopent()</li><li>将查询事件抽象为了netpoll()</li><li>但不是返回事件, 而是返回等待事件的协程列表</li></ul></li></ul><h2 id="Network-Poller的原理"><a href="#Network-Poller的原理" class="headerlink" title="Network Poller的原理"></a>Network Poller的原理</h2><ul><li>Network Poller是Runtime的强大工具</li><li>抽象了多路复用器的操作</li><li>Network Poller可以自动监测多个Socket状态</li><li>在Socket状态可用时，快速返回成功</li><li>在Socket状态不可用时，休眠等待</li></ul><h2 id="Net包"><a href="#Net包" class="headerlink" title="Net包"></a>Net包</h2><ul><li>net包抽象了TCP网络操作使用net.Listen()得到TCPListener(LISTEN状态的Socket)</li><li>使用TCPListener.Accept()得到TCPConn(ESTABLISHED)</li><li>TCPConn.Read()&#x2F;Write进行读写Socket的操作</li><li>Network Poller作为上述功能的底层支撑</li></ul><h2 id="goroutine-per-connection"><a href="#goroutine-per-connection" class="headerlink" title="goroutine-per-connection"></a>goroutine-per-connection</h2><ul><li>用主协程监听Listener</li><li>每个Conn使用一个新协程处理</li><li>结合了多路复用的性能和阻塞模型的简洁</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的Channel</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84Channel/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84Channel/</url>
    
    <content type="html"><![CDATA[<p>CSP模型: Communicating Sequential Process, 两个独立并发实体通过共享的通讯Channel进行通信的并发模型</p><h1 id="管道-vs-共享内存"><a href="#管道-vs-共享内存" class="headerlink" title="管道 vs 共享内存"></a>管道 vs 共享内存</h1><h2 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h2><ul><li><code>make(chan int)</code>  无缓冲</li><li><code>make(chan bool, 0)</code> &#x2F;&#x2F; 无缓冲</li><li><code>make(chan string, 2)</code> &#x2F;&#x2F; 有缓冲</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li><code>ch &lt;- x</code> &#x2F;&#x2F; 发送数据</li><li><code>x = &lt;- ch</code> &#x2F;&#x2F; 接收数据, 赋给x</li><li><code>&lt;- ch</code> &#x2F;&#x2F; 接收数据, 并丢弃</li></ul><h2 id="内存与通信"><a href="#内存与通信" class="headerlink" title="内存与通信"></a>内存与通信</h2><ul><li>不要通过共享内存的方式进行通信</li><li>而是应该通过通信的方式共享内存</li></ul><h2 id="为什么使用管道"><a href="#为什么使用管道" class="headerlink" title="为什么使用管道"></a>为什么使用管道</h2><ul><li>避免协程竞争和数据冲突的问题</li><li>更高级的抽象，降低开发难度，增加程序可读性</li><li>模块之间更容易解耦，增强扩展性和可维护性</li></ul><h1 id="如何设计"><a href="#如何设计" class="headerlink" title="如何设计"></a>如何设计</h1><p><img src="/img/Pasted%20image%2020230521221828.png"><br><img src="/img/Pasted%20image%2020230521222033.png"></p><h2 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h2><p><img src="/img/Pasted%20image%2020230521222819.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 指示channel是开放还是关闭</span><br>closed <span class="hljs-type">uint32</span> <span class="hljs-comment">// 0开启, 1关闭</span><br><br><span class="hljs-comment">// 组成一个缓存区</span><br>qcount <span class="hljs-type">uint</span><br>dataqsiz <span class="hljs-type">uint</span><br>buf unsafe.Pointer<br>elemsize <span class="hljs-type">uint16</span><br>elemtype *_type<br><br><span class="hljs-comment">// 两个队列</span><br>recvx <span class="hljs-type">uint</span> <span class="hljs-comment">// Channel接收操作处理到的位置</span><br>recvq waitq <span class="hljs-comment">// 链表</span><br><br>sendx <span class="hljs-type">uint</span><br>sendq waitq<br><br><span class="hljs-comment">// 保护hchan所有字段</span><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>环形缓存可以大幅降低GC的开销</li><li>互斥锁并不是用来排队发送&#x2F;接收数据</li><li>互斥锁保护的hchan结构体本身</li><li>Channel并不是无锁的</li></ul><h2 id="发送数据的底层原理"><a href="#发送数据的底层原理" class="headerlink" title="发送数据的底层原理"></a>发送数据的底层原理</h2><h3 id="c"><a href="#c" class="headerlink" title="c&lt;-关键字"></a><code>c&lt;-</code>关键字</h3><ul><li><code>c&lt;-关键字</code>是一个语法糖</li><li>编译阶段, 会把 <code>c&lt;-</code>转化为<code>runtime.chansend1()</code></li><li>chansend1()会调用chansend()方法</li></ul><h3 id="发送情形"><a href="#发送情形" class="headerlink" title="发送情形"></a>发送情形</h3><p><img src="/img/Pasted%20image%2020230521223417.png"></p><h4 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h4><p><img src="/img/Pasted%20image%2020230521223523.png"><br>发送数据前, 已经有G在休眠等待接收<br>此时缓存肯定是空的, 不用考虑缓存<br>将数据直接拷贝给G的接收变量, 唤醒G<br>实现:<br>    1. 从队列里去除一个等待接收的G<br>    2. 将数据直接拷贝到接收变量中<br>    3. 唤醒G</p><h4 id="放入缓存"><a href="#放入缓存" class="headerlink" title="放入缓存"></a>放入缓存</h4><p><img src="/img/Pasted%20image%2020230521224355.png"><br>没有G在休眠等待, 但是有缓存空间<br>将数据放入缓存<br>实现:<br>    1. 获取可存入的缓存地址<br>    2. 存入数据<br>    3. 维护索引</p><h4 id="休眠等待"><a href="#休眠等待" class="headerlink" title="休眠等待"></a>休眠等待</h4><p><img src="/img/Pasted%20image%2020230521224641.png"><br>没有G在休眠等待, 而且没有缓存或满了<br>自己进入发送队列, 休眠等待<br>实现:<br>    1. 把自己包装成sudog<br>    2.  sudog放入sendq队列<br>    3. 休眠并解锁<br>    4. 被唤醒后, 数据已经被取走, 维护其它数据</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>编译阶段，会把&lt;-转化为runtime.chansend1()</li><li>1.直接发送时，将数据直接拷贝到目标变量</li><li>2.放入缓存时，将数据放入环形缓存，成功返回</li><li>3.休眠等待时，将自己包装后放入sendq,休眠</li></ul><h2 id="接收数据的底层原理"><a href="#接收数据的底层原理" class="headerlink" title="接收数据的底层原理"></a>接收数据的底层原理</h2><h3 id=""><a href="#" class="headerlink" title="&lt;-c 关键字"></a><code>&lt;-c</code> 关键字</h3><ul><li><code>&lt;-c</code> 关键字也是一个语法糖</li><li>编译阶段, <code>i&lt;-c</code> 转化为<code>runtime.chanrecv1()</code></li><li>或者 <code>i, ok&lt;-c</code> 转化为<code>runtime.chanrecv2()</code></li><li>最后调用<code>chanrecv()</code>方法</li></ul><h3 id="接收情形"><a href="#接收情形" class="headerlink" title="接收情形"></a>接收情形</h3><h4 id="缓冲区空-有等待的G-从G中接收"><a href="#缓冲区空-有等待的G-从G中接收" class="headerlink" title="缓冲区空, 有等待的G, 从G中接收"></a>缓冲区空, 有等待的G, 从G中接收</h4><p><img src="/img/Pasted%20image%2020230522222015.png"><br>接收数据前, 已经有协程在休眠等待发送<br>而且这个Channel没有缓存<br>将数据直接从G拷贝过来, 唤醒G<br>实现:</p><ol><li>判断有G在发送队列等待, 进入recv()</li><li>判断次Channel无缓存</li><li>直接从等待的协程中取走数据, 唤醒G</li></ol><h4 id="缓冲区满-有等待的协程-从缓存接收"><a href="#缓冲区满-有等待的协程-从缓存接收" class="headerlink" title="缓冲区满, 有等待的协程, 从缓存接收"></a>缓冲区满, 有等待的协程, 从缓存接收</h4><p><img src="/img/Pasted%20image%2020230522222424.png"><br>接收数据前, 已经有协程在休眠等待发送<br>而且这个Channel有缓存<br>从缓存取走一个数据(先取缓存中的数据, 因为缓存中的数据比较早)<br>将休眠协程的数据放入缓存, 唤醒协程<br>实现:</p><ol><li>判断有G在发送队列等待, 进入recv()</li><li>判断此Channel有缓存</li><li>从缓存中取走一个数据</li><li>将G的数据放入缓存, 唤醒G</li></ol><h4 id="缓冲区有值-没有等待协程-从缓存接收"><a href="#缓冲区有值-没有等待协程-从缓存接收" class="headerlink" title="缓冲区有值, 没有等待协程, 从缓存接收"></a>缓冲区有值, 没有等待协程, 从缓存接收</h4><p><img src="/img/Pasted%20image%2020230522223027.png"><br>没有协程在休眠等待发送, 但是缓存有内容<br>从缓存中取走数据<br>实现:</p><ol><li>判断没有协程在发送队列等待</li><li>判断此Channel有缓存</li><li>从缓存中取走一个数据</li></ol><h4 id="缓冲区空-且没有等待发送协程-阻塞接收"><a href="#缓冲区空-且没有等待发送协程-阻塞接收" class="headerlink" title="缓冲区空, 且没有等待发送协程, 阻塞接收"></a>缓冲区空, 且没有等待发送协程, 阻塞接收</h4><p><img src="/img/Pasted%20image%2020230522223219.png"><br>没有协程在休眠等待, 而且没有缓存或者缓存为空<br>自己进入接受队列, 休眠等待<br>实现:</p><ol><li>判断没有协程在发送队列等待</li><li>判断此Channel无缓存</li><li>把自己包装成sudog</li><li>sudog放入接收等待队列, 休眠</li><li>唤醒时, 发送的G已经把数据拷贝到位</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>编译阶段，&lt;-c会转化为chanrecv()</li><li>有等待的G,且无缓存时，从G接收</li><li>有等待的G,且有缓存时，从缓存接收</li><li>无等待的G,且缓存有数据，从缓存接收</li><li>无等待的G,且缓存无数据，等待喂数据</li></ul><h2 id="非阻塞channel"><a href="#非阻塞channel" class="headerlink" title="非阻塞channel"></a>非阻塞channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- chan1:<br><span class="hljs-comment">// 如果chan1成功读到数据, 则执行该case处理语句</span><br><span class="hljs-keyword">case</span> chan2 &lt;- <span class="hljs-number">1</span>:<br><span class="hljs-comment">// 如果成功向chan2写入数据, 则执行该case处理语句</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 如果上面都没有成功, 则进入default处理流程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Select遇到多个case就绪时, 选择哪个case执行时随机的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> time.Tick(<span class="hljs-number">1</span> * time.Second) &#123;<br>ch &lt;- <span class="hljs-number">0</span><br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;case1&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-ch:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;case2&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>case1<br>case2<br>case1<br>...<br></code></pre></td></tr></table></figure><h3 id="select原理"><a href="#select原理" class="headerlink" title="select原理"></a>select原理</h3><ul><li>同时存在接收&#x2F;发送&#x2F;默认路径</li><li>首先查看是否有可以立即执行的case</li><li>没有的话, 有default, 走default</li><li>没有default, 把自己注册在所有的channel中, 休眠等待; 等待其中一个case发生就会被唤醒</li></ul><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><ul><li>timer可以提供一个channel, 定时塞入数据<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">t := time.NewTimer(time.Second) <span class="hljs-comment">// 1s后向channel放入数据</span><br>&lt;-t.C <span class="hljs-comment">// 阻塞等待数据</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><h2 id="为什么使用Channel"><a href="#为什么使用Channel" class="headerlink" title="为什么使用Channel"></a>为什么使用Channel</h2><ul><li>相对于无锁, 避免协程竞争和数据冲突的问题</li><li>相对于加锁, 更高级的抽象，降低开发难度，增加程序可读性; 模块之间更容易解耦，增强扩展性和可维护性</li></ul><h2 id="Channel的基本结构"><a href="#Channel的基本结构" class="headerlink" title="Channel的基本结构"></a>Channel的基本结构</h2><ul><li>一个环形缓存</li><li>两个链表（发送协程&#x2F;接收协程）</li><li>一个互斥锁（保护hchan)</li><li>一个状态值</li></ul><h2 id="Channel数据发送原理"><a href="#Channel数据发送原理" class="headerlink" title="Channel数据发送原理"></a>Channel数据发送原理</h2><ul><li>直接发送时，将数据直接拷贝到目标变量</li><li>放入缓存时，将数据放入环形缓存，成功返回</li><li>休眠等待时，将自己包装后放入sendq, 休眠</li></ul><h2 id="Channel数据接收原理"><a href="#Channel数据接收原理" class="headerlink" title="Channel数据接收原理"></a>Channel数据接收原理</h2><ul><li>有等待的协程, 且无缓存时，从协程接收</li><li>有等待的协程, 且有缓存时，从缓存接收</li><li>无等待的协程, 且缓存有数据，从缓存接收</li><li>无等待的协程, 且缓存无数据，等待喂数据</li></ul><h2 id="非阻塞Channel"><a href="#非阻塞Channel" class="headerlink" title="非阻塞Channel"></a>非阻塞Channel</h2><ul><li>使用select可以使用Channel的非阻塞特性</li><li>使用timer配合select可以实现超时特性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的锁</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁的基础是什么"><a href="#锁的基础是什么" class="headerlink" title="锁的基础是什么"></a>锁的基础是什么</h1><h3 id="atomic-操作"><a href="#atomic-操作" class="headerlink" title="atomic 操作"></a>atomic 操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i ++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *<span class="hljs-type">int32</span>)</span></span> &#123;<br>*p ++;<br>&#125;(&amp;c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230521162404.png"><br>结果大概率不会到1000<br>使用atomic操作就可以稳定在1000</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i ++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *<span class="hljs-type">int32</span>)</span></span> &#123;<br><span class="hljs-comment">// 汇编实现, 里面用到了LOCK指令(硬件锁)</span><br>atomic.AddInt32(p, <span class="hljs-number">1</span>); <br>&#125;(&amp;c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>原子操作是一种硬件层面加锁机制</li><li>保证操作一个变量的时候, 其它协程&#x2F;线程无法访问</li><li>只能用于简单变量的简单操作</li></ul><h3 id="sema锁"><a href="#sema锁" class="headerlink" title="sema锁"></a>sema锁</h3><ul><li>信号量锁&#x2F;信号锁</li><li>核心是一个uint32值, 含义是同时可并发的数量</li><li>每一个 sema锁都对应一个SemaRoot结构体</li><li>SemaRoot中有一个平衡二叉树用于协程排队<br><img src="/img/Pasted%20image%2020230521164239.png"></li></ul><h4 id="sema操作-uint32-0"><a href="#sema操作-uint32-0" class="headerlink" title="sema操作(uint32&gt;0)"></a>sema操作(uint32&gt;0)</h4><ul><li>获取锁 uint32-1, 获取成功</li><li>释放锁 uint32+1, 释放成功</li></ul><h4 id="sema操作-uint32-0-1"><a href="#sema操作-uint32-0-1" class="headerlink" title="sema操作(uint32==0)"></a>sema操作(<code>uint32==0</code>)</h4><ul><li>获取锁 协程休眠 进入堆树等待</li><li>释放锁 从堆树中取出一个协程, 唤醒 </li><li>sema锁 退化成一个专门休眠的队列</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>原子操作是一种硬件层面加锁的机制</li><li>数据类型和操作类型有限制</li><li>sema锁是runtime的常用工具</li><li>sema经常被用作休眠队列</li></ul><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>讲解更好: <a href="https://juejin.cn/post/7129806718816485406">https://juejin.cn/post/7129806718816485406</a><br>sync.Mutex的结构<br><img src="/img/Pasted%20image%2020230521165513.png"><br>![[Pasted image 20230728151907.png]]<br>sema地址hash后在semtable中找到semroot</p><h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><ul><li>尝试CAS直接加锁</li><li>若无法直接获取, 进行多次自旋尝试</li><li>多次尝试失败, 进入sema队列休眠<br><img src="/img/Pasted%20image%2020230521165721.png"><br>未获得锁的多次自旋尝试获取锁, 多次自旋失败之后, 就会休眠自己, 然后记录到平衡二叉树下<br><img src="/img/Pasted%20image%2020230521165827.png"><br><img src="/img/Pasted%20image%2020230521165934.png"><br> 再有协程来试图获取锁, 自旋多次失败后就会加入到等待树中<br> <img src="/img/Pasted%20image%2020230521170053.png"><br> 对state的locked字段设置是通过CAS操作完成的</li></ul><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><ul><li>尝试CAS直接解锁 </li><li>若发现有协程在sema中休眠, 唤醒一个协程</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>mutex正常模式下: 自旋加锁 + sema休眠等待</li><li>mutex正常模式下, 可能有锁饥饿的问题</li></ul><h2 id="锁饥饿"><a href="#锁饥饿" class="headerlink" title="锁饥饿"></a>锁饥饿</h2><ul><li>当前协程等待锁的时间超过了1ms, 切换到饥饿模式</li><li>饥饿模式中, 不自旋, 新来的协程直接sema休眠</li><li>饥饿模式中, 被唤醒的协程直接获取锁</li><li>没有协程在队列中继续等待时, 回到正常模式</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>锁竞争严重时, 互斥锁进入饥饿模式</li><li>界模式没有自旋等待, 有利于公平</li></ul><h3 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h3><ul><li>减少锁的使用时间(细粒度锁)</li><li>善用defer确保锁的释放</li></ul><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><h2 id="多个协程同时只读"><a href="#多个协程同时只读" class="headerlink" title="多个协程同时只读"></a>多个协程同时只读</h2><p>只读时</p><ul><li>让其他人不能修改即可</li><li>多协程可以共享读</li><li>不需要互斥锁</li></ul><h2 id="读写锁需求"><a href="#读写锁需求" class="headerlink" title="读写锁需求"></a>读写锁需求</h2><ul><li>每个锁分为读锁和写锁，写锁互斥</li><li>没有加写锁时，多个协程都可以加读锁</li><li>加了写锁时，无法加读锁，读协程排队等待</li><li>加了读锁, 写锁排队等待</li></ul><h2 id="实现读写锁"><a href="#实现读写锁" class="headerlink" title="实现读写锁"></a>实现读写锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>w Mutex <span class="hljs-comment">// 写锁</span><br>writerSem <span class="hljs-type">uint32</span> <span class="hljs-comment">// 作为写协程队列</span><br>readerSem <span class="hljs-type">uint32</span> <span class="hljs-comment">// 作为读协程队列</span><br>readerCount <span class="hljs-type">int32</span> <span class="hljs-comment">// 正值: 正在读的协程 负值:加了写锁</span><br>readerWait <span class="hljs-type">int32</span> <span class="hljs-comment">// 写锁应该等待读协程个数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230521175918.png"></p><h3 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h3><ul><li>加写锁, 没有读协程<br>加互斥锁 w, 才有加写锁的资格,  readerCount变为-rwmutexMaxReaders(1 &lt;&lt; 30 )<br><img src="/img/Pasted%20image%2020230521180251.png"></li><li>加写锁: 有读协程<br>加互斥锁 w, 才有加写锁的资格,  readerCount变为3-rwmutexMaxReaders(1 &lt;&lt; 30 ); 表示加了写锁, 但还有三个读协程没有完成, readerWait从3变为0, 才可以加上写锁<br><img src="/img/Pasted%20image%2020230521180720.png"></li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li>先加mutex写锁, 若已经被加写锁会阻塞等待</li><li>将readerCount变为负值, 阻塞读锁的获取</li><li>计算需要等待多少个读协程释放</li><li>如果需要等待读协程释放, 陷入writerSem</li></ul><h3 id="解写锁"><a href="#解写锁" class="headerlink" title="解写锁"></a>解写锁</h3><p><img src="/img/Pasted%20image%2020230521181146.png"><br><img src="/img/Pasted%20image%2020230521181322.png"></p><ul><li>将readerCount变为正值, 允许读锁的获取</li><li>释放在readerSem中等待的读协程</li><li>解锁mutex</li></ul><h3 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h3><ul><li>readerCount &gt; 0<br>没有写锁, 直接加readerCount, 去读即可</li><li>readerCount &lt; 0<br>有写锁, 给readerCount + 1, 去读队列readerSem排队</li></ul><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul><li>给readerCount 无脑 + 1</li><li>如果加完之后readerCount是正数, 加锁成功</li><li>如果加完之后readerCount是负数, 说明被加了写锁, 陷入readerSem</li></ul><h3 id="解读锁"><a href="#解读锁" class="headerlink" title="解读锁"></a>解读锁</h3><ul><li>readerCount &gt; 0<br>readerCount - 1即可</li><li>readerCount &lt; 0<br>readerCount - 1, readerWait - 1<br>如果readerWait &#x3D; 0, 写锁就可以加上了</li></ul><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>给readerCount 无脑 - 1</li><li>如果readerCount是正数, 解锁成功</li><li>如果readerCount是负数, 有写锁在排队<ul><li>如果是readerWait的最后一个, 唤醒写协程</li></ul></li></ul><h2 id="使用经验-1"><a href="#使用经验-1" class="headerlink" title="使用经验"></a>使用经验</h2><ul><li>RW锁适合读多写少的场景, 减少锁冲突</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul><li>Mutex用来写协程之间互斥等待</li><li>读协程使用readerSem等待写锁的释放</li><li>写协程使用writerSem等待读锁的释放</li><li>readerCount记录读协程个数</li><li>readerWait记录写协程之前的读协程个数</li></ul><h1 id="相互等待-WaitGroup"><a href="#相互等待-WaitGroup" class="headerlink" title="相互等待 - WaitGroup"></a>相互等待 - WaitGroup</h1><p>一个(组)协程需要等待另一组协程完成<br><img src="/img/Pasted%20image%2020230521184025.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;<br>noCopy noCopy <span class="hljs-comment">// 特殊的结构体, 表示该结构体不能被拷贝  </span><br>state1 [<span class="hljs-number">3</span>]<span class="hljs-type">uint32</span> <span class="hljs-comment">// counter, waiter counter, sema</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230521205001.png"></p><h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h2><ul><li>如果被等待的协程没了, 直接返回</li><li>否则, waiter + 1, 陷入sema</li></ul><h2 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h2><ul><li>被等待协程做完, 给counter - 1</li><li>通过<code>wg.Add(-1)</code>实现</li></ul><h2 id="Add"><a href="#Add" class="headerlink" title="Add()"></a>Add()</h2><ul><li>add counter</li><li>被等待协程没做完, 或者没人在等待, 返回</li><li>被等待协程都做完, 且有人等待, 唤醒所有sema中的协程</li></ul><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><ul><li>WaitGroup:实现了一组协程等待另一组协程等待的协程</li><li>陷入sema并记录个数</li><li>被等待的协程计数归零时，唤醒所有sema中的协程</li></ul><h1 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h1><p>整个程序运行过程中, 代码只执行一次<br>用来进行一些初始化的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用</span><br>once := sync.Once&#123;&#125;<br><span class="hljs-keyword">go</span> once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;&#125;)<br><br><span class="hljs-comment">// 实现</span><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>done <span class="hljs-type">uint32</span><br>m Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>o.m.Lock()<br><span class="hljs-keyword">defer</span> o.m.Unlock()<br><span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>f()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先判断是否已经改值</li><li>没改, 尝试获取锁</li><li>获取到锁的协程执行业务, 改值, 解锁</li><li>冲突协程唤醒后直接返回</li></ul><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul><li>sync.Once实现了一段代码只执行一次</li><li>使用标志+mutex:实现了并发冲突的优化</li></ul><h1 id="锁常见问题"><a href="#锁常见问题" class="headerlink" title="锁常见问题"></a>锁常见问题</h1><h2 id="锁拷贝"><a href="#锁拷贝" class="headerlink" title="锁拷贝"></a>锁拷贝</h2><ul><li>锁拷贝可能导致锁的死锁问题</li><li>使用vet工具可以检测锁拷贝问题</li><li>vet还能检测可能的bug或者可疑的构造</li></ul><h2 id="RACE竞争检测"><a href="#RACE竞争检测" class="headerlink" title="RACE竞争检测"></a>RACE竞争检测</h2><ul><li>发现隐含的数据竞争问题</li><li>可能是加锁的建议</li><li>可能是bug的提醒</li></ul><h2 id="go-deadlock检测"><a href="#go-deadlock检测" class="headerlink" title="go-deadlock检测"></a>go-deadlock检测</h2><ul><li>检测可能的死锁</li><li>实际是检测获取锁的等待时间</li><li>用来排查bug和性能问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>锁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的协程</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要有协程"><a href="#为什么要有协程" class="headerlink" title="为什么要有协程"></a>为什么要有协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>操作系统程序的最小单位</li><li>进程用来占用内存空间</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>每个进程可以有多个线程</li><li>线程使用系统分配给进程的内存, 线程之间共享内存</li><li>线程用来占用CPU时间</li><li>线程的调度需要由系统进行, 开销较大</li></ul><h3 id="线程的问题"><a href="#线程的问题" class="headerlink" title="线程的问题"></a>线程的问题</h3><ul><li>线程本身占用资源大</li><li>线程的操作开销大</li><li>线程切换开销大</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>协程就是将一段程序的运行状态打包, 可以在线程之间调度</li><li>将生产流程打包, 使得流程不固定在生产线上</li><li>协程并不取代线程, 协程也要放在线程上运行</li><li>线程是协程的资源, 协程使用线程这个资源</li></ul><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><ul><li>资源利用</li><li>快速调度</li><li>超高并发</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>进程用于分配内存空间</li><li>线程用来分配CPU空间</li><li>协程用来精细利用线程</li><li>协程的本质是一段包含了运行状态的程序</li></ul><h2 id="协程的本质"><a href="#协程的本质" class="headerlink" title="协程的本质"></a>协程的本质</h2><p>协程在Go语言中的本质就是一个g结构体(位于runtime2.go). </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>stack stack <span class="hljs-comment">// 栈信息</span><br><span class="hljs-comment">// ...</span><br>sched gobuf <span class="hljs-comment">// 目前程序运行现场</span><br>atomicstatus <span class="hljs-type">uint32</span> <span class="hljs-comment">// 协程状态</span><br>goid <span class="hljs-type">int64</span> <span class="hljs-comment">// 协程的ID号  </span><br>&#125;<br><br><span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;<br>lo <span class="hljs-type">uintptr</span><br>hi <span class="hljs-type">uintptr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// stack pointer, 栈指针, 指向栈用到了什么地方</span><br>sp <span class="hljs-type">uintptr</span><br><span class="hljs-comment">// program counter, 程序计数器, 运行到了哪条代码</span><br>pc <span class="hljs-type">uintptr</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230520222112.png"><br>协程如何描述(runtime2.go下的struct m)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-keyword">go</span> *g <span class="hljs-comment">// go语言第一个协程, 操作调度器</span><br>curg *g <span class="hljs-comment">// 正在运行的协程</span><br>mOS <span class="hljs-comment">// 针对操作系统所记录的线程信息(os_linux / windows / darwin ...)</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协程如何执行"><a href="#协程如何执行" class="headerlink" title="协程如何执行"></a>协程如何执行</h2><h3 id="单线程循环-Go-0-x"><a href="#单线程循环-Go-0-x" class="headerlink" title="单线程循环(Go 0.x)"></a>单线程循环(Go 0.x)</h3><p><img src="/img/Pasted%20image%2020230520222715.png"><br><img src="/img/Pasted%20image%2020230520223748.png"></p><h3 id="多线程循环-Go-1-0"><a href="#多线程循环-Go-1-0" class="headerlink" title="多线程循环(Go 1.0)"></a>多线程循环(Go 1.0)</h3><p><img src="/img/Pasted%20image%2020230520223924.png"><br><img src="/img/Pasted%20image%2020230520224057.png"></p><h3 id="线程循环"><a href="#线程循环" class="headerlink" title="线程循环"></a>线程循环</h3><ul><li>操作系统并不知道Goroutine的存在</li><li>操作系统线程执行一个调度循环(Go代码或者会变组成)，顺序执行Goroutine</li><li>调度循环非常像线程池<br>问题:</li><li>协程顺序执行, 无法并发</li><li>多线程并发时, 会抢夺协程队列的全局锁</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>协程的本质是一个g结构体</li><li>结构体记录了协程栈、PC信息</li><li>最简情况下，线程执行标准调度循环，执行协程</li></ul><h2 id="G-M-P调度模型"><a href="#G-M-P调度模型" class="headerlink" title="G-M-P调度模型"></a>G-M-P调度模型</h2><p>前序的调度像是本地队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>m muintptr <span class="hljs-comment">// 指向相关的线程, 服务于一个线程</span><br><span class="hljs-comment">// 可执行的协程队列, 可无锁访问</span><br>runqhead <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队头</span><br>runqtail <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队尾</span><br>runq [<span class="hljs-number">256</span>]guintptr<br>runnext guintptr <span class="hljs-comment">// 下一个可用的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230520224937.png"><br><img src="/img/Pasted%20image%2020230520225028.png"><br>如果本地协程执行完成, 获取全局的锁, 取全局拉取协程<br><img src="/img/Pasted%20image%2020230520225134.png"></p><h3 id="P的作用"><a href="#P的作用" class="headerlink" title="P的作用"></a>P的作用</h3><ul><li>M与G之间的中介(送料器)</li><li>P持有一些G, 使得每次获取G的时候不用从全局找</li><li>大大减少了并发冲突的情况</li></ul><h3 id="任务窃取"><a href="#任务窃取" class="headerlink" title="任务窃取"></a>任务窃取</h3><p>本地(m)和全局的携程队列都没有任务, 可以去别的p中获取, 增加了线程利用率<br><img src="/img/Pasted%20image%2020230520225828.png"><br><img src="/img/Pasted%20image%2020230520225846.png"></p><h3 id="新建协程"><a href="#新建协程" class="headerlink" title="新建协程"></a>新建协程</h3><ul><li>随机寻找一个P</li><li>将新协程放入P的runnext(插队)</li><li>如果P本地队列满, 放入全局队列</li></ul><p>GMP模型减少了全局协程队列锁的获取</p><h2 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h2><h3 id="协程的饥饿问题"><a href="#协程的饥饿问题" class="headerlink" title="协程的饥饿问题"></a>协程的饥饿问题</h3><p><img src="/img/Pasted%20image%2020230520230310.png"><br>长协程会长期占用M, 导致其它饥饿 </p><h3 id="线程循环-触发切换"><a href="#线程循环-触发切换" class="headerlink" title="线程循环(触发切换)"></a>线程循环(触发切换)</h3><p><img src="/img/Pasted%20image%2020230520230549.png"><br> <img src="/img/Pasted%20image%2020230520230648.png"><br> 但全局队列可能会存在饥饿问题, 通过再添加一层循环解决.<br> 以一定的概率, 从全局队列拿任务到M中(代码中是每执行61次)<br> <img src="/img/Pasted%20image%2020230520230814.png"></p><h3 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h3><ul><li>主动挂起(runtime.gopark)<br><img src="/img/Pasted%20image%2020230520231107.png"><br>time.Sleep中会包含gopark操作</li><li>系统调用完成时<br><img src="/img/Pasted%20image%2020230520231320.png"></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>如果协程顺序执行，会有饥饿问题</li><li>协程执行中间，将协程挂起，执行其他协程</li><li>完成系统调用时挂起，也可以主动挂起</li><li>防止全局队列饥饿，本地队列随机抽取全局队列<br>永远不主动挂起, 也不系统调用, 如何处理?</li></ul><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><ul><li>有没有一个地方, 经常会被调用</li><li>涉及到调用其他方法都会调用 runtime.morestak()</li><li>morestack的本意是检查协程栈知否有足够的空间</li><li>调用方法时, 会被编译器插入morestack()</li></ul><h3 id="标记抢占"><a href="#标记抢占" class="headerlink" title="标记抢占"></a>标记抢占</h3><ul><li>系统检测到Goroutine运行超过10ms</li><li>将g.stackguard0置为0xfffffade</li></ul><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ul><li>执行morestack()时判断是否被抢占</li><li>如果被抢占, 回到schedule()</li><li>基于协作的抢占式调度<br><img src="/img/Pasted%20image%2020230521141053.png" alt="基于协作的抢占式调度"></li><li>如果任何函数调用(没有morestack), 则使用基于信号的抢占式调度</li></ul><h3 id="线程信号"><a href="#线程信号" class="headerlink" title="线程信号"></a>线程信号</h3><ul><li>操作系统中, 有很多基于信号的底层通信方式 eg. SIGPIPE &#x2F; SIGURG &#x2F; SIGHUP</li><li>线程可以注册对应信号的处理函数</li></ul><h3 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h3><ul><li>注册SIGURG信号的处理函数 </li><li>GC工作时, 向目标线程发送信号</li><li>线程收到信号, 会发生调度<br><img src="/img/Pasted%20image%2020230521141748.png"></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>基于系统调用和主动挂起，协程可能无法调度</li><li>基于<strong>协作</strong>的抢占式调度：业务主动调用morestack()</li><li>基于<strong>信号</strong>的抢占式调度：强制线程调用doSigPreempt()</li></ul><h2 id="协程开太多会怎么样"><a href="#协程开太多会怎么样" class="headerlink" title="协程开太多会怎么样"></a>协程开太多会怎么样</h2><p><code>panic: too many concurrent operations on a single file or socket (max 1048575)</code></p><ul><li>文件打开数限制</li><li>内存限制</li><li>调度开销过大</li></ul><h3 id="处理协程太多的方案"><a href="#处理协程太多的方案" class="headerlink" title="处理协程太多的方案"></a>处理协程太多的方案</h3><ul><li>优化业务逻辑</li><li>利用channel缓冲区(限制总数)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(i <span class="hljs-type">int</span>, ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>fmt.Println(i)<br>time.Sleep(time.Second)<br>&lt;- ch<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">3000</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; math.MaxInt32; i++ &#123;<br>c &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">go</span> do(i, c)<br>&#125;<br>time.Sleep(time.Hour)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>协程池(tunny)<br><img src="/img/Pasted%20image%2020230521151714.png"><ul><li>预创建一定数量的协程</li><li>将任务送入协程池队列</li><li>协程池不断取出可用协程, 执行任务</li><li>Go语言的线程, 已经相当于池化了</li><li>二级池化会增加系统复杂度</li><li>Go语言的初衷是希望协程即用即毁, 不要池化</li></ul></li><li>调整系统资源</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>太多的协程会给程序运行带来性能和稳定性问题</li><li>牺牲并发特性，利用channel缓冲</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><h3 id="为什么用协程"><a href="#为什么用协程" class="headerlink" title="为什么用协程"></a>为什么用协程</h3><ul><li>协程用来精细利用线程</li><li>协程可以支撑超高并发</li></ul><h3 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h3><ul><li>从runtime的角度看，协程是一个可以被调度的g结构体</li><li>从线程的角度看，协程是一段程序，自带执行现场</li></ul><h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><ul><li>通过P结构体，达成了缓存部分G的目的</li><li>P本质上是一个G的本地队列，避免全局并发等待</li><li>窃取式工作分配机制能够更加充分利用线程资源</li></ul><h3 id="协程并发-1"><a href="#协程并发-1" class="headerlink" title="协程并发"></a>协程并发</h3><ul><li>如果协程顺序执行，会有饥饿问题</li><li>协程执行中间，将协程挂起，执行其他协程</li><li>完成系统调用时挂起，也可以主动挂起</li><li>防止全局队列饥饿，本地队列随机抽取全局队列</li></ul><h3 id="抢占式调度-1"><a href="#抢占式调度-1" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><ul><li>基于系统调用和主动挂起，协程可能无法调度</li><li>基于<strong>协作</strong>的抢占式调度：业务主动调用morestack()</li><li>基于<strong>信号</strong>的抢占式调度：强制线程调用doSigPreempt()</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>Goroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的包管理方式</title>
    <link href="/2023/09/01/Go%E4%B8%AD%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/09/01/Go%E4%B8%AD%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><p>本质上, 一个Go包就是一个项目的原码<br>gomod的作用: 将Go包和Git项目关联起来<br>Go包的版本就是git项目的Tag<br>gomod就是解决”需要哪个git项目的什么版本”</p><h2 id="使用Modules"><a href="#使用Modules" class="headerlink" title="使用Modules"></a>使用Modules</h2><ul><li>github.com&#x2F;Jeffail&#x2F;tunny<br><code>go get github.com/Jeffail/tunny</code><br><code>go get github.com/Jeffail/tunny@0.1.3</code></li></ul><h2 id="用本地文件替代"><a href="#用本地文件替代" class="headerlink" title="用本地文件替代"></a>用本地文件替代</h2><ul><li>go.mod 文件追加<br>replace  github.com&#x2F;Jeffail&#x2F;tunny &#x3D;&gt; xxx&#x2F;xxx</li><li>go vender 缓存到本地<br>go mod vendor<br>go build -mod vendor</li></ul><h2 id="创建Go-module"><a href="#创建Go-module" class="headerlink" title="创建Go module"></a>创建Go module</h2><p>创建go.mod即可</p><ul><li>删除本地的go.mod<br><code>go mod init github.com/bing-zhub/xxx</code></li><li>推送至代码仓库</li><li>增加新版本时, 在仓库打新Tag</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的数据结构</title>
    <link href="/2023/09/01/Go%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/09/01/Go%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="基本类型的字节数"><a href="#基本类型的字节数" class="headerlink" title="基本类型的字节数"></a>基本类型的字节数</h2><p>可以用Unsafe.Sizeof查看任何变量的字节大小</p><ul><li>int大小跟随系统字长</li><li>指针的大小也是系统字长</li></ul><h2 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h2><p>空结构体大小为0<br>但有地址, 但所有的空结构体(独立出现, 没有被其它struct引用)都指向同一地址(zerobase, 0x8a82f8)<br>当被内嵌在其它struct中, 地址不是zerobase<br>空结构体主要是为了节约内存,<br>比如使用map实现hashset </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// value 不占任何空间</span><br>hashSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>hashSet[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br></code></pre></td></tr></table></figure><p>比如用channel传输信号, 不想携带任何信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串本质上是个结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer<br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对string取Sizeof的时候, 取的是指针大小.<br>Data指针指向底层Byte数组<br>len表示byte数组的长度, 编码不同, 字符的个数也不同(UTF8下, 一个字符占三个字节)</p><h3 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h3><p>所有字符都是用Unicode字符集,使用UTF-8编码</p><ul><li>Unicode字符集<br>一种统一的字符集, 包含了绝多数文字的绝大多数字符, 14w个字符, 至少需要3字节(2^24)才能表示<br>英文字母排在前128个</li><li>UTF-8编码<br>Unicode的一种变长格式<br>128个US-ASCII字符只需一个字节编码<br>西方常用字符需要两个字节<br>其他字符3个字节, 极少4个字节</li></ul><h3 id="字符串遍历"><a href="#字符串遍历" class="headerlink" title="字符串遍历"></a>字符串遍历</h3><p>自动判断多个字节是不是一个字符的不同部分(runtime下的utf8.go实现, rune就是UTF-8编码)<br>字符串被range遍历的时候, 被解码成rune类型的字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;中国科学院&quot;</span><br><span class="hljs-comment">// 这样不正确</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;  <br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, s[i])  <br>&#125;<br><span class="hljs-comment">// 正确方式</span><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, c)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><ol><li>转为rune数组</li><li>切片</li><li>转为string<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s = <span class="hljs-type">string</span>([]<span class="hljs-type">rune</span>(s)[:<span class="hljs-number">3</span>]) <span class="hljs-comment">// 取前三个汉字</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>是一个结构体<br>切片的本质是对数组的引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>  array unsafe.Pointer<br>  <span class="hljs-built_in">len</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 长度</span><br>  <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 总容量</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片创建"><a href="#切片创建" class="headerlink" title="切片创建"></a>切片创建</h3><ul><li>根据数组创建<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">arr[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br>slice[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li><li>字面量创建: 编译时插入创建数组的代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></li><li>make: 运行时创建数组<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><ul><li>不扩容时, 只调整len(编译器负责)</li><li>扩容时, 编译时转为调用runtime.growslice()<br><code>&lt; 1024</code>的时候, 二倍增长, 将原数据复制过来.<br><code>&gt; 1024</code>的时候, 每次增加25%<br>切片扩容时, 并发不安全, 注意切片并发需要加锁</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>字符串与切片都是对底层数组的引用</li><li>字符串有UTF-8变长编码的特点</li><li>切片的容量和长度不同</li><li>切片追加时, 可能需要重新创建底层数组</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li>开放寻址法</li><li>拉链法<br><img src="/img/20230510221809.png" alt="20230510221809.png"><br>Go语言的map使用的是拉链法, 在<code>runtime.hmap</code>中, hmap被定义为<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>count <span class="hljs-type">int</span><br>flags <span class="hljs-type">uint8</span><br>B <span class="hljs-type">uint8</span><br>nooverflow <span class="hljs-type">uint16</span><br>hash0 <span class="hljs-type">uint32</span><br><br>buckets unsafe.Pointer<br>oldbuckets unsafe.Pointer<br>nevacuate <span class="hljs-type">uintptr</span><br>extra *mapextra<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/20230510222352.png" alt="20230510222352.png"><br><code>2^B</code>个bucket, b map is a bucket for a Go map<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// bucketCntBits = 3</span><br><span class="hljs-comment">// bucketCnt = 1 &lt;&lt; bucketCntBits</span><br>  tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="map的初始化"><a href="#map的初始化" class="headerlink" title="map的初始化"></a>map的初始化</h3><ul><li>make<br><code>m := make(map[string]int, 10)</code><br><img src="/img/20230510223101.png" alt="20230510223101.png"></li><li>字面量<br>元素少于25个时, 转化为简单赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-number">6</span>,<br>&#125;<br><span class="hljs-comment">// 转化为</span><br>hash := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br>hash[<span class="hljs-string">&quot;1&quot;</span>] = <span class="hljs-number">2</span><br>hash[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-number">4</span><br>hash[<span class="hljs-string">&quot;5&quot;</span>] = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>元素多于25个时, 转化为循环赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br><span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-number">1</span><br><span class="hljs-string">&quot;2&quot;</span> : <span class="hljs-number">2</span> <br>...<br><span class="hljs-string">&quot;26&quot;</span>: <span class="hljs-number">26</span><br>&#125;<br><span class="hljs-comment">// 转化为</span><br>hash := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>vstatk := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, ... , <span class="hljs-string">&quot;26&quot;</span>&#125;<br>vstatv := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ..., <span class="hljs-number">26</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(vstak); i++ &#123;<br>hash[vstatk[i]] = vstatk[i]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="map的访问"><a href="#map的访问" class="headerlink" title="map的访问"></a>map的访问</h3><ol><li>计算桶号<br><img src="/img/20230510224041.png" alt="20230510224041.png"></li><li>计算tophash<br><img src="/img/20230510223911.png" alt="20230510223911.png"></li><li>匹配<br> <img src="/img/20230510224212.png" alt="20230510224212.png"><br> 从第二个桶中找到tophash等于0x5c的kv, 看k是不是我们想要的, 如果是则返回v.<br> 如果碰撞, 继续线性查找, 如果该bucket也没有, 则去查找溢出桶, 如果都没有则该k不存在.<blockquote><p>写入也类似</p></blockquote></li></ol><h3 id="map扩容"><a href="#map扩容" class="headerlink" title="map扩容"></a>map扩容</h3><p>当hash碰撞过多的时候, 溢出桶数量增加, 会退化成一个链表<br><img src="/img/20230510224803.png" alt="20230510224803.png"><br>map溢出桶太多会导致严重的性能下降<br>runtime.mapassign()可能会触发扩容的情况</p><ol><li>装载因子超过6.5(品骏每个槽6.5个key)</li><li>使用了太多溢出桶(溢出桶超过了普通桶)</li></ol><h4 id="map的扩容类型"><a href="#map的扩容类型" class="headerlink" title="map的扩容类型"></a>map的扩容类型</h4><ul><li>等量扩容<br>数据不多但是溢出桶太多了(整理)</li><li>翻倍扩容<br>数据太多了</li></ul><p>扩容步骤</p><ol><li>创建一组新桶</li><li>oldbuckets指向原有的桶数组</li><li>buckets指向新的桶数组</li><li>map标记为扩容状态</li><li>将所有的数据从旧桶驱逐到新桶</li><li>采用渐进式驱逐</li><li>每次操作一个旧桶时, 将旧桶数据驱逐到新桶</li><li>读取时不进行驱逐, 只判断读取新桶还是旧桶</li><li>所有的旧桶驱逐完成后</li><li>oldbuckets回收</li></ol><h4 id="map的并发"><a href="#map的并发" class="headerlink" title="map的并发"></a>map的并发</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>_ = m[<span class="hljs-number">1</span>]<br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>m[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>&#125;<br>&#125;()<br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无法编译<code>fatal error: concurrent map read and map write</code><br>A协程在桶中读数据时, B协程驱逐了这个桶, 那么A协程就会读到错误的数据或者找不到数据<br><img src="/img/20230511203607.png" alt="20230511203607.png"><br>解决方案</p><ul><li>给map加锁(mutex)</li><li>使用sync.Map<br><img src="/img/20230511203912.png" alt="20230511203912.png"><br>追加”d”:D<br><img src="/img/20230511204247.png" alt="20230511204247.png"><br>追加后的读写(misses ++ ), 先去read没有找到d, amended为true, 去dirty查找, 找到对应kv, misses ++<br><img src="/img/20230511204503.png" alt="20230511204503.png"><br>dirty提升, <code>misses = len(dirty)</code>时, dirty提升为read的m, 置回初始状态<br><img src="/img/20230511210918.png" alt="20230511210918.png"><br>删除操作</li><li>正常删除<br><img src="/img/20230511211202.png" alt="20230511211202.png"><br>k置成nil后, GC会自动将v回收</li><li>追加后删除<br><img src="/img/20230511211420.png" alt="20230511211420.png"><br>后面需要提升的话, 要特殊处理<br><img src="/img/20230511211556.png" alt="20230511211556.png"><br>提升后被删key还需要特殊处理<br>不是读写分离, 而是普通读写和追加分离</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>Go语言使用拉链实现了hashmap</li><li>每一个桶中存储键哈希的前8位</li><li>桶超出8个数据, 就会存储到溢出桶中</li><li>装载系数或者溢出桶的增加, 会触发map扩容</li><li>扩容可能并不是增加桶数, 而是整理</li><li>map扩容采用渐进式, 桶被操作时才会重新分配</li><li>map才扩容的时候会有并发问题</li><li>sync.Map使用了两个Map, 分离了扩容问题</li><li>不会引发扩容的操作(查 改)使用read map</li><li>会引发扩容的操作(新增)使用dirty map</li><li>读多写多, 追加少的时候性能好</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口显式好还是隐式好?</p><h3 id="Go隐式接口特点"><a href="#Go隐式接口特点" class="headerlink" title="Go隐式接口特点"></a>Go隐式接口特点</h3><ul><li>只要实现了接口的全部方法, 就是自动实现接口</li><li>可以在不修改代码的情况下抽象出新的接口</li></ul><h3 id="接口的底层表示"><a href="#接口的底层表示" class="headerlink" title="接口的底层表示"></a>接口的底层表示</h3><p>底层使用<code>runtime.iface</code>表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span>&#123; <br>tab *itab <span class="hljs-comment">// 接口类型, 接口装载的类型, 实现了哪些方法</span><br>data unsafe.Pointer <span class="hljs-comment">// 指向结构体(数据)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><ul><li>类型断言是一个使用在接口值上的操作</li><li>可以将接口值转换为其它类型值(实现或者兼容接口)</li><li>还可以配合switch 进行类型判断<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c Car = Truck&#123;&#125;<br>t := c.(Truck)<br></code></pre></td></tr></table></figure>接受者为结构体的时候, 会自动添加一个接受者为指针的方法; 但如果用结构体指针实现了方法, 只会存在指针的.<br><img src="/img/20230511222155.png" alt="20230511222155.png"></li></ul><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>是eface<br>可以承载任何类型.<br>底层不是普通接口</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>作为任意类型的函数入参</li><li>函数调用的时候, 会新生成一个空接口, 再传参</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>Go的隐式接口更方便系统的扩展和重构</li><li>接口提和指针都可以实现接口</li><li>空接口值可以称在任何类型的数据</li></ul><h2 id="nil-空接口-空结构体"><a href="#nil-空接口-空结构体" class="headerlink" title="nil 空接口 空结构体"></a>nil 空接口 空结构体</h2><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><ul><li>nil是空, 但不一定是空指针</li><li>是pointer, channel, func, interface, map, slice其中之一的零值</li><li>每种类型的nil是不同的, 无法比较</li></ul><h3 id="空结构体-1"><a href="#空结构体-1" class="headerlink" title="空结构体"></a>空结构体</h3><ul><li>空结构体是Go中非常特殊的类型</li><li>空结构体的值不是nil</li><li>空结构体的指针也不是nil 但都是相同的(zerobase)</li></ul><h3 id="空接口-1"><a href="#空接口-1" class="headerlink" title="空接口"></a>空接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// a最初是空的eface</span><br>fmt.Println(a == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br><span class="hljs-keyword">var</span> c *<span class="hljs-type">int</span><br>a = c <span class="hljs-comment">// c赋给a之后, 数据为nil, 但类型变为*int, 不是nil</span><br>fmt.Println(c == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br>fmt.Println(a == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li>空接口不一定是”nil接口”</li><li>两个属性都是nil才是nil接口</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>nil是多个类型的零值, 或者空值</li><li>空结构体的指针和值都不是nil</li><li>空接口零值是nil, 一旦有了类型信息就不是nil</li></ul><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int32</span><br>num2 <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int16</span><br>num2 <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230520185105.png" alt="非内存对齐"><br><img src="/img/Pasted%20image%2020230520185306.png" alt="内存对齐"></p><ul><li>内存对齐: 提高内存操作效率, 有利于内存原子性</li></ul><h3 id="对齐系数"><a href="#对齐系数" class="headerlink" title="对齐系数"></a>对齐系数</h3><p><code>unsafe.Alignof()</code><br>对齐系数: 变量的内存地址必须被对齐系数整除<br>如果对齐系数为4, 变量内存地址必须是4的倍数</p><h3 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h3><ul><li><p>结构体对齐分为内部对齐和结构体之间对齐</p></li><li><p>内部对齐：考虑成员大小和成员的对齐系数</p><ul><li>指的是结构体内部成员的相对位置（偏移量）</li><li>每个成员的偏移量是自身大小与其对齐系数较小值的倍数</li><li>可以尝试通过调整成员顺序, 节约空间</li><li>结构体的对齐系数为成员最大的对齐系数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span> <span class="hljs-comment">// 大小1, 对齐系数1</span><br>b <span class="hljs-type">string</span> <span class="hljs-comment">// 大小16, 对齐系数8</span><br>c <span class="hljs-type">int16</span> <span class="hljs-comment">// 大小2, 对齐系数2, 必须保持顺序</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/Pasted%20image%2020230520185957.png" alt="结构体内部对齐, 顺序严格遵守"></li></ul></li><li><p>结构体长度填充：考虑自身对齐系数和系统字长</p><ul><li>指的是结构体通过增加长度，对齐系统字长</li><li>结构体长度是最大成员长度与系统字长较小的整数倍</li></ul></li></ul><h3 id="空结构体的对齐"><a href="#空结构体的对齐" class="headerlink" title="空结构体的对齐"></a>空结构体的对齐</h3><ul><li>空结构体单独出现时为zerobase</li><li>空结构体出现在<strong>结构体中</strong>时, 地址跟随前一个变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span><br>z <span class="hljs-keyword">struct</span>&#123;&#125;<br>c <span class="hljs-type">int16</span><br>b <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/Pasted%20image%2020230520190857.png" alt="空结构体出现在结构体中"></li><li>空结构体出现在<strong>结构体末尾</strong>时, 需要补齐字长<br><img src="/img/Pasted%20image%2020230520191107.png" alt="空结构体出现在结构体末尾"></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>提高内存操作效率，变量之间需要内存对齐</li><li>基本类型考虑对齐系数</li><li>结构体既需要内部对齐，又需要外部填充对</li><li>齐空结构体作为最后一个成员，需要填充对齐</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><h3 id="变量长度"><a href="#变量长度" class="headerlink" title="变量长度"></a>变量长度</h3><ul><li>Go中部分数据的长度与系统字长有关</li><li>空结构体不占用空间</li><li>空结构体与map结合可以实现nashset</li><li>空结构体与channel结合可以当作纯信号</li></ul><h3 id="字符串与切片"><a href="#字符串与切片" class="headerlink" title="字符串与切片"></a>字符串与切片</h3><ul><li>字符串与切片都是对底层数组的引用</li><li>字符串有UTF-8变长编码的特点</li><li>切片的容量和长度不同</li><li>切片追加时可能需要重建底层数组</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>Go语言使用拉链实现了hashmap</li><li>每一个桶中存储键哈希的前8位</li><li>桶超出8个数据，就会存储到溢出桶中</li></ul><h3 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a>map的扩容</h3><ul><li>装载系数或者谥出桶的增加，会触发map扩容</li><li>“扩容”可能并不是增加桶数，而是整理</li><li>map扩容采用<strong>渐进式</strong>，桶被操作时才会重新分配</li></ul><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><ul><li>map在扩容时会有并发问题</li><li>sync.Map使用了两个map,分离了扩容问题</li><li>不会引发扩容的操作（查、改）使用read map</li><li>可能引发扩容的操作(新增)，使用dirty map</li></ul><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><ul><li>Go的隐式接口更加方便系统的扩展和重构</li><li>结构体和指针都可以实现接口</li><li>空接口值可以承载任何类型的数据</li></ul><h3 id="nil-空结构体-空接口"><a href="#nil-空结构体-空接口" class="headerlink" title="nil&#x2F;空结构体&#x2F;空接口"></a>nil&#x2F;空结构体&#x2F;空接口</h3><ul><li>nil是多个类型的零值，或者空值</li><li>空结构体的指针和值都不是nil</li><li>空接口零值是nil,一旦有了类型信息就不是nil</li></ul><h3 id="内存对齐-1"><a href="#内存对齐-1" class="headerlink" title="内存对齐"></a>内存对齐</h3><ul><li>提高内存操作效率，变量之间需要内存对齐</li><li>基本类型考虑对齐系数</li><li>结构体既需要内部对齐，又需要外部填充对齐</li><li>空结构体作为最后一个成员，需要填充对齐</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go是不是面向对象</title>
    <link href="/2023/09/01/Go%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/09/01/Go%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>Go允许OO的编程风格<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> walk() &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Go的Struct可以看做是其他语言的Class</li><li>Go缺乏其它语言的继承结构</li><li>Go的接口与其它语言有很大差异</li></ul><h2 id="Go的”类”"><a href="#Go的”类”" class="headerlink" title="Go的”类”"></a>Go的”类”</h2><ul><li>其它语言, 往往用class表示一类数据</li><li>class的每一个实例称作”对象”</li><li>Go中用struct表示一类数据</li><li>struct的每一个实例并不是对象, 而是此类型的值</li><li>struct也可以定义方法</li></ul><h2 id="Go的继承"><a href="#Go的继承" class="headerlink" title="Go的继承"></a>Go的继承</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>Person<br>&#125;<br>m := Man&#123;&#125;<br>m.walk() <span class="hljs-comment">// 语法糖, 实际上是 m.People.walk()</span><br></code></pre></td></tr></table></figure><ul><li>Go没有继承关系</li><li>所谓Go的继承只是组合</li><li>组合中的匿名字段, 通过语法糖达成了类似继承的效果</li></ul><h2 id="Go的接口"><a href="#Go的接口" class="headerlink" title="Go的接口"></a>Go的接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> alive <span class="hljs-keyword">interface</span> &#123;<br>walk()<br>&#125;<br><br><span class="hljs-comment">// 实现alive接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p Person)</span></span> walk() &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>接口可以定义Go中的一组行为相似的struct</li><li>struct并不显式实现接口, 而是隐式实现</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Go没有对象, 没有类, 没有继承</li><li>Go通过组合匿名字段来达到类似继承的效果</li><li>通过以上手段去掉了面向对象中复杂而冗余的部分</li><li>保留了基本的面向对象特性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go是如何运行的</title>
    <link href="/2023/09/01/Go%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <url>/2023/09/01/Go%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>并非是main方法<br>runtime包, <code>_rt0_linux_amd64.s</code>. 汇编程序<br><code>asm_amd64.s</code>, </p><h2 id="读取命令行参数"><a href="#读取命令行参数" class="headerlink" title="读取命令行参数"></a>读取命令行参数</h2><ul><li>复制参数数量argc和参数值argv到栈上</li></ul><h2 id="初始化g0执行栈"><a href="#初始化g0执行栈" class="headerlink" title="初始化g0执行栈"></a>初始化g0执行栈</h2><ul><li>g0是为了调度协程而产生的的协程</li><li>g0是每个Go程序的第一个协程</li></ul><h2 id="运行时检测"><a href="#运行时检测" class="headerlink" title="运行时检测"></a>运行时检测</h2><ul><li>检查各种类型的长度</li><li>检查指针操作</li><li>检查结构体字段的偏移量</li><li>检查atomic原子类型</li><li>检查CAS操作</li><li>检查栈的大小是否为2的幂次</li></ul><h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><ul><li>对命令行中的参数进行处理</li><li>参数数量赋值给<code>argc int32</code></li><li>参数值赋值给<code>argv **byte</code></li></ul><h2 id="调度器初始化-runtime-schedinit"><a href="#调度器初始化-runtime-schedinit" class="headerlink" title="调度器初始化 runtime.schedinit"></a>调度器初始化 runtime.schedinit</h2><ul><li>全局栈空间内存分配</li><li>加载命令行参数到os.Args</li><li>堆内存空间初始化</li><li>加载操作系统环境变量</li><li>初始化当前系统线程</li><li>垃圾回收器的参数初始化</li><li>算法初始化(map&#x2F;hash)</li><li>设置process数量</li></ul><h2 id="创建主协程"><a href="#创建主协程" class="headerlink" title="创建主协程"></a>创建主协程</h2><ul><li>创建一个新的协程, 执行runtime.main(此前已经有一个g0协程)</li><li>放入调度器等待调度</li></ul><h2 id="初始化M"><a href="#初始化M" class="headerlink" title="初始化M"></a>初始化M</h2><ul><li>初始化一个M, 用来调度主协程</li></ul><h2 id="主协程执行主函数"><a href="#主协程执行主函数" class="headerlink" title="主协程执行主函数"></a>主协程执行主函数</h2><ul><li>执行runtime包中的init方法</li><li>启动GC垃圾收集器</li><li>执行用户包依赖的init方法</li><li>执行用户主函数main.main()</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go启动时经历了检查, 各种初始化, 初始化协程调度的过程<br>main.main()也是在协程中运行的<br>Go程序的启动过程像一个虚拟机, 或框架.</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
