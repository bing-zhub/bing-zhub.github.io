<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MQTT over QUIC</title>
    <link href="/2023/09/02/MQTT-over-QUIC/"/>
    <url>/2023/09/02/MQTT-over-QUIC/</url>
    
    <content type="html"><![CDATA[<h1 id="MQTT介绍"><a href="#MQTT介绍" class="headerlink" title="MQTT介绍"></a>MQTT介绍</h1><ul><li>物联网广泛应用车联网 &#x2F; 工业制造 &#x2F; 能源电力 &#x2F; 智能家居, </li><li>相比于HTTP这种文本协议报文紧凑, 对流量敏感场景友好</li><li>二进制协议, 可以承载任何数据, JSON &#x2F; Protobuf &#x2F; Ciphertext</li><li>发布订阅机制, 轻耦合, 更加专注于业务逻辑的开发, 开发效率提升, 灵活的新增减少主题, 增加发布者订阅者</li><li>三个QoS等级, 对网络质量要求比较宽容</li><li>生态成熟, 各个平台都有<br>传输层可以提供有序 &#x2F; 可靠 &#x2F; 双向字节流即可(TCP &#x2F; WebSocket)</li></ul><h1 id="TCP传输协议的不足"><a href="#TCP传输协议的不足" class="headerlink" title="TCP传输协议的不足"></a>TCP传输协议的不足</h1><h2 id="依靠四元组标识连接"><a href="#依靠四元组标识连接" class="headerlink" title="依靠四元组标识连接"></a>依靠四元组标识连接</h2><p>通过四元组区分报文属于哪个连接<br>回家: 基站到WiFi<br>车辆: 基站A到基站B<br>IP发生变更, 如果继续发送数据, 服务器收到后找不到对应的四元组, 直接丢弃该TCP报文. 如果要继续通信, 必须断开原有的四元组, 重新创建连接.</p><h3 id="连接耗时"><a href="#连接耗时" class="headerlink" title="连接耗时"></a>连接耗时</h3><p>TCP握手需要时间, MQTT握手也需要时间.<br>建立MQTT连接, 需要2 RTT (几十 ~ 几百ms)<br><img src="/img/Pasted%20image%2020230827211631.png"><br>为了通信安全还回引入TLS握手, 此时建立连接需要4 RTT<br><img src="/img/Pasted%20image%2020230827211729.png"><br>建立连接的时候, 无法传送数据, 但应用层还在不断地增加数据, 会产生堆积, 产生延迟</p><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><p>QoS &#x3D; 0, 数据直接丢失<br>QoS &#x3D; 1或2, 数据虽然不会丢失, 但是浪费带宽, 且增加了延迟</p><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>连接断开, 重连后, 无法立即获得重连前的传输速率<br><img src="/img/Pasted%20image%2020230827212426.png"><br>加入到新网络中, 还不了解, 就先不发送太多的数据.<br>如果重连后, 需要发送一个大报文, 就会把这个大报文拆成很多个小报文分成多次传输给对端.</p><h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><p>TCP按顺序到达, 同时传输多个消息, 传输路径不同. 后发送的可能先到达, 先到达的数据只能缓存下来.<br><img src="/img/Pasted%20image%2020230827212711.png"><br>有些情况下, 消息并没有先后顺序, 但受限于队头阻塞, 紧急消息无法及时到达</p><h2 id="TCP单流"><a href="#TCP单流" class="headerlink" title="TCP单流"></a>TCP单流</h2><p><img src="/img/Pasted%20image%2020230827212935.png"></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>网络比较差的时候, 不能发送太大的报文, 进一步增加网络拥堵.<br>Reno, CUBIC, BBR<br>很难升级, 定制化变更.</p><h2 id="重传的序列号"><a href="#重传的序列号" class="headerlink" title="重传的序列号"></a>重传的序列号</h2><p>重传的时候是相同的序列号, 无法区分是原始报文, 还是重传报文, 会导致错误的估计RTT.<br><img src="/img/Pasted%20image%2020230827213446.png"><br>RTT偏小, 过于乐观, 加剧拥堵; RTT偏大, 无法有效利用.<br>为了解决这个问题, 增加了10字节的时间戳.<br><img src="/img/Pasted%20image%2020230827213613.png"><br>对带宽敏感的场景并不友好, 关闭时间戳可以减少1%</p><h1 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h1><p>quick udp internet connections. Google 2013年推出<br><img src="/img/Pasted%20image%2020230827213743.png"><br>HTTP&#x2F;3弃用TCP, 选择QUIC<br><img src="/img/Pasted%20image%2020230827221538.png"><br>首次连接, 1 RTT<br>恢复连接, 0 RTT<br>TLS 1.3 无降级风险<br>密码套件 AES256-GCM-SHA256<br>可插拔的拥塞控制算法 - 运行时可以调整<br>无重传歧义<br><img src="/img/Pasted%20image%2020230827221803.png"><br>连接迁移</p><ul><li>避免消息音链接断开而丢失</li><li>NAT重绑定导致端口变化时, 传输速率将不受影响<br><img src="/img/Pasted%20image%2020230827221917.png"><br>多路复用<br>极大改善队头阻塞问题<br><img src="/img/Pasted%20image%2020230827222044.png"><br>紧急数据可以优先发送<br><img src="/img/Pasted%20image%2020230827222119.png"><br>可以设置优先级<br><img src="/img/Pasted%20image%2020230827222205.png"><br>多路复用<br><img src="/img/Pasted%20image%2020230827222341.png"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>QUIC</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 4</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-4/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-4/</url>
    
    <content type="html"><![CDATA[<p>Quality Of Service 服务等级</p><ul><li>QoS 0 最多交付一次</li><li>QoS 1 至少交付一次</li><li>QoS 2 仅交付一次</li></ul><h3 id="为什么QoS-0消息会丢失"><a href="#为什么QoS-0消息会丢失" class="headerlink" title="为什么QoS 0消息会丢失"></a>为什么QoS 0消息会丢失</h3><ol><li>调用API发送消息</li><li>消息被拷贝到内核层的发送缓冲区</li><li>在合适的时机, 消息被发送到网络中</li><li>经过几个路由的跳转后, 消息来到对端的接收缓冲区, 通知上层应用</li><li>消息被读取到应用</li></ol><p>任何一步骤出现问题, 消息都会丢失</p><h3 id="QoS1-通过Puback报文进行重传"><a href="#QoS1-通过Puback报文进行重传" class="headerlink" title="QoS1 通过Puback报文进行重传"></a>QoS1 通过Puback报文进行重传</h3><p><img src="/img/20230427123116.png" alt="20230427123116.png"><br><img src="/img/20230427123136.png" alt="20230427123136.png"><br>消息可能重复 </p><h3 id="为什么QoS1的消息会重复"><a href="#为什么QoS1的消息会重复" class="headerlink" title="为什么QoS1的消息会重复"></a>为什么QoS1的消息会重复</h3><p><img src="/img/20230427123315.png" alt="20230427123315.png"><br>为什么被当做新消息处理</p><ul><li>情况一, 确实是需要重传的消息<br><img src="/img/20230427123358.png" alt="20230427123358.png"></li><li>情况二, Packet ID被重用. 消息确实是一个全新的消息.<br><img src="/img/20230427123511.png" alt="20230427123511.png"></li></ul><p>也可能出现多次重传<br><img src="/img/20230427123605.png" alt="20230427123605.png"></p><h3 id="如何为QoS-1去重"><a href="#如何为QoS-1去重" class="headerlink" title="如何为QoS 1去重"></a>如何为QoS 1去重</h3><p>时间戳 或者 单调递增的计数</p><h3 id="重传不等于乱序"><a href="#重传不等于乱序" class="headerlink" title="重传不等于乱序"></a>重传不等于乱序</h3><p>发送 ABC<br>实际到达 AABC &#x2F; ABABC 但不可能出现BAC</p><h3 id="QoS-2报文"><a href="#QoS-2报文" class="headerlink" title="QoS 2报文"></a>QoS 2报文</h3><ul><li>PUBLISH</li><li>PUBREC<br>publish receive, 表示收到了publish报文; 与PUBACK类似, 但PUBACK用于QoS1</li><li>PUBREL<br>publish release, 表示准备释放本次的QoS 2消息</li><li>PUBCOMP<br>publish complete, 表示本次QoS 2的消息即将完成<br><img src="/img/20230427124231.png" alt="20230427124231.png"></li></ul><h3 id="不同QoS使用场景"><a href="#不同QoS使用场景" class="headerlink" title="不同QoS使用场景"></a>不同QoS使用场景</h3><ul><li>QoS 0<br>优点: 投递效率高<br>缺点: 消息可能丢失<br>适用场景: 传输高频且不那么重要的数据, 例如传感器数据</li><li>QoS 1<br>优点: 保证消息到达<br>缺点: 消息可能重复<br>适用场景: 传输较为重要的数据, 例如下达关键指令, 更新重要的实时性要求的状态等<br>注意事项: 能够处理重复消息, 或者允许重复消息, eg: 扫码签收包裹</li><li>QoS 2<br>优点: 保证消息到达且不会重复<br>缺点: 拥有最高的开销<br>适用场景: 传输重要数据, 并且能够接受QoS2带来的额外开销<br>开销几乎是QoS1的两倍</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 3</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-3/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-3/</url>
    
    <content type="html"><![CDATA[<p>MQTT会话</p><ul><li>什么是会话</li><li>会话能够解决什么问题</li><li>不同生命周期会话的区别</li></ul><p><img src="/img/20230413203229.png" alt="20230413203229.png"><br>对应话题没有订阅者, 就会丢弃已发送的消息<br><img src="/img/20230413203317.png" alt="20230413203317.png"><br>不应该随着连接断开而消失, 应该缓存下来<br><img src="/img/20230413203410.png" alt="20230413203410.png"><br>持久会话:<br><img src="/img/20230413203418.png" alt="20230413203418.png"><br>通常还会和ClientID进行关联<br><img src="/img/20230413203455.png" alt="20230413203455.png"><br>服务端还需要存储:</p><ol><li><p>客户端的订阅信息</p><blockquote><p>重连后不需要重新进行订阅</p></blockquote></li><li><p>已发送, 但还没未完成确认的QoS 1和QoS 2消息</p></li><li><p>等待发送的QoS 0, QoS 1和QoS 2消息<br><img src="/img/20230413203657.png" alt="20230413203657.png"></p><blockquote><p>包含上次连接未发送的消息, 以及在离线时收到的消息</p></blockquote></li><li><p>从客户端收到的, 还没有完全确认的QoS 2消息</p></li><li><p>遗嘱消息和遗嘱延迟间隔</p></li><li><p>会话是否存在<br>客户端需要存储:</p></li><li><p>已经发送给服务端但还未确认的QoS 1, QoS 2消息</p></li><li><p>收到但未确认的QoS 2消息</p></li></ol><p> 两个字段</p><ul><li>Clean Start<br>Clean Start &#x3D; 0<blockquote><p>尝试从已经存在的会话中恢复通信, 如果不存在则创建全新的会话<br><img src="/img/20230413204131.png" alt="20230413204131.png"><br>Clean Start &#x3D; 1<br>即使存在对应的会话, 也会丢弃, 创建全新的会话<br><img src="/img/20230413204218.png" alt="20230413204218.png"></p></blockquote></li><li>Session Expiry Interval<br>指定会话在连接断开后能够保留的最长时间</li></ul><ol><li>val &#x3D; 0<br>会话将在网络连接断开时结束</li><li>val &gt; 0<br>会话将在连接断开的多少秒后过期</li><li>val &#x3D; 0xFFFFFFFF<br>会话永不过期</li></ol><p>要求建立全新的会话<br><img src="/img/20230413204522.png" alt="20230413204522.png"><br>因为网络波动, 导致异常断开连接, 客户端能够保留会话状态<br><img src="/img/20230413204653.png" alt="20230413204653.png"><br>上述都是在MQTT 5.0中的特性, 在MQTT 3.1.1中, 只有Clean Session字段</p><ul><li>Clean Session &#x3D; 0<br>等价于<br>Clean Start &#x3D; 0, 尝试复用已存在的会话;<br>Session Expiry Interval &#x3D; 0xFFFFFFFF, 会话永不过期</li><li>Clean Session &#x3D; 1<br>Clean Start &#x3D; 1, 永远创建全新的会话;<br>Session Expiry Interval &#x3D; 0, 会话的声明周期与网络连接相同</li></ul><p>在MQTT 3.1.1中, 如果要丢弃之前的会话, 并且建立新链接的会话要保持, 必须先用Clean Session &#x3D; 1 丢弃之前的连接, 之后断开连接, 再用Clean Session &#x3D; 0 建立新的保持会话的连接.</p><p>持久会话:</p><ol><li>不希望错过离线期间的消息</li><li>不希望QoS 1和QoS 2消息丢失</li><li>不希望每次连接都要重新建立订阅</li><li>设备定期休眠, 不希望长时间维护连接<br>不需要持久会话:</li><li>只对外发布QoS 0消息, 不会接收任何消息</li><li>只订阅QoS 0消息, 不关心离线期间的消息</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 2</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-2/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-2/</url>
    
    <content type="html"><![CDATA[<h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p><img src="/img/20230323223119.png" alt="20230323223119.png"><br>Topic Name: UTF-8 String<br>QoS: Integer</p><blockquote><p>QoS 0: 消息可能丢失<br>QoS 1: 消息不会丢失但可能重复<br>QoS 2: 消息不会丢失也不会重复</p></blockquote><p>Payload: Binary<br><img src="/img/20230323223329.png" alt="20230323223329.png"><br>保留消息<br><img src="/img/20230323223622.png" alt="20230323223622.png"><br>正常转发的同时, 也会在本地保存副本, 当有新的客户端建立订阅时, 保留消息就会下发给客户端.<br><img src="/img/20230323223744.png" alt="20230323223744.png"></p><h3 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h3><p><img src="/img/20230323223826.png" alt="20230323223826.png"><br>Packet ID<br><img src="/img/20230323223904.png" alt="20230323223904.png"><br>Subscription List</p><blockquote><p>可以一次订阅多个报文<br><img src="/img/20230323223936.png" alt="20230323223936.png"><br>Topic Filter 可以使用主题通配符<br><img src="/img/20230323224020.png" alt="20230323224020.png"><br> <strong>但发布时不能使用主题通配符</strong></p></blockquote><p>发布QoS &#x3D; 2的消息, 但接收端QoS &#x3D; 1, QoS &#x3D; 2的消息将会被降级<br><img src="/img/20230323224214.png" alt="20230323224214.png"><br>如果没有超过最大QoS, 则保持不变<br><img src="/img/20230323224301.png" alt="20230323224301.png"><br>使用相同主题过滤器的新订阅将覆盖旧订阅<br>消息将转发给所有匹配的订阅<br><img src="/img/20230323224425.png" alt="20230323224425.png"><br>订阅回复报文<br><img src="/img/20230323224451.png" alt="20230323224451.png"><br>Reason Codes<br><img src="/img/20230323224515.png" alt="20230323224515.png"><br>Granted Maximum QoS - 可能小于订阅时的Maximum QoS<br><img src="/img/20230323224614.png" alt="20230323224614.png"><br><img src="/img/20230323224628.png" alt="20230323224628.png"></p><h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p><img src="/img/20230323224648.png" alt="20230323224648.png"><br>想要取消订阅的Topic Filter-&gt; 完全的文本匹配 -&gt; 实际订阅的Topic Filter<br><img src="/img/20230323224713.png" alt="20230323224713.png"><br><img src="/img/20230323224804.png" alt="20230323224804.png"></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>类型 UTF-8字符串<br>最大长度 65535字节<br>区分大小写</p><h3 id="主题通配符"><a href="#主题通配符" class="headerlink" title="主题通配符"></a>主题通配符</h3><ul><li>单层通配符<br><img src="/img/20230323224919.png" alt="20230323224919.png"><br><img src="/img/20230323224938.png" alt="20230323224938.png"><br><img src="/img/20230323225024.png" alt="20230323225024.png"><br>一个单层通配符不能匹配多个层级, 但可以通过多个通配符实现<br><img src="/img/20230323225127.png" alt="20230323225127.png"></li><li>多层通配符<br> <code>#</code>可以匹配任意数量个层级<br> <img src="/img/20230323225312.png" alt="20230323225312.png"><br> <img src="/img/20230323225326.png" alt="20230323225326.png"><br> 单层和多层可以搭配使用<br> <img src="/img/20230323225354.png" alt="20230323225354.png"><br>主题名 在发布时不支持主题通配符<br>主题过滤器 在订阅和取消订阅时使用, 支持主题通配符</li><li>特殊主题<br>以<code>$</code>开头的主题, 由服务器使用, 客户端只能订阅, 不能发布.<br><img src="/img/20230323225600.png" alt="20230323225600.png"><br><code>#</code>并不包含<code>$SYS</code>主题, 需要明确指定<code>$SYS/#</code></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>不建议主题以<code>/</code>开头或结尾</li><li>尽量仅使用ASCII字符</li><li>不建议在主题使用空格</li><li>不建议使用<code>#</code>订阅所有主题</li><li>尽量使用简洁的主题</li><li>在主题中包含标识信息</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT入门与进阶 - 1</title>
    <link href="/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-1/"/>
    <url>/2023/09/02/MQTT%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-1/</url>
    
    <content type="html"><![CDATA[<p>MQTT 3.1.1 全解</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>基于发布订阅模型的轻量级的消息传输协议</p><ul><li>发布订阅<br>发布者 - 代理(接收订阅, Broker) - 订阅者</li><li>轻量<br>集成简单 &#x2F; 传输编解码友好</li></ul><p>专为受限设备和低带宽&#x2F;高延迟&#x2F;不可靠网络设计<br>发布订阅 &#x2F; 简单 &#x2F; 轻量 &#x2F; 可靠交付</p><p>MQTT 1.0 IBM内部使用<br>MQTT 3.1 开放给所有人使用<br>MQTT 3.1.1 提交给OASIS进行标准修订<br>MQTT 5.0 2019年发布, MQTT最新版本, 最重要的一次升级</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="通信模式"><a href="#通信模式" class="headerlink" title="通信模式"></a>通信模式</h3><p><img src="/img/20230323121323.png" alt="20230323121323.png"><br>不同与HTTP的请求响应模式, MQTT采用发布订阅模式<br>因此, MQTT可以实现多种通信模式<br><img src="/img/20230323121351.png" alt="20230323121351.png"></p><h3 id="可靠网络"><a href="#可靠网络" class="headerlink" title="可靠网络"></a>可靠网络</h3><p>为了实现消息可靠, 在传输层选择了TCP协议.<br>如果简单的密码验证无法满足需求, 还是建立在TLS之上, 实现消息的加密.<br>如果需要在Web上进行使用, MQTT还可以建立在WebSocket之上</p><h3 id="服务质量-QoS"><a href="#服务质量-QoS" class="headerlink" title="服务质量 QoS"></a>服务质量 QoS</h3><ul><li>QoS 0 - 消息可能丢失 &lt;&#x3D; 1</li><li>QoS 1 - 消息不会丢失, 但可能重复 &gt;&#x3D; 1</li><li>QoS 2- 消息不会丢失, 也不会重复 &#x3D;&#x3D; 1</li></ul><h3 id="心跳保活-KeepAlive"><a href="#心跳保活-KeepAlive" class="headerlink" title="心跳保活 KeepAlive"></a>心跳保活 KeepAlive</h3><p>链接很容易进入假死状态, 为了减少对上层的影响, 需要尽快的感知到连接的异常状态.<br>但TCP的KeepAlive时间过长, 所以MQTT也自定义了心跳机制</p><h3 id="遗嘱-Will-Message"><a href="#遗嘱-Will-Message" class="headerlink" title="遗嘱 Will Message"></a>遗嘱 Will Message</h3><p>通讯双方无法感知到设备是否在线, 为了解决该问题引入遗嘱机制.<br>连接时会设置好遗嘱内容, 一旦代理发现链接异常断开, 就会向订阅了这个遗嘱Topic的客户端发送信息.</p><h3 id="保留消息-Retained-Message"><a href="#保留消息-Retained-Message" class="headerlink" title="保留消息 Retained Message"></a>保留消息 Retained Message</h3><p>如果客户端不在线, 就会错过该消息, 如果不想这样, 就可以设置保留消息, 会让Broker保留向某个主题发送的最后一条消息. 订阅者上线, Broker就会把消息发送给它.</p><h2 id="报文基础"><a href="#报文基础" class="headerlink" title="报文基础"></a>报文基础</h2><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p>连接</p><ul><li>CONNECT<blockquote><p>包含客户端标识&#x2F;用户名&#x2F;密码&#x2F;遗嘱消息</p></blockquote></li><li>CONNACK</li><li>DISCONNECT<br>发布</li><li>PUBLISH<blockquote><p>主题&#x2F;QoS&#x2F;Payload</p></blockquote></li><li>PUBACK</li><li>PUBREC</li><li>PUBREL</li><li>PUBCOMP<br>订阅</li><li>SUBSCRIBE<blockquote><p>主题&#x2F;QoS</p></blockquote></li><li>SUBACK</li><li>UNSUBSCRIBE</li><li>UNSUNACK<br>心跳</li><li>PINGREQ</li><li>PINGRESP</li></ul><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>固定报头Fixed Header - 所有控制报文</p><ul><li>报文类型</li><li>标志</li><li>剩余报文长度<br>可变报头Variable Header - 部分控制报文</li><li>内容视报文类型而定<br>有效载荷Payload - 不分控制论文</li><li>内容视报文类型而定</li></ul><p>Publish报文<br><img src="/img/20230323123059.png" alt="20230323123059.png"><br>心跳报文仅需两个字节<br><img src="/img/20230323123029.png" alt="20230323123029.png"></p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p><img src="/img/20230323123925.png" alt="20230323123925.png"><br>发布者并不知道订阅者是否收到了消息, 为了解决该问题, 需要在业务层面确认消息<br><img src="/img/20230323124104.png" alt="20230323124104.png"></p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>先通过三次握手建立TCP连接 至少2 RTT<br> <img src="/img/20230323124205.png" alt="20230323124205.png"><br> Client ID唯一标识了一个会话, 因此必须全局唯一<br> <img src="/img/20230323124252.png" alt="20230323124252.png"><br> MQTT连接的建立<br> <img src="/img/20230323124447.png" alt="20230323124447.png"><br> 如果client id为0, broker会分配一个全局唯一的cleint id, 通过connack报文返回, 但由于是临时分配的, 后续无法使用持久会话.<br>  <img src="/img/20230323124640.png" alt="20230323124640.png"><br>协议名<br><img src="/img/20230323124718.png" alt="20230323124718.png"><br>协议级别<br><img src="/img/20230323124740.png" alt="20230323124740.png"><br>用户名和密码<br>User Name &amp; Password<br>认证 &amp; 授权<br><img src="/img/20230323124846.png" alt="20230323124846.png"><br><img src="/img/20230323124857.png" alt="20230323124857.png"><br>保活 Keep Alive<br><img src="/img/20230323124958.png" alt="20230323124958.png"><br>1.5倍的Keep Alive Interval没有收到心跳包 则断开连接<br><img src="/img/20230323125033.png" alt="20230323125033.png"><br><img src="/img/20230323125100.png" alt="20230323125100.png"><br>最大允许的保活间隔 18H12M15S</p><p>断开连接 DISCONNECT<br>客户端发起, 因此不会发布遗嘱信息<br><img src="/img/20230323125207.png" alt="20230323125207.png"><br>超时也会断开连接<br><img src="/img/20230323125237.png" alt="20230323125237.png"><br>Broker主动断开<br><img src="/img/20230323125332.png" alt="20230323125332.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>IoT</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化与自动内存管理</title>
    <link href="/2023/09/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/09/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="性能优化是什么？"><a href="#性能优化是什么？" class="headerlink" title="性能优化是什么？"></a>性能优化是什么？</h2><ul><li>提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力</li></ul><p> 为什么要做性能优化？</p><ul><li>用户体验：带来用户体验的提升 – 让刷抖音更丝滑，让双十一购物不再卡顿</li><li>资源高效利用：降低成本，提高效率 – 很小的优化乘以海量机器会是显著的性能提升和成本节约</li></ul><h3 id="性能优化的层面"><a href="#性能优化的层面" class="headerlink" title="性能优化的层面"></a>性能优化的层面</h3><ul><li>业务层优化<br>针对特定场景，具体问题，具体分析<br>容易获得较大性能收益</li><li>语言运行时优化<br>解决更通用的性能问题<br>考虑更多场景<br>Tradeoffs</li><li>数据驱动<br>自动化性能分析工具 – pprof<br>依靠数据而非猜测<br>首先优化最大瓶颈</li></ul><h3 id="性能优化与软件质量"><a href="#性能优化与软件质量" class="headerlink" title="性能优化与软件质量"></a>性能优化与软件质量</h3><ul><li>软件质量至关重要</li><li>在保证接口稳定的前提下改进具体实现</li><li>测试用例：覆盖尽可能多的场景，方便回归</li><li>文档：做了什么，没做什么，能达到怎样的效果</li><li>隔离：通过选项控制是香开启优化</li><li>可观测：必要的日志输出<br><img src="/img/20230515193448.png" alt="20230515193448.png"></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>性能优化的基本问题</li><li>性能优化的两个层面</li><li>性能优化的可维护性</li></ul><h2 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h2><ul><li>动态内存<ul><li>程序在运行时根据需求动态分配的内存：malloc()</li></ul></li><li>自动内存管理(垃圾回收)：由程序语言的运行时系统管理动态内存<ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的<strong>正确性</strong>和<strong>安全性</strong>：double-free problem,use-after–free problem</li></ul></li><li>三个任务<ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul></li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Mutator: 业务线程, 分配新对象, 修改对象指向关系<br>Collector: GC线程, 找到存活对象, 回收死亡对象的内存空间<br>Serial GC: 只有一个collector<br>Parallel GC: 支持多个collectors 同时回收的GC算法<br><img src="/img/20230515194758.png" alt="20230515194758.png"><br>Concurrent GC: mutator(s)和collector(s)可以<strong>同时执行</strong><br>    - <strong>Collectors必须感知对象指向关系的改变!</strong><br><img src="/img/20230515194403.png" alt="20230515194403.png"><br>a. 会有暂停 b.只有一个collector<br><img src="/img/20230515194411.png" alt="20230515194411.png"><br>a. 会有暂停 b.有多个collector<br><img src="/img/20230515194425.png" alt="20230515194425.png"><br>a. 不需要暂停 b.有多个collector</p><p>评价GC</p><ul><li>安全性(Safety): 不能回收存活的对象 <strong>基本要求</strong></li><li>吞吐率(Throughput): 1 - (GC时间 &#x2F; 程序执行时间) <strong>花在GC上的时间</strong></li><li>暂停时间(Pause Time): stop the word(STW) <strong>业务是否感知</strong></li><li>内存开销(Space Overhead) GC原数据开销</li></ul><h3 id="追踪垃圾回收-Tracing-garbage-collection"><a href="#追踪垃圾回收-Tracing-garbage-collection" class="headerlink" title="追踪垃圾回收(Tracing garbage collection)"></a>追踪垃圾回收(Tracing garbage collection)</h3><p>对象被回收的条件</p><ol><li>指针指向关系不可达的的对象<blockquote><p>静态变量, 全局变量, 常量, 线程栈等</p></blockquote></li><li>标记: 找到可达对象<blockquote><p>求指针指向关系的传递闭包: 从跟对象出发, 找到所有可达对象 </p></blockquote></li><li>清理: 所有不可达对象<blockquote><p>不同的清理策略(根据对象的生命周期, 使用不同的标记和清理策略)</p><ul><li>将存活对象复制到另外的内存空间(Copying GC)<br>  <img src="/img/20230515200449.png" alt="20230515200449.png"></li><li>将死亡对象的内存标记为”可分配”(Mark-sweep GC)<br>  使用free list管理空闲内存<br>  <img src="/img/20230515200423.png" alt="20230515200423.png"></li><li>移动并整理存活对象(Mark-compack GC)<br>  原地整理对象<br>  <img src="/img/20230515200409.png" alt="20230515200409.png"><br><img src="/img/20230515200006.png" alt="20230515200006.png"></li></ul></blockquote></li></ol><h3 id="分代GC-Generational-GC"><a href="#分代GC-Generational-GC" class="headerlink" title="分代GC(Generational GC)"></a>分代GC(Generational GC)</h3><ul><li>分代假说(Generational hypothesis): most objects die young</li><li>很多对象在分配出来后很快就不再使用了</li><li>每个对象都有年龄: 经历过GC的次数</li><li>目的: 对年轻的和老年的对象, 制定不同的GC策略, 降低整体内存管理的开销</li><li>不同年龄的对象处于heap的不同区域<br><img src="/img/20230515201220.png" alt="20230515201220.png"></li><li>年轻代(Young generation)<ul><li>常规的对象分配</li><li>由于存活对象很少, 可以采用copying collection</li><li>GC吞吐率很高</li></ul></li><li>老年代(Old Generation)<ul><li>对象趋向于一直或者, 反复复制开销比较大</li><li>可以采用 mark-sweep collection</li></ul></li></ul><h3 id="引用计数-Reference-counting"><a href="#引用计数-Reference-counting" class="headerlink" title="引用计数(Reference counting)"></a>引用计数(Reference counting)</h3><ul><li>每个对象都有一个与之关联的引用数目</li><li>对象存活的条件: 当且仅当引用数大于0</li><li>优点<ul><li>内存管理的操作被平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节: C++智能指针(smart pointer)</li></ul></li><li>缺点<ul><li>维护引用计数的开销较大: 通过原子操作保证对引用计数操作的原子性和可见性</li><li>无法回收环形数据结构 - weak reference</li><li>内存开销: 每个对象都引入的额外内存空间存储引用数目</li><li>回收内存时依然可能引发暂停</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go中的单例模式</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用场景:</p><ul><li>只允许存在一个实例的类 - 全局统一的监控统计模块</li><li>实例化很耗费资源的类 - 连接池, 客户端登</li><li>入参繁杂的系统模块组件 - controller, service, dao等</li></ul><h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><p>从一开始就完成单例的初始化工作;<br>不够智能, 如果一直不被用到, 但初始化了, 就造成了浪费.</p><p>步骤</p><ul><li>单例类和构造方法不可导出</li><li>代码启动之初就初始化全局单一的实例</li><li>暴露一个可导出的单例获取方法GetXXX()</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-comment">// singleton是需要被单例模式保护的类型</span><br><span class="hljs-comment">// 首字母小写, 不可导出, 避免被外界直接获取</span><br><span class="hljs-keyword">var</span> s *singleton<br><br><span class="hljs-comment">// 完成singleton的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>s = newSingleton()<br>&#125;<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Working...&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 创建singleton</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 外部获取单一实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码导出了私有的类</p><ul><li>不符合规范, 私有还要导出?</li><li>只能拿到实例, 执行实例的方法, 无法传参, 比较鸡肋<br>以下是更为规范的写法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-comment">// singleton是需要被单例模式保护的类型</span><br><span class="hljs-comment">// 首字母小写, 不可导出, 避免被外界直接获取</span><br><span class="hljs-keyword">var</span> s *singleton<br><br><span class="hljs-comment">// 完成singleton的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>s = newSingleton()<br>&#125;<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Working...&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 创建singleton</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// singleton 实现了Instance接口</span><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br>Work()<br>&#125;<br><br><span class="hljs-comment">// 外部获取单一实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *Instance &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// 外部获取单一实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p>需要被使用了, 才会执行单例的初始化;<br>只有用的时候才可能发现问题.</p><p>步骤</p><ul><li>单例类和构造方法不可导出</li><li>代码启动之初就初始化全局单一的实例</li><li>暴露一个可导出的单例获取方法GetXXX()</li><li>在这个获取方法被调用时, 会判断单例是否被初始化过, 倘若没有, 则在此时才完成初始化工作</li></ul><h3 id="并发不安全"><a href="#并发不安全" class="headerlink" title="并发不安全"></a>并发不安全</h3><p>并发访问GetInstance方法, 导致实例可能被创建多次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">var</span> s *singleton<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br>    <span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() &#123;<br>&#125;<br><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br>    Work()<br>&#125;<br><br><span class="hljs-comment">// 并发访问的时候, 单例可能创建多次</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>        s = newSingleton()<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一加锁"><a href="#统一加锁" class="headerlink" title="统一加锁"></a>统一加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>s *singleton<br>mu sync.Mutex<br>)<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSingleton</span><span class="hljs-params">()</span></span> *singleton &#123;<br><span class="hljs-keyword">return</span> &amp;singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *singleton)</span></span> Work() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Working...&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br>Work()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br>mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br><span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>s = newSingleton()<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是否完成初始化, 都需要先获取锁, 造成了浪费.</p><h3 id="未初始化再加锁"><a href="#未初始化再加锁" class="headerlink" title="未初始化再加锁"></a>未初始化再加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br><span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>mu.Lock()<br>defere mu.Unlock()<br>s = newSingleton()<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>但存在bad case.  多个协程在未初始化的时候同时到达, 但只有一个获取了锁, 进行了初始化, 之后释放. 其它等待锁的协程获得了锁, 再次进行初始化. 导致类被实例化多次</p><h3 id="二次检查"><a href="#二次检查" class="headerlink" title="二次检查"></a>二次检查</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br><span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br><span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>s = newSingleton()<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用Golang的sync-Once"><a href="#使用Golang的sync-Once" class="headerlink" title="使用Golang的sync.Once"></a>使用Golang的sync.Once</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> Instance &#123;<br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>s = newSingleton()<br>&#125;)<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Golang单例工具-sync-Once源码"><a href="#Golang单例工具-sync-Once源码" class="headerlink" title="Golang单例工具 sync.Once源码"></a>Golang单例工具 sync.Once源码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sync<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 通过一个整型变量标识，once 保护的函数是否已经被执行过</span><br>    done <span class="hljs-type">uint32</span><br>    <span class="hljs-comment">// 一把锁，在并发场景下保护临界资源 done 字段只能串行访问</span><br>    m    Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>    <span class="hljs-comment">// 锁外的第一次 check，读取 Once.done 的值</span><br>    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>        o.doSlow(f)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>    <span class="hljs-comment">// 加锁</span><br>    o.m.Lock()<br>    <span class="hljs-keyword">defer</span> o.m.Unlock()<br>    <span class="hljs-comment">// double check</span><br>    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 任务执行完成后，将 Once.done 标识为 1</span><br>        <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 保证全局唯一一次执行用户注入的任务</span><br>        f()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁</title>
    <link href="/2023/09/02/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2023/09/02/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<ul><li>主动轮询型: Redis &#x2F; MySQL<br>类似单机锁的主动轮询 + cas乐观锁模型, 取锁房会持续对分布式锁发出尝试获取操作, 如果锁已经被占用则会不断发起重试, 直到获取锁成功为止</li></ul><p>优势: 无需阻塞操作, 短期来看操作比较轻<br>劣势: 长时间抢不到锁, 会浪费CPU时间片<br>适合场景: 并发竞争强度低的场景</p><ul><li>watch回调型: etcd &#x2F; zookeeper<br>在取锁方发现锁已经他人占用时, 会创建watcher监听订阅锁的释放时间, 随后不再主动发起获取锁的尝试; 当锁被释放后, 取锁方能通过之前创建的watcher感知到这一变化, 然后再重新发起获取锁的尝试动作</li></ul><p>优势: 精准打击, 不浪费CPU时间片<br>劣势: 需要挂起协程, 进行上下文切换, 操作比较重<br>适合场景: 并发竞争激烈的场景</p><p>在分布式场景下, 轮询式会存在大量网络IO, 代价比较高.</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>核心性质</p><ol><li>独占: 统一时刻只能被一个取锁方占有</li><li>健壮: 不能产生死锁, 某有持锁者因宕机不能释放锁, 锁也应该被正常传承下去, 被其他适用方使用</li><li>对称: 加锁和解锁必须是同一身份, 不允许非法释放他人持有的分布式锁</li><li>高可用: 基础组件少量节点出现故障时, 不能影响到分布式锁的稳定性</li></ol><h2 id="主动轮询型"><a href="#主动轮询型" class="headerlink" title="主动轮询型"></a>主动轮询型</h2><ul><li>加锁<br>SETNX(set only if not exist, deprecated)<br>将value设置为持有者标识</li><li>解锁<br>对称性:  先检查锁标识, 是持有者才可以解锁. 通过Lua脚本实现<ul><li>检查释放锁动作执行者的身份</li><li>身份合法才可以进行解锁</li></ul></li></ul><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>Redis设置一个过期时间, 进行兜底.<br>但, 可能存在操作时间长, 但锁被提前自动释放, 导致出现一锁多方持有.</p><h2 id="Redis-AP流派"><a href="#Redis-AP流派" class="headerlink" title="Redis - AP流派"></a>Redis - AP流派</h2><p>在分区容错的情况下, 着重保护可用性. 会存在若一致问题.<br>Redis肯定不是单点 -&gt; 主从复制;<br>可能存在问题</p><ol><li>master节点加锁成功, 完成数据写入;</li><li>master宕机, 数据还没有同步给slave; </li><li>其它请求者也可以获得锁<br>此问题有解决方案: Redis红锁(redis distribution lock)</li></ol><h2 id="watch回调型"><a href="#watch回调型" class="headerlink" title="watch回调型"></a>watch回调型</h2><p>取锁失败后, 不会持续轮询, 而是会watch监听锁的删除事件</p><p>不仅需要支持对数据的存和去重, 还需要利用其中的watch监听回调功能进行锁释放事件的订阅感知<br>支持的常用组件: etcd, zookeeper</p><h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>适用于共享配置 &#x2F; 服务发现的分布式kv存储组件, 底层基于分布式共识算法Raft协议, 保证了存储服务的强一致性和高可用性.<br>也可提供持续续约, 秩序取锁的统筹协调能力</p><h4 id="死锁问题-租约-续约"><a href="#死锁问题-租约-续约" class="headerlink" title="死锁问题 - 租约 &#x2F; 续约"></a>死锁问题 - 租约 &#x2F; 续约</h4><p>租约机制,  具有时效性的协议, 一旦达到组约上规定的截止时间, 租约失去效力. 同时, etcd也提供了续约机制(keepAlive), 用户可以通过续约操作来延迟租约过期时间. 与Redisson中的watch dog很像.</p><ul><li>用户现申请一个租约, 设定好租约截止时间(可以短一些, 乐观一些)</li><li>一步启动一个续约协程, 负责业务逻辑处理完成前, 按照一定的时间节奏持续进行续约操作</li><li>执行取锁动作, 将对应于锁的kv数据和租约进行关联绑定, 使得锁数据和租约拥有相同的过期时间属性</li></ul><h4 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h4><p>如果锁的竞争比较激烈, 锁的释放事件被多个取锁方监听, 一旦锁真的被释放, 所有取锁方都会尝试加锁, 但只有一个可以成功, 因此会存在大量无意义的性能损耗.</p><p>etcd中通过prefix机制以及版本revision机制</p><ul><li>对于一把分布式锁, 锁记录数据的key拥有共同的前缀, 作为锁的标识</li><li>每个取锁方都会以锁前缀prefix拼接上自身的身份标识(id), 生成完整的lock key, 因此各个取锁方完整的lock key都不相同, 理论上所有的取锁方都能成功把所记录插入etcd中</li><li>每个取锁方插入锁记录时, 会获得自身lock key处在锁前缀prefix返回下唯一且递增的版本号revision</li><li>取锁方插入加锁记录并不意味着成功, 而是需要在插入数据后, 查询一个锁前缀prefix下的记录列表, 判定自身lock key对应的revision是不是其中最小的, 如果是, 才加锁成功</li><li>如果锁被其它人占用, 取锁方会watch监听revision小于自己但最接近自己的那个lock key的删除事件.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中Context的实现原理</title>
    <link href="/2023/09/02/Go%E4%B8%ADContext%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/02/Go%E4%B8%ADContext%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>主要用在异步场景中用于实现并发协调以及对Goroutine的生命周期控制, 兼有一定的数据存储能力.</p><h1 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h1><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">// 返回ctx过期的时间</span><br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 返回用以标识ctx是否结束的</span><br>Err() <span class="hljs-type">error</span> <span class="hljs-comment">// 返回ctx的错误</span><br>Value(key any) any <span class="hljs-comment">// 返回ctx存放的对应于key的value</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标准error"><a href="#标准error" class="headerlink" title="标准error"></a>标准error</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Canceled = errors.New(<span class="hljs-string">&quot;context canceled&quot;</span>) <span class="hljs-comment">// context被取消时报此错误</span><br><span class="hljs-keyword">var</span> DealineExceeded <span class="hljs-type">error</span> = deadlineExceededError&#123;&#125; <span class="hljs-comment">// context超时时报此错误</span><br><span class="hljs-keyword">type</span> deadlineExceededError <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;context deadline&quot;</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span></span> Timeout() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span></span> Temporary() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br></code></pre></td></tr></table></figure><h1 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h1><h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>根Context都是空Context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-type">int</span> <span class="hljs-comment">// 空context, 但本质上是一个整形</span><br><br><span class="hljs-comment">// 返回一个公元元年时间以及 false 的 flag，标识当前 context 不存在过期时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 返回一个 nil 值，用户无论往 nil 中写入或者读取数据，均会陷入阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// 读取信号 永远阻塞</span><br>&#125;<br><br><span class="hljs-comment">// 返回的错误永远为 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 返回的 value 同样永远为 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Value(key any) any &#123;<br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context-Background-与-context-TODO"><a href="#context-Background-与-context-TODO" class="headerlink" title="context.Background() 与 context.TODO()"></a>context.Background() 与 context.TODO()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    background = <span class="hljs-built_in">new</span>(emptyCtx)<br>    todo       = <span class="hljs-built_in">new</span>(emptyCtx)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span></span> Context &#123;<br>    <span class="hljs-keyword">return</span> background<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span> Context &#123;<br>    <span class="hljs-keyword">return</span> todo<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h1><p>一个父Ctx会有多个子Ctx, 子Ctx在父Ctx上添加能力<br>治理: 生命周期终止传递的单向性, 某一Context终止, 从上向下传递终止信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>    Context <span class="hljs-comment">// 内置Context, 指向父Context. cancelCtx必然是某个context的子context</span><br><br>    mu       sync.Mutex            <span class="hljs-comment">// protects following fields</span><br>    done     atomic.Value          <span class="hljs-comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span><br>    children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// set to nil by the first cancel call</span><br>    err      <span class="hljs-type">error</span>                 <span class="hljs-comment">// set to non-nil by the first cancel call</span><br>&#125;<br><br><span class="hljs-keyword">type</span> canceler <span class="hljs-keyword">interface</span> &#123;<br>    cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>)<br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现Context接口, 需要实现Deadline, Done, Err 和 Value方法</p><h2 id="Deadline方法"><a href="#Deadline方法" class="headerlink" title="Deadline方法"></a>Deadline方法</h2><p>cancelCtx没有实现该方法, 仅仅是内置了一个带有Deadline方法的Context Interface, 因此如果直接调用会报错</p><h2 id="Done方法"><a href="#Done方法" class="headerlink" title="Done方法"></a>Done方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>    d := c.done.Load()<br>    <span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br>    d = c.done.Load()<br>    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>        d = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>        c.done.Store(d)<br>    &#125;<br>    <span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>基于atomic包, 读取cancelCtx中的chan, 如果已经存在, 则直接返回</li><li>加锁后, 再次检查chan是否存在, 若存在则返回; (double check)</li><li>初始化chan存储到actomic.Value当中, 并返回. (懒加载机制)</li></ul><h2 id="Err方法"><a href="#Err方法" class="headerlink" title="Err方法"></a>Err方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br>    c.mu.Lock()<br>    err := c.err<br>    c.mu.Unlock()<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加锁</li><li>读取cancelCtx.err;</li><li>解锁</li><li>返回结果</li></ul><h2 id="Value方法"><a href="#Value方法" class="headerlink" title="Value方法"></a>Value方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Value(key any) any &#123;<br>    <span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br>        <span class="hljs-keyword">return</span> c<br>    &#125;<br>    <span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果key等于&amp;cancelCtxKey特定值, 则返回cancelCtx自身的指针</li><li>否则遵循valueCtx的思路取值返回</li></ul><h2 id="context-WithCancel"><a href="#context-WithCancel" class="headerlink" title="context.WithCancel()"></a>context.WithCancel()</h2><p>在父context的基础上添加取消</p><h3 id="context-WithCancel-1"><a href="#context-WithCancel-1" class="headerlink" title="context.WithCancel()"></a>context.WithCancel()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;<br>    <span class="hljs-comment">// 校验父 context 非空；</span><br>    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 注入父 context 构造好一个新的 cancelCtx</span><br>    c := newCancelCtx(parent)  <br>    <span class="hljs-comment">// 在 propagateCancel 方法内启动一个守护协程，以保证父 context 终止时，该 cancelCtx 也会被终止；</span><br>    propagateCancel(parent, &amp;c)<br>    <span class="hljs-comment">// 将 cancelCtx 返回，连带返回一个用以终止该 cancelCtx 的闭包函数.</span><br>    <span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="newCancelCtx"><a href="#newCancelCtx" class="headerlink" title="newCancelCtx"></a>newCancelCtx</h3><p>注入父 context 后，返回一个新的 cancelCtx.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCancelCtx</span><span class="hljs-params">(parent Context)</span></span> cancelCtx &#123;<br>    <span class="hljs-keyword">return</span> cancelCtx&#123;Context: parent&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="propagateCancel"><a href="#propagateCancel" class="headerlink" title="propagateCancel"></a>propagateCancel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br><span class="hljs-comment">// 父永远不会取消,  就不用实现传播特性</span><br>    done := parent.Done()<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span><br>    &#125;<br><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-done:<br>        <span class="hljs-comment">// parent is already canceled</span><br>        child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>    &#125;<br><span class="hljs-comment">// 如果父是cancelCtx, 只需要将自己添加到父亲的children中</span><br>    <span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>        p.mu.Lock()<br>        <span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// parent has already been canceled</span><br>            child.cancel(<span class="hljs-literal">false</span>, p.err)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>                p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>            &#125;<br>            p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        &#125;<br>        p.mu.Unlock()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果不是cancelCtx </span><br>        atomic.AddInt32(&amp;goroutines, +<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 守护协程</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-parent.Done(): <span class="hljs-comment">// 父亲是否终止</span><br>                child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br>            <span class="hljs-keyword">case</span> &lt;-child.Done(): <span class="hljs-comment">// 孩子终止, 无需做什么</span><br>            &#125;<br>        &#125;()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>校验parent是否为cancelCtx类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span></span> (*cancelCtx, <span class="hljs-type">bool</span>) &#123;<br>    done := parent.Done()<br>    <span class="hljs-keyword">if</span> done == closedchan || done == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    pdone, _ := p.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">if</span> pdone != done &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cancelCtx-cancel"><a href="#cancelCtx-cancel" class="headerlink" title="cancelCtx.cancel"></a>cancelCtx.cancel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>        c.mu.Unlock()<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span><br>    &#125;<br>    c.err = err<br>    <span class="hljs-comment">// 处理 cancelCtx 的 channel</span><br>    <span class="hljs-comment">// 若 channel 此前未初始化，则直接注入一个 closedChan，否则关闭该 channel</span><br>    d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>        c.done.Store(closedchan)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">close</span>(d)<br>    &#125;<br>    <span class="hljs-comment">// 遍历当前 cancelCtx 的 children set，依次将 children context 都进行 cancel</span><br>    <span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span><br>        child.cancel(<span class="hljs-literal">false</span>, err)<br>    &#125;<br>    c.children = <span class="hljs-literal">nil</span><br>    c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> removeFromParent &#123;<br>        removeChild(c.Context, c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将cancelCt从parent的children set中移除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeChild</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>    <span class="hljs-comment">// 如果 parent 不是 cancelCtx，直接返回（因为只有 cancelCtx 才有 children set）</span><br>    p, ok := parentCancelCtx(parent)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    p.mu.Lock()<br>    <span class="hljs-keyword">if</span> p.children != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">delete</span>(p.children, child)<br>    &#125;<br>    p.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>    cancelCtx<br>    timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br>    deadline time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>timerCtx 在 cancelCtx 基础上又做了一层封装，除了继承 cancelCtx 的能力之外，新增了一个 time.Timer 用于定时终止 context；另外新增了一个 deadline 字段用于字段 timerCtx 的过期时间.</p><h2 id="timerCtx-Dealine"><a href="#timerCtx-Dealine" class="headerlink" title="timerCtx.Dealine()"></a>timerCtx.Dealine()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">return</span> c.deadline, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="timerCtx-cancel"><a href="#timerCtx-cancel" class="headerlink" title="timerCtx.cancel"></a>timerCtx.cancel</h2><p>重写了父类cancelCtx的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br>    c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<br>    <span class="hljs-keyword">if</span> removeFromParent &#123;<br>        removeChild(c.cancelCtx.Context, c)<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>        c.timer.Stop()<br>        c.timer = <span class="hljs-literal">nil</span><br>    &#125;<br>    c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context-WithTimeout-context-WithDeadline"><a href="#context-WithTimeout-context-WithDeadline" class="headerlink" title="context.WithTimeout &amp; context.WithDeadline"></a>context.WithTimeout &amp; context.WithDeadline</h2><p>context.WithTimeout 方法用于构造一个 timerCtx，本质上会调用 context.WithDeadline 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;<br>    <span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;<br>    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br>        <span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br>        <span class="hljs-keyword">return</span> WithCancel(parent)<br>    &#125;<br>    c := &amp;timerCtx&#123;<br>        cancelCtx: newCancelCtx(parent),<br>        deadline:  d,<br>    &#125;<br>    propagateCancel(parent, c)<br>    dur := time.Until(d)<br>    <span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>        c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><br>        <span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br>    <span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>        c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>    Context <span class="hljs-comment">// 继承了一个 parent context</span><br>    key, val any <span class="hljs-comment">// 一个 valueCtx 中仅有一组 kv 对</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="valueCtx-Value"><a href="#valueCtx-Value" class="headerlink" title="valueCtx.Value()"></a>valueCtx.Value()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-comment">// 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value</span><br>    <span class="hljs-keyword">if</span> c.key == key &#123;<br>        <span class="hljs-keyword">return</span> c.val<br>    &#125;<br>    <span class="hljs-comment">// 假如不等，则从 parent context 中依次向上寻找.</span><br>    <span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(c Context, key any)</span></span> any &#123;<br><span class="hljs-comment">// 启动一个 for 循环，由下而上，由子及父，依次对 key 进行匹配</span><br>    <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 其中 cancelCtx、timerCtx、emptyCtx 类型会有特殊的处理方式；</span><br>        <span class="hljs-keyword">switch</span> ctx := c.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> *valueCtx:<br>            <span class="hljs-keyword">if</span> key == ctx.key &#123;<br>                <span class="hljs-keyword">return</span> ctx.val<br>            &#125;<br>            c = ctx.Context<br>        <span class="hljs-keyword">case</span> *cancelCtx:<br>            <span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br>                <span class="hljs-keyword">return</span> c<br>            &#125;<br>            c = ctx.Context<br>        <span class="hljs-keyword">case</span> *timerCtx:<br>            <span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br>                <span class="hljs-keyword">return</span> &amp;ctx.cancelCtx<br>            &#125;<br>            c = ctx.Context<br>        <span class="hljs-keyword">case</span> *emptyCtx:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> c.Value(key)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context-WithValue"><a href="#context-WithValue" class="headerlink" title="context.WithValue()"></a>context.WithValue()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val any)</span></span> Context &#123;<br>    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成本比较高, 每放入一个kv, 就要新建一个context</p><ul><li>一个 valueCtx 实例只能存一个 kv 对，因此 n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v. 由此得知，valueContext 的定位类似于请求头，只适合存放少量作用域较大的全局 meta 数据.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中可能的面试题</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E5%8F%AF%E8%83%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E5%8F%AF%E8%83%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="交替打印"><a href="#交替打印" class="headerlink" title="交替打印"></a>交替打印</h2><blockquote><p>使用两个Goroutine交替打印序列, 一个Goroutine打印数字, 另一个Goroutine打印字母<br>‘12AB34CD…..2526YZ’</p></blockquote><p>三个channel, 但WaitGroup有点问题…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>numChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>charChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>blockChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;aa&quot;</span>)<br>&#125;()<br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-numChan:<br>fmt.Print(i)<br>i++<br>fmt.Print(i)<br>i++<br>charChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-charChan:<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, i)<br>i++<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, i)<br>i++<br><span class="hljs-keyword">if</span> i &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &#123;<br>numChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>blockChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;()<br><br>numChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&lt;-blockChan<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串中的所有字符-是否全都不同"><a href="#字符串中的所有字符-是否全都不同" class="headerlink" title="字符串中的所有字符 是否全都不同"></a>字符串中的所有字符 是否全都不同</h2><blockquote><p>确定一个字符串所有字符是否全都不同, 不能使用额外存储结构, 给定一个string, 返回bool, 都是ascii码</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;ABCA&quot;</span><br>fmt.Println(IsRepeat(s))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsRepeat</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">for</span> ii, vv := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> vv == v &amp;&amp; ii != i &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="解析时-struct的字段名要大写"><a href="#解析时-struct的字段名要大写" class="headerlink" title="解析时, struct的字段名要大写"></a>解析时, struct的字段名要大写</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span> <span class="hljs-comment">// 字段名要大写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>js := <span class="hljs-string">`&#123;&quot;name&quot;: &quot;bing&quot;&#125;`</span><br>p := &amp;Person&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(js), &amp;p)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, p)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高并发下的锁与map的读写"><a href="#高并发下的锁与map的读写" class="headerlink" title="高并发下的锁与map的读写"></a>高并发下的锁与map的读写</h2><blockquote><p>在一个高并发的Web服务器中, 限制IP的频繁访问, 现模拟100个IP同时访问并发服务器, 每个IP要重复访问1000次, 每个IP三分钟之内只能访问一次. </p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Ban <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 需要加锁访问map</span><br>visitIPs <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBan</span><span class="hljs-params">()</span></span> *Ban &#123;<br><span class="hljs-keyword">return</span> &amp;Ban&#123;visitIPs: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Ban)</span></span> visit(ip <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> _, ok := o.visitIPs[ip]; ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>o.visitIPs[ip] = time.Now()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>success := <span class="hljs-number">0</span> <span class="hljs-comment">// 也是并发对象</span><br>ban := NewBan()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ip := fmt.Sprintf(<span class="hljs-string">&quot;192.168.1.%d&quot;</span>, j)<br><span class="hljs-keyword">if</span> !ban.visit(ip) &#123;<br>success++<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;success&quot;</span>, success)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会报错, 因为map不能并发读写. 需要加锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Ban <span class="hljs-keyword">struct</span> &#123;<br>visitIPs <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br>sync.RWMutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBan</span><span class="hljs-params">()</span></span> *Ban &#123;<br><span class="hljs-keyword">return</span> &amp;Ban&#123;visitIPs: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Ban)</span></span> visit(ip <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>o.Lock()<br><span class="hljs-keyword">defer</span> o.Unlock()<br><span class="hljs-keyword">if</span> _, ok := o.visitIPs[ip]; ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>o.visitIPs[ip] = time.Now()<br><span class="hljs-keyword">go</span> o.delIP(ip)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Ban)</span></span> delIP(ip <span class="hljs-type">string</span>) &#123;<br>timer := time.NewTicker(time.Minute * <span class="hljs-number">3</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-timer.C:<br>o.Lock()<br><span class="hljs-keyword">defer</span> o.Unlock()<br><span class="hljs-built_in">delete</span>(o.visitIPs, ip)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>success := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)<br>ban := NewBan()<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>ip := fmt.Sprintf(<span class="hljs-string">&quot;192.168.1.%d&quot;</span>, j)<br><span class="hljs-keyword">if</span> !ban.visit(ip) &#123;<br>atomic.AddInt32(&amp;success, <span class="hljs-number">1</span>)<br>&#125;<br>&#125;(j)<br>&#125;<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;success&quot;</span>, success)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交替打印dog-cat-fish"><a href="#交替打印dog-cat-fish" class="headerlink" title="交替打印dog cat fish"></a>交替打印dog cat fish</h2><p>有三个函数，分别打印”cat”, “fish”,”dog”要求每一个函数都用一个goroutine，按照顺序打印100次。<br>此题目考察channel，<strong>用三个无缓冲channel</strong>，如果一个channel收到信号则通知下一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>chDog := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>chCat := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>chFish := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(<span class="hljs-number">300</span>)<br><br>dog := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-chDog<br>fmt.Println(<span class="hljs-string">&quot;dog&quot;</span>)<br>wg.Done()<br>chCat &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br>cat := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-chCat<br>fmt.Println(<span class="hljs-string">&quot;cat&quot;</span>)<br>wg.Done()<br>chFish &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br>fish := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-chFish<br>fmt.Println(<span class="hljs-string">&quot;fish&quot;</span>)<br>wg.Done()<br>chDog &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> cat()<br><span class="hljs-keyword">go</span> dog()<br><span class="hljs-keyword">go</span> fish()<br>&#125;<br>chCat &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两个协程交替打印10个字母和数字"><a href="#两个协程交替打印10个字母和数字" class="headerlink" title="两个协程交替打印10个字母和数字"></a>两个协程交替打印10个字母和数字</h2><p>思路：采用channel来协调goroutine之间顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>chChar := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>chNum := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>wg := sync.WaitGroup&#123;&#125;<br><br>wg.Add(<span class="hljs-number">2</span>)<br><br>printNum := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>&lt;-chNum<br>fmt.Println(i)<br>chChar &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br><br>printChar := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;a&#x27;</span>; i &lt; <span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">10</span>; i++ &#123;<br>&lt;-chChar<br>fmt.Printf(<span class="hljs-string">&quot;%c\n&quot;</span>, i)<br>chNum &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">go</span> printNum()<br><span class="hljs-keyword">go</span> printChar()<br>chNum &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现阻塞map"><a href="#实现阻塞map" class="headerlink" title="实现阻塞map"></a>实现阻塞map</h2><p>实现一个map</p><ol><li>面向高并发: map本身并不支持高并发, 可能会抛出fatal error杀掉进程, 无法recover.</li><li>只存在插入和查询操作 O(1)</li><li>查询时, 若key存在返回val; 若key不存在, 阻塞直到key, val对被放入后, 获取val返回; 等待指定时长仍未放入, 返回超市错误</li><li>写出真实代码, 不能有死锁或者pannic风险.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyChan <span class="hljs-keyword">struct</span> &#123;<br>sync.Once<br>ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyChan)</span></span> Close &#123;<br>m.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyChan</span><span class="hljs-params">()</span></span> *MyChan &#123;<br><span class="hljs-keyword">return</span> &amp;MyChan&#123;<br>ch : <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> MyConcurrentMap <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex<br>mp <span class="hljs-keyword">map</span> [<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">// keyToCh map[int]chan struct&#123;&#125; // key是int, value是 chan struct&#123;&#125;</span><br>keyToCh <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*MyChan<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyConcurrentMap</span><span class="hljs-params">()</span></span> *MyConcurrentMap &#123;<br><span class="hljs-keyword">return</span> &amp;MyConcurrentMap &#123;<br>mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>),<br><span class="hljs-comment">// keyToCh: make(map[int]chan struct&#123;&#125;),</span><br>keyToCh: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*MyChan), <br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Put(k,v <span class="hljs-type">int</span>) &#123;<br>m.Lock()<br><span class="hljs-keyword">defer</span> m.Unlock()<br>m.mp[k] = v<br><br>ch, ok := m.keyToCh[k]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// ch &lt;- struct&#123;&#125;&#123;&#125;  // 不知道有多少个读Goroutine在等待, 放一个信号可能直接被消耗, 造成读死锁</span><br><span class="hljs-comment">// close(ch) // 直接关闭, 读channel会被唤醒, 写会panic; 会存在多次关闭ch的可能</span><br><br><span class="hljs-comment">// 方案1, 确保ch不会被重复关闭</span><br><span class="hljs-comment">/* select &#123;</span><br><span class="hljs-comment">case &lt;- ch:</span><br><span class="hljs-comment">return // 读到了数据, 说明channel关闭了</span><br><span class="hljs-comment">default:</span><br><span class="hljs-comment">close(ch) // 没有读到数据, channel没有关闭</span><br><span class="hljs-comment">&#125; */</span><br><span class="hljs-comment">// 方案2, 实现仅关闭一次的channel</span><br>ch.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Get(k <span class="hljs-type">int</span>, maxWaitingDuration time.Duration) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span> ) &#123;<br> m.Lock()<br> v, ok := m.mp[k]<br> <span class="hljs-keyword">if</span> ok &#123;<br> m.Unlock()<br> <span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br> &#125;<br><br> ch, ok := m.keyToCh[k]<br> <span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-comment">// ch = make(chan struct&#123;&#125;) // 对应的channel没有创建过, 创建这个channel</span><br>ch = NewMyChan()<br>m.keyToCh[k] = ch<br> &#125;<br><br> tCtx, canncel := context.WithTimeout(context.Background(), maxWaitingDuration)<br> <span class="hljs-keyword">defer</span> cancel()<br> <br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- tCtx.Done():<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>, tCtx.Err()<br><span class="hljs-keyword">case</span> &lt;- ch:<br>&#125;<br><br>m.Lock();<br>v = m.mp[k]<br>m.Unlock()<br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现一个读写锁"><a href="#实现一个读写锁" class="headerlink" title="实现一个读写锁"></a>实现一个读写锁</h2><p>五个方法</p><ul><li>Lock&#x2F;Unlock - 写操作时调用的方法<ul><li>如果已经被reader或者writer持有, 那么lock方法会一直阻塞, 获取锁</li><li>Unlock: 配对的释放锁的方法</li></ul></li><li>Rlock &#x2F; RUnlock - 读操作时调用的方法<ul><li>如果锁已经被writer持有的话, RLock方法会一直被阻塞, 直到获取锁, 否则直接返回</li><li>Runlock: 配对的释放锁的方法</li></ul></li><li>RLocker - 读操作时返回的Locker接口的对象</li></ul><p>RWMutex的5个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>w Mutex<br>writerSem <span class="hljs-type">uint32</span><br>readerSem <span class="hljs-type">uint32</span><br>readerCount <span class="hljs-type">int32</span><br>readerWait <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的其它高级特性</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%85%B6%E5%AE%83%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="cgo-Go调用C代码"><a href="#cgo-Go调用C代码" class="headerlink" title="cgo - Go调用C代码"></a>cgo - Go调用C代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int sum(int a,  int b) &#123;</span><br><span class="hljs-comment">return a + b;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-comment">// 以上述注释为源代码 生成二进制C方法</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(C.sum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在内存中开辟一个结构体</li><li>结构体中含有参数和返回值</li><li>结构体地址传入C方法</li><li>C方法将结果写入返回值的位置<br>需要调度器的配合</li><li>协程需要抢占式调度</li><li>进入C程序之后, 调度器无法抢占携程</li><li>调度器停止对此协程的调度<br>协程栈的切换</li><li>C的栈不受Runtime管理</li><li>进入C时, 需要将当前栈切换到线程的系统栈上<br>优缺点</li><li>cgo可以让Go调用现成的C实现</li><li>cgo限制了Go语言的跨平台特性</li><li>cgo并不能提高Go语言的性能</li></ul><h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><h2 id="协程记录defer信息-函数退出时调用"><a href="#协程记录defer信息-函数退出时调用" class="headerlink" title="协程记录defer信息, 函数退出时调用"></a>协程记录defer信息, 函数退出时调用</h2><p>解锁, 关闭资源等</p><h3 id="堆上分配"><a href="#堆上分配" class="headerlink" title="堆上分配"></a>堆上分配</h3><ul><li>1.12之前使用</li><li>在堆上开辟一个sched.deferpool</li><li>遇到defer语句, 将信息放入deferpool(p结构体中)</li><li>函数返回时, 从deferpool取出执行</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul><li>1.13之后出现</li><li>遇到defer语句, 将信息放入栈上 </li><li>函数返回时, 从栈中取出执行</li><li>只能保存一个defer信息(栈空间优先, 过大会导致扩容, 影响性能)</li></ul><h3 id="开放编码-性能最高"><a href="#开放编码-性能最高" class="headerlink" title="开放编码 - 性能最高"></a>开放编码 - 性能最高</h3><ul><li>1.14之后出现</li><li>如果defer语句在编译时就可以固定</li><li>直接改写用户代码, defer语句放入函数末尾</li></ul><h1 id="recover-拯救程序"><a href="#recover-拯救程序" class="headerlink" title="recover - 拯救程序"></a>recover - 拯救程序</h1><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><ul><li>抛出错误</li><li>终止协程运行</li><li>带崩整个Go程序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer main g&quot;</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer g&quot;</span>) <span class="hljs-comment">// 只有此会被调用</span><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;end g&quot;</span>)<br>&#125;()<br><br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;end main g&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>panic在退出协程之前会执行所有本协程已注册的defer</li><li>不会执行其它协程的defer</li></ul><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;defer main&quot;</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">recover</span>()<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;end g&quot;</span>)<br>&#125;()<br><br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;end main g&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>添加了recover之后, 可以恢复panic</p><ul><li>如果设计recover, defer会使用堆上分配(deferpool)</li><li>遇到panic, panic会从deferpool取出的defer语句执行</li><li>defer中调用recover, 可以终止panic的过程</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>panic终止当前协程的运行</li><li>panic在退出协程之前会执行所有已注册的defer在defert中执行recover,可以拯救panic的协程</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>不同类型执行不同逻辑</p><ul><li>获取对象的类型</li><li>对任意类型变量赋值</li><li>调用任意方法</li></ul><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><ul><li>元数据就是数据的数据</li><li>把对象的类型表示成一个数据类型</li><li>把对象的值表示成一个数据类型</li></ul><h2 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h2><ul><li>接口reflect.type</li><li>把对象的类型表示成一个接口</li><li>就能对类型做各种操作</li></ul><h2 id="对象的值"><a href="#对象的值" class="headerlink" title="对象的值"></a>对象的值</h2><ul><li>结构体 reflect.Value</li><li>把对象的值表示成一个结构体</li><li>就能对值做各种操作</li></ul><h2 id="对象到反射对象"><a href="#对象到反射对象" class="headerlink" title="对象到反射对象"></a>对象到反射对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Bing&quot;</span><br>fmt.Println(reflect.TypeOf(s))<br>sv := reflect.ValueOf(s)<br>fmt.Println(sv)<br><br><span class="hljs-comment">// 从值恢复到变量</span><br>s2 := sv.Interface().(<span class="hljs-type">string</span>)<br>fmt.Println(s2)<br></code></pre></td></tr></table></figure><h2 id="使用反射调用方法"><a href="#使用反射调用方法" class="headerlink" title="使用反射调用方法"></a>使用反射调用方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyAdd</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyAdd2</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallAdd</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) &#123;<br>v := reflect.ValueOf(f)<br><span class="hljs-keyword">if</span> v.Kind() != reflect.Func &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>argv := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-number">2</span>)<br>argv[<span class="hljs-number">0</span>] = reflect.ValueOf(<span class="hljs-number">1</span>)<br>argv[<span class="hljs-number">1</span>] = reflect.ValueOf(<span class="hljs-number">2</span>)<br>res := v.Call(argv)<br>fmt.Println(res[<span class="hljs-number">0</span>].Int())<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>CallAdd(MyAdd)<br>CallAdd(MyAdd2)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过反射调用方法, 可以将框架和用户方法解耦</li><li>往往需要用户注册方法 , 框架调用</li><li>很多框架的HTTP调用处理使用此思路</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的内存模型与垃圾回收</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="栈内存-协程栈-调用栈"><a href="#栈内存-协程栈-调用栈" class="headerlink" title="栈内存(协程栈, 调用栈)"></a>栈内存(协程栈, 调用栈)</h1><h2 id="Go协程栈的作用"><a href="#Go协程栈的作用" class="headerlink" title="Go协程栈的作用"></a>Go协程栈的作用</h2><p><img src="/img/Pasted%20image%2020230524101355.png"></p><ul><li>协程的执行路径</li><li>局部变量</li><li>函数传参</li><li>函数返回值</li></ul><h2 id="Go协程栈的位置"><a href="#Go协程栈的位置" class="headerlink" title="Go协程栈的位置"></a>Go协程栈的位置</h2><ul><li>Go的协程栈位于堆内存上</li><li>Go堆内存位于操作系统虚拟内存上</li></ul><h2 id="Go栈帧的结构"><a href="#Go栈帧的结构" class="headerlink" title="Go栈帧的结构"></a>Go栈帧的结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br>sum = a + b<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">3</span><br>b := <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(<br>sum(a, b)<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230524102337.png"></p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li>Go使用参数拷贝传递(值传递)</li><li>传递结构体时: 会拷贝结构体中全部内容</li><li>传递结构体指针时: 会拷贝结构体指针</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>协程栈记录了协程的执行现场</li><li>协程栈还负责记录局部变量，传递参数和返回值</li><li>Go使用参数拷贝传递</li></ul><h2 id="栈的扩增"><a href="#栈的扩增" class="headerlink" title="栈的扩增"></a>栈的扩增</h2><p>初始栈帧大小: 2k~4k </p><h3 id="局部变量太大"><a href="#局部变量太大" class="headerlink" title="局部变量太大"></a>局部变量太大</h3><p>可以通过逃逸分析解决<br>逃逸分析</p><ul><li>不是所有的变量都能放在协程栈上</li><li>栈帧回收后, 需要继续使用的变量</li><li>太大的变量<br>三种情形:</li><li>指针逃逸<br>函数返回了对象的指针<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>v := <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> &amp;v<br>&#125;<br></code></pre></td></tr></table></figure></li><li>空接口逃逸<br>如果函数参数为interface{}, 函数的实参很可能会逃逸<br>因为interface{}类型的函数往往会使用反射(要求对象在堆上)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">1</span><br>fmt.Println(i) <span class="hljs-comment">// 空接口逃逸</span><br></code></pre></td></tr></table></figure></li><li>大变量逃逸<br>过大的变量会导致栈空间不足<br>在64位的机器中, 一般超过64KB的变量会逃逸</li></ul><h3 id="栈帧太多"><a href="#栈帧太多" class="headerlink" title="栈帧太多"></a>栈帧太多</h3><p>栈扩容</p><ul><li>Go初始栈空间大小为2kb</li><li>在函数调用前判断栈空间(morestack)</li><li>必要时对栈进行扩容</li><li>早期使用分段栈, 后期使用连续栈</li></ul><h4 id="分段栈"><a href="#分段栈" class="headerlink" title="分段栈"></a>分段栈</h4><ul><li>1.13之前使用</li><li>优点: 没有空间浪费</li><li>缺点: 栈指针会在不连续的空间跳转<br><img src="/img/Pasted%20image%2020230524104520.png"></li></ul><h4 id="连续栈"><a href="#连续栈" class="headerlink" title="连续栈"></a>连续栈</h4><p>直接开辟一块大小为原来两倍的新栈空间, 将老的全部拷贝过来;<br>空间使用率不足1&#x2F;4是缩容, 变为原来1&#x2F;2;</p><ul><li>优点: 空间一直连续</li><li>缺点: 伸缩时开销大</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>三种特殊情况(逃逸)下, 变量可能会分配到堆上</li><li>1.13之前, Go使用可伸缩的分段栈</li><li>1.14以后, Go使用连续栈, 伸缩时直接使用新栈</li></ul><h1 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1><h2 id="操作系统的虚拟内存"><a href="#操作系统的虚拟内存" class="headerlink" title="操作系统的虚拟内存"></a>操作系统的虚拟内存</h2><ul><li>不是Win的”虚拟内存”(交换区, Linux下的Swap)</li><li>操作系统给应用提供的虚拟内存空间</li><li>背后是物理内存, 也有可能是磁盘</li><li>Linux获取虚拟内存: mmap, madvice<br> <img src="/img/Pasted%20image%2020230524111556.png"></li></ul><h2 id="heapArena"><a href="#heapArena" class="headerlink" title="heapArena"></a>heapArena</h2><ul><li>Go每次申请的虚拟内存单元为64MB</li><li>最多有2^20个虚拟内存单元</li><li>所有的heapArena组成了mheap(Go堆内存)</li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ul><li><p>线性分配: 没分配满的时候, 一直向后分配<br><img src="/img/Pasted%20image%2020230524112720.png"></p></li><li><p>链表分配: 使用链表串联起所有空闲内存块<br><img src="/img/Pasted%20image%2020230524112807.png"></p><blockquote><p>线性分配或者链表分配很容易出现空间碎片</p></blockquote></li><li><p>分级分配<br>找到比要分配对象的最小内存块<br><img src="/img/Pasted%20image%2020230524113122.png"><br>外部碎片比较少<br>级 -&gt; mspan</p></li></ul><h2 id="内存管理单元mspan"><a href="#内存管理单元mspan" class="headerlink" title="内存管理单元mspan"></a>内存管理单元mspan</h2><ul><li>根据隔离适应策略，使用内存时的最小单位为mspan</li><li>每个mspan为N个相同大小的“格子” </li><li>Go中一共有67种mspan<br><img src="/img/Pasted%20image%2020230524113424.png"></li><li>每个heapArena中的mspan都不确定</li><li>如何快速找到所需的mspan级别? 中心索引mcenteral</li></ul><h2 id="中心索引mcentral"><a href="#中心索引mcentral" class="headerlink" title="中心索引mcentral"></a>中心索引mcentral</h2><ul><li>136个mcentral结构体, 其中<ul><li>68个需要扫描的mspan()</li><li>68个不需要扫描的mspan(常量等)<br><img src="/img/Pasted%20image%2020230524123452.png"></li></ul></li></ul><h2 id="mcentral的性能问题"><a href="#mcentral的性能问题" class="headerlink" title="mcentral的性能问题"></a>mcentral的性能问题</h2><ul><li>mcentral实际是中心索引, 使用互斥锁保护</li><li>高并发场景下, 锁冲突问题严重</li><li>参考协程GMP模型, 增加线程本地缓存</li></ul><h2 id="线程缓存mcache"><a href="#线程缓存mcache" class="headerlink" title="线程缓存mcache"></a>线程缓存mcache</h2><ul><li>每个P拥有一个mcache</li><li>一个mcache拥有136个mspan, 其中<ul><li>68个需要GC扫描的mspan</li><li>68个不需要GC扫描的mspan<br><img src="/img/Pasted%20image%2020230524124322.png"></li></ul></li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>Go魔方TCmalloc, 建立了自己的堆内存架构</li><li>使用heapArena向操作系统申请内存</li><li>使用heapArena时, 以mspan为单位, 防止碎片化</li><li>mcentral是mspan们的中心索引</li><li>mcache记录了分配给各个P的本地mspan</li></ul><h2 id="对象分级"><a href="#对象分级" class="headerlink" title="对象分级"></a>对象分级</h2><ul><li>Tiny微对象(0, 16B) 无指针</li><li>Small小对象<code>[16B, 32KB]</code></li><li>Large大对象(32KB, +inf)</li></ul><p>微小对象分配到普通mspan, class 1 ~ class 67<br>大对象量身定做mspan</p><h2 id="微小对象分配"><a href="#微小对象分配" class="headerlink" title="微小对象分配"></a>微小对象分配</h2><ul><li>从mcache拿到2级mspan</li><li>将多个微对象合并成一个16Byte存入<br><img src="/img/Pasted%20image%2020230524125614.png"></li></ul><h2 id="mcache的替换"><a href="#mcache的替换" class="headerlink" title="mcache的替换"></a>mcache的替换</h2><ul><li>mcache中, 每个级别的mspan只有一个</li><li>当mspan满了之后, 会从mcentral中换一个新的</li></ul><h2 id="mcentral的扩容"><a href="#mcentral的扩容" class="headerlink" title="mcentral的扩容"></a>mcentral的扩容</h2><ul><li>mcentral中, 只有有限数量的mspan</li><li>当mspan缺少时, 会从heapArena开辟新的mspan</li></ul><h2 id="大对象分配"><a href="#大对象分配" class="headerlink" title="大对象分配"></a>大对象分配</h2><ul><li>直接从heapArena开辟0级的mspan</li><li>0级的mspan为大对象定制</li></ul><h2 id="heapArena的扩容"><a href="#heapArena的扩容" class="headerlink" title="heapArena的扩容"></a>heapArena的扩容</h2><ul><li>当heapArena空间不足时</li><li>向操作系统申请新的heapArena</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul><li>Go将对象按照大小分为3种</li><li>微小对象使用mcache</li><li>mcache中的mspan填满后, 与mcentral交换新的</li><li>mcentral不足时, 在heapArena开辟新的mspan</li><li>大对象直接在heapArena开辟新的mspan</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>“标记-清除”</li><li>“标记-整理”</li><li>复制</li></ul><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p><img src="/img/Pasted%20image%2020230524145303.png"><br>标记之后, 清除即可.</p><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><p><img src="/img/Pasted%20image%2020230524145711.png"><br>标记完成后, 进行整理, 都向前放.</p><h2 id="标记复制"><a href="#标记复制" class="headerlink" title="标记复制"></a>标记复制</h2><p><img src="/img/Pasted%20image%2020230524145837.png"><br>把有用的复制到新的地方<br><img src="/img/Pasted%20image%2020230524145908.png"></p><h2 id="Go中"><a href="#Go中" class="headerlink" title="Go中"></a>Go中</h2><ul><li>由于堆内存结构的独特优势, 选择最简单的标记-清除</li><li>找到有引用的对象, 剩下的就是没有引用的</li></ul><h2 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h2><p>Root Set(GC Root)</p><ul><li>被栈上的指针引用</li><li>被全局变量指针引用</li><li>被寄存器中的指针引用<br>可达性分析标记法 - Root节点进行广度优先搜索<br><img src="/img/Pasted%20image%2020230524150440.png"><br>只有G, H会被回收</li></ul><h2 id="串行GC"><a href="#串行GC" class="headerlink" title="串行GC"></a>串行GC</h2><p>步骤</p><ol><li>Stop The World, 暂停其它所有协程</li><li>通过可达性分析, 找到无用的堆内存</li><li>释放堆内存</li><li>恢复所有其它协程<br>问题</li></ol><ul><li>串行对业务性能影响较大</li></ul><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul><li>从GC Root出发，寻找被引用对象</li><li>没有被引用的就是无用对象</li><li>串行GC需要STW,对性能景影响大</li></ul><h2 id="并发GC"><a href="#并发GC" class="headerlink" title="并发GC"></a>并发GC</h2><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><ul><li>黑色: 有用, 已经分析扫描</li><li>灰色: 有用, 还未分析扫描</li><li>白色: 暂时无用</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>起初所有的对象都是白色的<br><img src="/img/Pasted%20image%2020230524151440.png"></li><li>从根对象出发扫描可达对象, 标记为灰色<br><img src="/img/Pasted%20image%2020230524152123.png"></li><li>扫描灰色对象, 将其引用的对象标记为灰色, 自身标记为黑色<br><img src="/img/Pasted%20image%2020230524152407.png"><br><img src="/img/Pasted%20image%2020230524152451.png"></li><li>清除白色对象.</li><li>再次标记时, 所有对象恢复为白色.</li></ol><h3 id="并发标记问题-删除"><a href="#并发标记问题-删除" class="headerlink" title="并发标记问题(删除)"></a>并发标记问题(删除)</h3><ul><li>并发标记进行中<br><img src="/img/Pasted%20image%2020230524152925.png"></li><li>在业务协程中, B指向C的指针释放<br><img src="/img/Pasted%20image%2020230524152836.png"></li><li>在业务协程中, E的一个指针成员指向了C<br><img src="/img/Pasted%20image%2020230524153024.png"></li><li>持续扫描<br><img src="/img/Pasted%20image%2020230524153142.png"><br><strong>C将会被错误清除</strong> -&gt; Yuasa删除屏障</li></ul><h3 id="Yuasa删除屏障"><a href="#Yuasa删除屏障" class="headerlink" title="Yuasa删除屏障"></a>Yuasa删除屏障</h3><ul><li>并发标记时, 对指针释放的白色对象置为灰色<br><img src="/img/Pasted%20image%2020230524155130.png"></li><li>删除屏障: C被置为灰色 </li><li>删除屏障可以杜绝在GC标记中释放的指针被清理</li></ul><h3 id="并发标记问题-插入"><a href="#并发标记问题-插入" class="headerlink" title="并发标记问题(插入)"></a>并发标记问题(插入)</h3><ul><li>并发标记进行中<br><img src="/img/Pasted%20image%2020230524155350.png"></li><li>在业务协程中, E的一个指针成员指向了C<br><img src="/img/Pasted%20image%2020230524155501.png"><br>此时则出现了问题, C会被错误删除 -&gt; Dijkstra插入屏障</li></ul><h3 id="Dijkstra插入屏障"><a href="#Dijkstra插入屏障" class="headerlink" title="Dijkstra插入屏障"></a>Dijkstra插入屏障</h3><p>并发标记时, 对指针新指向的白色对象置为灰色<br><img src="/img/Pasted%20image%2020230524155904.png"><br>插入屏障可以杜绝在GC标记中被插入的指针被清理</p><h3 id="混合屏障"><a href="#混合屏障" class="headerlink" title="混合屏障"></a>混合屏障</h3><ul><li>被删除的堆对象被标记为灰色</li><li>被添加的堆对象标记为灰色</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul><li>并发垃圾回收的关键在于标记安全</li><li>混合屏障机制兼顾了安全与效率</li></ul><h1 id="如何优化GC效率"><a href="#如何优化GC效率" class="headerlink" title="如何优化GC效率"></a>如何优化GC效率</h1><h2 id="GC触发的时机"><a href="#GC触发的时机" class="headerlink" title="GC触发的时机"></a>GC触发的时机</h2><h3 id="系统定时触发"><a href="#系统定时触发" class="headerlink" title="系统定时触发"></a>系统定时触发</h3><ul><li>sysmon定时检查(g0协程)</li><li>如果2分钟内没有过GC, 触发</li><li>谨慎调整</li></ul><h3 id="用户显式触发"><a href="#用户显式触发" class="headerlink" title="用户显式触发"></a>用户显式触发</h3><ul><li>用户调用runtime.GC方法</li><li>并不推荐调用</li></ul><h3 id="申请内存时触发"><a href="#申请内存时触发" class="headerlink" title="申请内存时触发"></a>申请内存时触发</h3><ul><li>给对象申请堆空间时, 可能导致GC</li></ul><h2 id="GC优化原则"><a href="#GC优化原则" class="headerlink" title="GC优化原则"></a>GC优化原则</h2><ul><li>尽量少在堆上产生垃圾<ul><li>内存池化</li><li>减少逃逸</li><li>使用空结构体</li></ul></li></ul><h3 id="内存池化"><a href="#内存池化" class="headerlink" title="内存池化"></a>内存池化</h3><ul><li>缓存性质的对象</li><li>频繁创建和删除</li><li>使用内存池, 不GC</li></ul><h3 id="减少逃逸"><a href="#减少逃逸" class="headerlink" title="减少逃逸"></a>减少逃逸</h3><ul><li>逃逸会使原本在栈上的对象进入堆中</li><li>fmt包</li><li>返回了指针而不是拷贝</li></ul><h3 id="使用空结构体"><a href="#使用空结构体" class="headerlink" title="使用空结构体"></a>使用空结构体</h3><ul><li>空结构体指向一个固定地址</li><li>不占用堆空间</li><li>比如channel传递空结构体</li></ul><h3 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h3><ul><li>go tool pprof</li><li>go tool trace</li><li>go build -gcflags&#x3D;” -m”</li><li>GODEBUG&#x3D;”gctrace&#x3D;1”</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul><li>GC主要由系统定时触发或者申请内存触发</li><li>GC优化的原则是减少在堆上产生垃圾</li><li>使用GC分析工具可以帮助分析GC问题</li></ul><h1 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h1><h2 id="协程栈"><a href="#协程栈" class="headerlink" title="协程栈"></a>协程栈</h2><ul><li>协程栈记录了协程的执行现场</li><li>G0协程栈位于G0堆内存上</li><li>Go使用参数拷贝传递</li><li>3种特殊情况下，变量可能会逃逸到堆上</li><li>1.14以后，G0使用连续栈，伸缩时直接使用新栈</li></ul><h2 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h2><p><img src="/img/Pasted%20image%2020230524124322.png"></p><ul><li>Go模仿TCmalloc,建立了自己的堆内存架构</li><li>使用heapArena向操作系统申请内存</li><li>使用heapArena时，以mspan为单位，防止碎片化</li><li>mcentral是mspan们的中心索引</li><li>mcache记录了分配给各个P的本地mspan</li></ul><h3 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h3><ul><li>G0将对象按照大小分为3种</li><li>微小对象使用mcache</li><li>mcache中的mspan填满后，与mcentral交换新的</li><li>mcentral不足时，在heapArena开辟新的mspan</li><li>大对象直接在heapArena开辟新的mspan</li></ul><h2 id="堆内存回收-GC"><a href="#堆内存回收-GC" class="headerlink" title="堆内存回收(GC)"></a>堆内存回收(GC)</h2><ul><li>“标记-清除”法<ul><li>标记有用对象，清除无用对象</li></ul></li><li>“可达性分析”标记法<ul><li>从GC Root出发，寻找被引用对象</li></ul></li></ul><h2 id="并发GC-1"><a href="#并发GC-1" class="headerlink" title="并发GC"></a>并发GC</h2><ul><li>并发垃圾回收的关键在于标记安全</li><li>混合屏障机制兼顾了安全与效率</li></ul><h2 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h2><ul><li>GC主要由系统定时触发或者申请内存触发</li><li>GC优化的原则是减少在堆上产生垃圾</li><li>使用GC分析工具可以帮助分析GC问题</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的TCP网络编程</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP通讯基本原理"><a href="#TCP通讯基本原理" class="headerlink" title="TCP通讯基本原理"></a>TCP通讯基本原理</h1><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p><img src="/img/Pasted%20image%2020230523202540.png"> </p><h2 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程"></a>TCP通信过程</h2><p> <img src="/img/Pasted%20image%2020230523202721.png"></p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li>很多系统都提供Socket作为TCP网络连接的抽象</li><li>Linux -&gt; Internet domain -&gt; SOCK_STRE</li><li>AM</li><li>Linux中Socket以”文件描述符”FD作为标识</li></ul><h2 id="Socket通信过程"><a href="#Socket通信过程" class="headerlink" title="Socket通信过程"></a>Socket通信过程</h2><p><img src="/img/Pasted%20image%2020230523202927.png"><br><img src="/img/Pasted%20image%2020230523203134.png"></p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO模型指的是同时操作Socket的方案</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><img src="/img/Pasted%20image%2020230523203714.png"><br>同步读写Socket时，线程陷入内核态; 当读写成功后，切换回用户态，继续执行;<br>优点：开发难度小，代码简单</p><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p><img src="/img/Pasted%20image%2020230523203941.png"><br>如果暂时无法收发数据，会返回错误; 应用会不断轮询，直到Socketi可以读写;<br>优点：不会陷入内核态，自由度高; 缺点：需要自旋轮询</p><h3 id="多路复用-Linux-epoll"><a href="#多路复用-Linux-epoll" class="headerlink" title="多路复用 - Linux epoll"></a>多路复用 - Linux epoll</h3><p> <img src="/img/Pasted%20image%2020230523204128.png"><br> 注册多个Socket事件; 调用epool,当有事件发生，返回<br> 优点：提供了事件列表，不需要查询各个Scoket;  缺点：开发难度大，逻辑复杂<br> Mac: kqueue, Windows: IOCP</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>操作系统提供了Socket作为TCP通信的抽象</li><li>IO模型指的是操作Socket的方案</li><li>阻塞模型最利于业务编写，但是性能差</li><li>多路复用性能好，但业务编写麻烦</li></ul><h1 id="net包对TCP通信的实现"><a href="#net包对TCP通信的实现" class="headerlink" title="net包对TCP通信的实现"></a>net包对TCP通信的实现</h1><h2 id="阻塞模型-多路复用"><a href="#阻塞模型-多路复用" class="headerlink" title="阻塞模型 + 多路复用"></a>阻塞模型 + 多路复用</h2><ul><li>在底层使用操作系统的多路复用IO</li><li>在协程层次使用阻塞模型</li><li>阻塞协程时，休眠协程</li></ul><h2 id="epoll抽象层"><a href="#epoll抽象层" class="headerlink" title="epoll抽象层"></a>epoll抽象层</h2><p>epoll抽象层是为了统一各个操作系统对多路复用器的实现<br>各个系统的多路复用都有一下功能(以linux epoll为例):</p><ul><li>新建多路复用器 epoll_create()</li><li>往多路复用器里插入需要监听的时间 epoll_ctl()</li><li>查询发生了什么事件 epoll_wait()</li></ul><h2 id="Go-Network-Poller多路复用器的抽象"><a href="#Go-Network-Poller多路复用器的抽象" class="headerlink" title="Go Network Poller多路复用器的抽象"></a>Go Network Poller多路复用器的抽象</h2><p>Go Network Poller对多路复用器的抽象和适配</p><h3 id="新建多路复用器-netpollinit-epoll-create"><a href="#新建多路复用器-netpollinit-epoll-create" class="headerlink" title="新建多路复用器 netpollinit() -&gt; epoll_create()"></a>新建多路复用器 netpollinit() -&gt; epoll_create()</h3><ol><li>调用epollcreate(汇编实现, 底层是epoll_create) 新建epoll</li><li>新建一个pipe管道用于中断epoll</li><li>将”管道有数据到达”时间注册到epoll中<br>最重要的是拿到<code>epfd</code></li></ol><h3 id="插入事件-netpollopen-epoll-ctl"><a href="#插入事件-netpollopen-epoll-ctl" class="headerlink" title="插入事件 netpollopen() -&gt; epoll_ctl()"></a>插入事件 netpollopen() -&gt; epoll_ctl()</h3><p>EPOLL_IN EPOLL_OUT EPOLL_RDHUP EPOLL_ET </p><ul><li>传入一个Socket的FD, 和pollDesc指针</li><li>pollDesc指针记录了<ul><li>Socket相关详细信息</li><li>哪个协程在等待此Socket</li></ul></li><li>将Socket可读&#x2F;可写&#x2F;断开注册到Epoll当中</li></ul><h3 id="查询事件-netpoll-epoll-wait"><a href="#查询事件-netpoll-epoll-wait" class="headerlink" title="查询事件 netpoll -&gt; epoll_wait()"></a>查询事件 netpoll -&gt; epoll_wait()</h3><ul><li>调用epoll_wait(), 查询有哪些时间发生</li><li>根据Socket相关的pollDesc信息, 返回哪些协程可以唤醒</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>Go将多路复用器的操作进行了抽象和适配<ul><li>将新建多路复用器抽象为了netpollinit()</li><li>将插入监听事件抽象为了netpollopen()</li><li>将查询事件抽象为了netpoll()</li><li>但不是返回事件，而是返回等待事件的协程列表</li></ul></li></ul><h2 id="Network-Poller-如何工作"><a href="#Network-Poller-如何工作" class="headerlink" title="Network Poller 如何工作"></a>Network Poller 如何工作</h2><h3 id="Network-Poller初始化"><a href="#Network-Poller初始化" class="headerlink" title="Network Poller初始化"></a>Network Poller初始化</h3><ul><li>poll_runtime_pollServerInit()</li><li>使用原子操作保证只初始化一次</li><li>调用netpollinit()</li></ul><h3 id="pollcache与pollDesc"><a href="#pollcache与pollDesc" class="headerlink" title="pollcache与pollDesc"></a>pollcache与pollDesc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pollCache <span class="hljs-keyword">struct</span> &#123;<br>lock mutex<br>first *pollDesc <span class="hljs-comment">// 放链表头</span><br>&#125;<br><br><span class="hljs-keyword">type</span> pollDesc <span class="hljs-keyword">struct</span> &#123;<br>link *pollDesc <span class="hljs-comment">// 后续指针</span><br><span class="hljs-comment">// ...</span><br>fd <span class="hljs-type">uintptr</span> <span class="hljs-comment">// socket的ID</span><br>rg <span class="hljs-type">uintptr</span> <span class="hljs-comment">// pdReady(1), pdWait(2), 等待读的协程的地址</span><br>wg <span class="hljs-type">uintptr</span> <span class="hljs-comment">// pdReady(1), pdWait(2), 等待写的协程的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>pollcache: 一个带锁的链表头</li><li>polDesc: 链表的成员</li><li>pollDesc是runtime包对Socket的详细描述(记录了哪些协程对该socket感兴趣)</li><li>rg, rw: 初始(0), pdReady(1), pdWait(2), 或者等待协程G的地址<br><img src="/img/Pasted%20image%2020230523214244.png"></li></ul><h3 id="Network-Poller新增监听Socket"><a href="#Network-Poller新增监听Socket" class="headerlink" title="Network Poller新增监听Socket"></a>Network Poller新增监听Socket</h3><ul><li>poll_runtime_pollOpen()</li><li>在pollcache链表中分配一个pollDesc</li><li>初始化pollDesc(rg, rw为0)</li><li>调用netpollopen(见上节, 注册各种epoll事件)</li></ul><h2 id="Network-Poller收发数据"><a href="#Network-Poller收发数据" class="headerlink" title="Network Poller收发数据"></a>Network Poller收发数据</h2><p>收发数据分为两个场景:</p><ul><li>协程需要收发数据时, Socket已经可读可写</li><li>协程需要收发数据时, Socket暂时无法读写</li></ul><h3 id="场景1-Socket已经可读可写"><a href="#场景1-Socket已经可读可写" class="headerlink" title="场景1: Socket已经可读可写"></a>场景1: Socket已经可读可写</h3><ul><li>runtime循环调用netpoll()方法(g0协程, 最终是通过垃圾回收器调用, gcStart, 一个hook)</li><li>发现Socket可读写时, 给对应的rg或者wg置为pdReady(1)</li><li>协程调用poll_runtime_pollWait()</li><li>判断rg或者wg已经置为pdReady(1), 返回0</li></ul><h3 id="场景2-Socket暂时无法读写"><a href="#场景2-Socket暂时无法读写" class="headerlink" title="场景2: Socket暂时无法读写"></a>场景2: Socket暂时无法读写</h3><ul><li>runtime循环调用netpoll()方法</li><li>协程调用poll_runtime_pollWait()</li><li>发现对应的rg或者wg为0</li><li>给对应的rg或者wg置为协程地址</li><li>休眠等待</li><li>runtime循环调用netpoll方法</li><li>发现Socket可读写时, 查看对应的rg或者wg</li><li>若为协程地址, 返回协程地址(有协程在监听)</li><li>调度器开始调度对应协程</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>Network Poller是Runtime的强大工具</li><li>抽象了多路复用器的操作</li><li>Network Poller可以自动监测多个Socket状态</li><li>在Socket状态可用时，快速返回成功</li><li>在Socket状态不可用时，休眠等待</li></ul><h2 id="Go-抽象Socket"><a href="#Go-抽象Socket" class="headerlink" title="Go 抽象Socket"></a>Go 抽象Socket</h2><h3 id="net包"><a href="#net包" class="headerlink" title="net包"></a>net包</h3><ul><li>net包是go原生的网络包</li><li>net包支持了TCP, UDP, HTTP等网络操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>) <span class="hljs-comment">// 监听8888端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">var</span> body [<span class="hljs-number">100</span>]<span class="hljs-type">byte</span><br><span class="hljs-keyword">for</span> &#123;<br>_, err := conn.Read(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;收到消息: %s\n&quot;</span>, body)<br>_, err = conn.Write(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="net-Listen"><a href="#net-Listen" class="headerlink" title="net.Listen()"></a>net.Listen()</h3><ul><li>新建Socket, 并执行bind操作</li><li>新建一个FD(net包对Socket的详情描述)</li><li>返回一个TCPListener对象</li><li>将TCPListener的FD信息加入监听</li><li>TCPListener对象本质上是一个Listen状态的Socket</li></ul><h3 id="TCPListener-Accept"><a href="#TCPListener-Accept" class="headerlink" title="TCPListener.Accept()"></a>TCPListener.Accept()</h3><ul><li>直接调用Socket的accept()</li><li>如果失败，休眠等待新的连接</li><li>将新的Socket包装为TCPConn变量返回</li><li>将TCPConn的FD信息加入监听</li><li>TCPConn本质上是一个ESTABLISHED状态的Socket</li></ul><h3 id="TCPConn-Read-Write"><a href="#TCPConn-Read-Write" class="headerlink" title="TCPConn.Read() &#x2F; Write()"></a>TCPConn.Read() &#x2F; Write()</h3><ul><li>直接调用Socket原生读写方法</li><li>如果失败，休眠等待可读&#x2F;可写</li><li>被唤醒后调用系统Socket</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>net包抽象了TCP网络操作</li><li>使用net.Listen()得到TCPListener(LISTEN状态的Socket)</li><li>使用TCPListener..Accept()得到TCPConn(ESTABLISHED)</li><li>TCPConn.Read() &#x2F; Write() 进行读写Socket的操作</li><li>Network Poller 作为上述功能的底层支撑</li></ul><h1 id="Go搭建TCP-Server"><a href="#Go搭建TCP-Server" class="headerlink" title="Go搭建TCP Server"></a>Go搭建TCP Server</h1><p>结合阻塞模型和多路复用<br><img src="/img/Pasted%20image%2020230523230339.png"></p><ul><li>用主协程监听Listener</li><li>每个Conn使用一个新携程处理<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := conn.Close(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> body [<span class="hljs-number">100</span>]<span class="hljs-type">byte</span><br><span class="hljs-keyword">for</span> &#123;<br>_, err := conn.Read(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;收到消息: %s\n&quot;</span>, body)<br>_, err = conn.Write(body[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>) <span class="hljs-comment">// 监听8888端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">go</span> handleConnection(conn)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><h2 id="系统IO模型"><a href="#系统IO模型" class="headerlink" title="系统IO模型"></a>系统IO模型</h2><ul><li>操作系统提供了Socket作为TCP通信的抽象</li><li>lO模型指的是操作Socket的方案</li><li>阻塞模型最利于业务编写，但是性能差</li><li>多路复用性能好，但业务编写麻烦</li></ul><h2 id="Epoll的抽象"><a href="#Epoll的抽象" class="headerlink" title="Epoll的抽象"></a>Epoll的抽象</h2><ul><li>Go将多路复用器的操作进行了抽象和适配：<ul><li>将新建多路复用器抽象为了netpollinit()</li><li>将插入监听事件抽象为了netpollopent()</li><li>将查询事件抽象为了netpoll()</li><li>但不是返回事件, 而是返回等待事件的协程列表</li></ul></li></ul><h2 id="Network-Poller的原理"><a href="#Network-Poller的原理" class="headerlink" title="Network Poller的原理"></a>Network Poller的原理</h2><ul><li>Network Poller是Runtime的强大工具</li><li>抽象了多路复用器的操作</li><li>Network Poller可以自动监测多个Socket状态</li><li>在Socket状态可用时，快速返回成功</li><li>在Socket状态不可用时，休眠等待</li></ul><h2 id="Net包"><a href="#Net包" class="headerlink" title="Net包"></a>Net包</h2><ul><li>net包抽象了TCP网络操作使用net.Listen()得到TCPListener(LISTEN状态的Socket)</li><li>使用TCPListener.Accept()得到TCPConn(ESTABLISHED)</li><li>TCPConn.Read()&#x2F;Write进行读写Socket的操作</li><li>Network Poller作为上述功能的底层支撑</li></ul><h2 id="goroutine-per-connection"><a href="#goroutine-per-connection" class="headerlink" title="goroutine-per-connection"></a>goroutine-per-connection</h2><ul><li>用主协程监听Listener</li><li>每个Conn使用一个新协程处理</li><li>结合了多路复用的性能和阻塞模型的简洁</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的Channel</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84Channel/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84Channel/</url>
    
    <content type="html"><![CDATA[<p>CSP模型: Communicating Sequential Process, 两个独立并发实体通过共享的通讯Channel进行通信的并发模型</p><h1 id="管道-vs-共享内存"><a href="#管道-vs-共享内存" class="headerlink" title="管道 vs 共享内存"></a>管道 vs 共享内存</h1><h2 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h2><ul><li><code>make(chan int)</code>  无缓冲</li><li><code>make(chan bool, 0)</code> &#x2F;&#x2F; 无缓冲</li><li><code>make(chan string, 2)</code> &#x2F;&#x2F; 有缓冲</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li><code>ch &lt;- x</code> &#x2F;&#x2F; 发送数据</li><li><code>x = &lt;- ch</code> &#x2F;&#x2F; 接收数据, 赋给x</li><li><code>&lt;- ch</code> &#x2F;&#x2F; 接收数据, 并丢弃</li></ul><h2 id="内存与通信"><a href="#内存与通信" class="headerlink" title="内存与通信"></a>内存与通信</h2><ul><li>不要通过共享内存的方式进行通信</li><li>而是应该通过通信的方式共享内存</li></ul><h2 id="为什么使用管道"><a href="#为什么使用管道" class="headerlink" title="为什么使用管道"></a>为什么使用管道</h2><ul><li>避免协程竞争和数据冲突的问题</li><li>更高级的抽象，降低开发难度，增加程序可读性</li><li>模块之间更容易解耦，增强扩展性和可维护性</li></ul><h1 id="如何设计"><a href="#如何设计" class="headerlink" title="如何设计"></a>如何设计</h1><p><img src="/img/Pasted%20image%2020230521221828.png"><br><img src="/img/Pasted%20image%2020230521222033.png"></p><h2 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h2><p><img src="/img/Pasted%20image%2020230521222819.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 指示channel是开放还是关闭</span><br>closed <span class="hljs-type">uint32</span> <span class="hljs-comment">// 0开启, 1关闭</span><br><br><span class="hljs-comment">// 组成一个缓存区</span><br>qcount <span class="hljs-type">uint</span><br>dataqsiz <span class="hljs-type">uint</span><br>buf unsafe.Pointer<br>elemsize <span class="hljs-type">uint16</span><br>elemtype *_type<br><br><span class="hljs-comment">// 两个队列</span><br>recvx <span class="hljs-type">uint</span> <span class="hljs-comment">// Channel接收操作处理到的位置</span><br>recvq waitq <span class="hljs-comment">// 链表</span><br><br>sendx <span class="hljs-type">uint</span><br>sendq waitq<br><br><span class="hljs-comment">// 保护hchan所有字段</span><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>环形缓存可以大幅降低GC的开销</li><li>互斥锁并不是用来排队发送&#x2F;接收数据</li><li>互斥锁保护的hchan结构体本身</li><li>Channel并不是无锁的</li></ul><h2 id="发送数据的底层原理"><a href="#发送数据的底层原理" class="headerlink" title="发送数据的底层原理"></a>发送数据的底层原理</h2><h3 id="c"><a href="#c" class="headerlink" title="c&lt;-关键字"></a><code>c&lt;-</code>关键字</h3><ul><li><code>c&lt;-关键字</code>是一个语法糖</li><li>编译阶段, 会把 <code>c&lt;-</code>转化为<code>runtime.chansend1()</code></li><li>chansend1()会调用chansend()方法</li></ul><h3 id="发送情形"><a href="#发送情形" class="headerlink" title="发送情形"></a>发送情形</h3><p><img src="/img/Pasted%20image%2020230521223417.png"></p><h4 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h4><p><img src="/img/Pasted%20image%2020230521223523.png"><br>发送数据前, 已经有G在休眠等待接收<br>此时缓存肯定是空的, 不用考虑缓存<br>将数据直接拷贝给G的接收变量, 唤醒G<br>实现:<br>    1. 从队列里去除一个等待接收的G<br>    2. 将数据直接拷贝到接收变量中<br>    3. 唤醒G</p><h4 id="放入缓存"><a href="#放入缓存" class="headerlink" title="放入缓存"></a>放入缓存</h4><p><img src="/img/Pasted%20image%2020230521224355.png"><br>没有G在休眠等待, 但是有缓存空间<br>将数据放入缓存<br>实现:<br>    1. 获取可存入的缓存地址<br>    2. 存入数据<br>    3. 维护索引</p><h4 id="休眠等待"><a href="#休眠等待" class="headerlink" title="休眠等待"></a>休眠等待</h4><p><img src="/img/Pasted%20image%2020230521224641.png"><br>没有G在休眠等待, 而且没有缓存或满了<br>自己进入发送队列, 休眠等待<br>实现:<br>    1. 把自己包装成sudog<br>    2.  sudog放入sendq队列<br>    3. 休眠并解锁<br>    4. 被唤醒后, 数据已经被取走, 维护其它数据</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>编译阶段，会把&lt;-转化为runtime.chansend1()</li><li>1.直接发送时，将数据直接拷贝到目标变量</li><li>2.放入缓存时，将数据放入环形缓存，成功返回</li><li>3.休眠等待时，将自己包装后放入sendq,休眠</li></ul><h2 id="接收数据的底层原理"><a href="#接收数据的底层原理" class="headerlink" title="接收数据的底层原理"></a>接收数据的底层原理</h2><h3 id=""><a href="#" class="headerlink" title="&lt;-c 关键字"></a><code>&lt;-c</code> 关键字</h3><ul><li><code>&lt;-c</code> 关键字也是一个语法糖</li><li>编译阶段, <code>i&lt;-c</code> 转化为<code>runtime.chanrecv1()</code></li><li>或者 <code>i, ok&lt;-c</code> 转化为<code>runtime.chanrecv2()</code></li><li>最后调用<code>chanrecv()</code>方法</li></ul><h3 id="接收情形"><a href="#接收情形" class="headerlink" title="接收情形"></a>接收情形</h3><h4 id="缓冲区空-有等待的G-从G中接收"><a href="#缓冲区空-有等待的G-从G中接收" class="headerlink" title="缓冲区空, 有等待的G, 从G中接收"></a>缓冲区空, 有等待的G, 从G中接收</h4><p><img src="/img/Pasted%20image%2020230522222015.png"><br>接收数据前, 已经有协程在休眠等待发送<br>而且这个Channel没有缓存<br>将数据直接从G拷贝过来, 唤醒G<br>实现:</p><ol><li>判断有G在发送队列等待, 进入recv()</li><li>判断次Channel无缓存</li><li>直接从等待的协程中取走数据, 唤醒G</li></ol><h4 id="缓冲区满-有等待的协程-从缓存接收"><a href="#缓冲区满-有等待的协程-从缓存接收" class="headerlink" title="缓冲区满, 有等待的协程, 从缓存接收"></a>缓冲区满, 有等待的协程, 从缓存接收</h4><p><img src="/img/Pasted%20image%2020230522222424.png"><br>接收数据前, 已经有协程在休眠等待发送<br>而且这个Channel有缓存<br>从缓存取走一个数据(先取缓存中的数据, 因为缓存中的数据比较早)<br>将休眠协程的数据放入缓存, 唤醒协程<br>实现:</p><ol><li>判断有G在发送队列等待, 进入recv()</li><li>判断此Channel有缓存</li><li>从缓存中取走一个数据</li><li>将G的数据放入缓存, 唤醒G</li></ol><h4 id="缓冲区有值-没有等待协程-从缓存接收"><a href="#缓冲区有值-没有等待协程-从缓存接收" class="headerlink" title="缓冲区有值, 没有等待协程, 从缓存接收"></a>缓冲区有值, 没有等待协程, 从缓存接收</h4><p><img src="/img/Pasted%20image%2020230522223027.png"><br>没有协程在休眠等待发送, 但是缓存有内容<br>从缓存中取走数据<br>实现:</p><ol><li>判断没有协程在发送队列等待</li><li>判断此Channel有缓存</li><li>从缓存中取走一个数据</li></ol><h4 id="缓冲区空-且没有等待发送协程-阻塞接收"><a href="#缓冲区空-且没有等待发送协程-阻塞接收" class="headerlink" title="缓冲区空, 且没有等待发送协程, 阻塞接收"></a>缓冲区空, 且没有等待发送协程, 阻塞接收</h4><p><img src="/img/Pasted%20image%2020230522223219.png"><br>没有协程在休眠等待, 而且没有缓存或者缓存为空<br>自己进入接受队列, 休眠等待<br>实现:</p><ol><li>判断没有协程在发送队列等待</li><li>判断此Channel无缓存</li><li>把自己包装成sudog</li><li>sudog放入接收等待队列, 休眠</li><li>唤醒时, 发送的G已经把数据拷贝到位</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>编译阶段，&lt;-c会转化为chanrecv()</li><li>有等待的G,且无缓存时，从G接收</li><li>有等待的G,且有缓存时，从缓存接收</li><li>无等待的G,且缓存有数据，从缓存接收</li><li>无等待的G,且缓存无数据，等待喂数据</li></ul><h2 id="非阻塞channel"><a href="#非阻塞channel" class="headerlink" title="非阻塞channel"></a>非阻塞channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- chan1:<br><span class="hljs-comment">// 如果chan1成功读到数据, 则执行该case处理语句</span><br><span class="hljs-keyword">case</span> chan2 &lt;- <span class="hljs-number">1</span>:<br><span class="hljs-comment">// 如果成功向chan2写入数据, 则执行该case处理语句</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 如果上面都没有成功, 则进入default处理流程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Select遇到多个case就绪时, 选择哪个case执行时随机的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> time.Tick(<span class="hljs-number">1</span> * time.Second) &#123;<br>ch &lt;- <span class="hljs-number">0</span><br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;case1&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-ch:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;case2&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>case1<br>case2<br>case1<br>...<br></code></pre></td></tr></table></figure><h3 id="select原理"><a href="#select原理" class="headerlink" title="select原理"></a>select原理</h3><ul><li>同时存在接收&#x2F;发送&#x2F;默认路径</li><li>首先查看是否有可以立即执行的case</li><li>没有的话, 有default, 走default</li><li>没有default, 把自己注册在所有的channel中, 休眠等待; 等待其中一个case发生就会被唤醒</li></ul><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><ul><li>timer可以提供一个channel, 定时塞入数据<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">t := time.NewTimer(time.Second) <span class="hljs-comment">// 1s后向channel放入数据</span><br>&lt;-t.C <span class="hljs-comment">// 阻塞等待数据</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><h2 id="为什么使用Channel"><a href="#为什么使用Channel" class="headerlink" title="为什么使用Channel"></a>为什么使用Channel</h2><ul><li>相对于无锁, 避免协程竞争和数据冲突的问题</li><li>相对于加锁, 更高级的抽象，降低开发难度，增加程序可读性; 模块之间更容易解耦，增强扩展性和可维护性</li></ul><h2 id="Channel的基本结构"><a href="#Channel的基本结构" class="headerlink" title="Channel的基本结构"></a>Channel的基本结构</h2><ul><li>一个环形缓存</li><li>两个链表（发送协程&#x2F;接收协程）</li><li>一个互斥锁（保护hchan)</li><li>一个状态值</li></ul><h2 id="Channel数据发送原理"><a href="#Channel数据发送原理" class="headerlink" title="Channel数据发送原理"></a>Channel数据发送原理</h2><ul><li>直接发送时，将数据直接拷贝到目标变量</li><li>放入缓存时，将数据放入环形缓存，成功返回</li><li>休眠等待时，将自己包装后放入sendq, 休眠</li></ul><h2 id="Channel数据接收原理"><a href="#Channel数据接收原理" class="headerlink" title="Channel数据接收原理"></a>Channel数据接收原理</h2><ul><li>有等待的协程, 且无缓存时，从协程接收</li><li>有等待的协程, 且有缓存时，从缓存接收</li><li>无等待的协程, 且缓存有数据，从缓存接收</li><li>无等待的协程, 且缓存无数据，等待喂数据</li></ul><h2 id="非阻塞Channel"><a href="#非阻塞Channel" class="headerlink" title="非阻塞Channel"></a>非阻塞Channel</h2><ul><li>使用select可以使用Channel的非阻塞特性</li><li>使用timer配合select可以实现超时特性</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go中的锁</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁的基础是什么"><a href="#锁的基础是什么" class="headerlink" title="锁的基础是什么"></a>锁的基础是什么</h1><h3 id="atomic-操作"><a href="#atomic-操作" class="headerlink" title="atomic 操作"></a>atomic 操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i ++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *<span class="hljs-type">int32</span>)</span></span> &#123;<br>*p ++;<br>&#125;(&amp;c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230521162404.png"><br>结果大概率不会到1000<br>使用atomic操作就可以稳定在1000</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i ++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *<span class="hljs-type">int32</span>)</span></span> &#123;<br><span class="hljs-comment">// 汇编实现, 里面用到了LOCK指令(硬件锁)</span><br>atomic.AddInt32(p, <span class="hljs-number">1</span>); <br>&#125;(&amp;c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>原子操作是一种硬件层面加锁机制</li><li>保证操作一个变量的时候, 其它协程&#x2F;线程无法访问</li><li>只能用于简单变量的简单操作</li></ul><h3 id="sema锁"><a href="#sema锁" class="headerlink" title="sema锁"></a>sema锁</h3><ul><li>信号量锁&#x2F;信号锁</li><li>核心是一个uint32值, 含义是同时可并发的数量</li><li>每一个 sema锁都对应一个SemaRoot结构体</li><li>SemaRoot中有一个平衡二叉树用于协程排队<br><img src="/img/Pasted%20image%2020230521164239.png"></li></ul><h4 id="sema操作-uint32-0"><a href="#sema操作-uint32-0" class="headerlink" title="sema操作(uint32&gt;0)"></a>sema操作(uint32&gt;0)</h4><ul><li>获取锁 uint32-1, 获取成功</li><li>释放锁 uint32+1, 释放成功</li></ul><h4 id="sema操作-uint32-0-1"><a href="#sema操作-uint32-0-1" class="headerlink" title="sema操作(uint32==0)"></a>sema操作(<code>uint32==0</code>)</h4><ul><li>获取锁 协程休眠 进入堆树等待</li><li>释放锁 从堆树中取出一个协程, 唤醒 </li><li>sema锁 退化成一个专门休眠的队列</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>原子操作是一种硬件层面加锁的机制</li><li>数据类型和操作类型有限制</li><li>sema锁是runtime的常用工具</li><li>sema经常被用作休眠队列</li></ul><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>讲解更好: <a href="https://juejin.cn/post/7129806718816485406">https://juejin.cn/post/7129806718816485406</a><br>sync.Mutex的结构<br><img src="/img/Pasted%20image%2020230521165513.png"><br>![[Pasted image 20230728151907.png]]<br>sema地址hash后在semtable中找到semroot</p><h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><ul><li>尝试CAS直接加锁</li><li>若无法直接获取, 进行多次自旋尝试</li><li>多次尝试失败, 进入sema队列休眠<br><img src="/img/Pasted%20image%2020230521165721.png"><br>未获得锁的多次自旋尝试获取锁, 多次自旋失败之后, 就会休眠自己, 然后记录到平衡二叉树下<br><img src="/img/Pasted%20image%2020230521165827.png"><br><img src="/img/Pasted%20image%2020230521165934.png"><br> 再有协程来试图获取锁, 自旋多次失败后就会加入到等待树中<br> <img src="/img/Pasted%20image%2020230521170053.png"><br> 对state的locked字段设置是通过CAS操作完成的</li></ul><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><ul><li>尝试CAS直接解锁 </li><li>若发现有协程在sema中休眠, 唤醒一个协程</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>mutex正常模式下: 自旋加锁 + sema休眠等待</li><li>mutex正常模式下, 可能有锁饥饿的问题</li></ul><h2 id="锁饥饿"><a href="#锁饥饿" class="headerlink" title="锁饥饿"></a>锁饥饿</h2><ul><li>当前协程等待锁的时间超过了1ms, 切换到饥饿模式</li><li>饥饿模式中, 不自旋, 新来的协程直接sema休眠</li><li>饥饿模式中, 被唤醒的协程直接获取锁</li><li>没有协程在队列中继续等待时, 回到正常模式</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>锁竞争严重时, 互斥锁进入饥饿模式</li><li>界模式没有自旋等待, 有利于公平</li></ul><h3 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h3><ul><li>减少锁的使用时间(细粒度锁)</li><li>善用defer确保锁的释放</li></ul><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><h2 id="多个协程同时只读"><a href="#多个协程同时只读" class="headerlink" title="多个协程同时只读"></a>多个协程同时只读</h2><p>只读时</p><ul><li>让其他人不能修改即可</li><li>多协程可以共享读</li><li>不需要互斥锁</li></ul><h2 id="读写锁需求"><a href="#读写锁需求" class="headerlink" title="读写锁需求"></a>读写锁需求</h2><ul><li>每个锁分为读锁和写锁，写锁互斥</li><li>没有加写锁时，多个协程都可以加读锁</li><li>加了写锁时，无法加读锁，读协程排队等待</li><li>加了读锁, 写锁排队等待</li></ul><h2 id="实现读写锁"><a href="#实现读写锁" class="headerlink" title="实现读写锁"></a>实现读写锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>w Mutex <span class="hljs-comment">// 写锁</span><br>writerSem <span class="hljs-type">uint32</span> <span class="hljs-comment">// 作为写协程队列</span><br>readerSem <span class="hljs-type">uint32</span> <span class="hljs-comment">// 作为读协程队列</span><br>readerCount <span class="hljs-type">int32</span> <span class="hljs-comment">// 正值: 正在读的协程 负值:加了写锁</span><br>readerWait <span class="hljs-type">int32</span> <span class="hljs-comment">// 写锁应该等待读协程个数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230521175918.png"></p><h3 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h3><ul><li>加写锁, 没有读协程<br>加互斥锁 w, 才有加写锁的资格,  readerCount变为-rwmutexMaxReaders(1 &lt;&lt; 30 )<br><img src="/img/Pasted%20image%2020230521180251.png"></li><li>加写锁: 有读协程<br>加互斥锁 w, 才有加写锁的资格,  readerCount变为3-rwmutexMaxReaders(1 &lt;&lt; 30 ); 表示加了写锁, 但还有三个读协程没有完成, readerWait从3变为0, 才可以加上写锁<br><img src="/img/Pasted%20image%2020230521180720.png"></li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li>先加mutex写锁, 若已经被加写锁会阻塞等待</li><li>将readerCount变为负值, 阻塞读锁的获取</li><li>计算需要等待多少个读协程释放</li><li>如果需要等待读协程释放, 陷入writerSem</li></ul><h3 id="解写锁"><a href="#解写锁" class="headerlink" title="解写锁"></a>解写锁</h3><p><img src="/img/Pasted%20image%2020230521181146.png"><br><img src="/img/Pasted%20image%2020230521181322.png"></p><ul><li>将readerCount变为正值, 允许读锁的获取</li><li>释放在readerSem中等待的读协程</li><li>解锁mutex</li></ul><h3 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h3><ul><li>readerCount &gt; 0<br>没有写锁, 直接加readerCount, 去读即可</li><li>readerCount &lt; 0<br>有写锁, 给readerCount + 1, 去读队列readerSem排队</li></ul><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul><li>给readerCount 无脑 + 1</li><li>如果加完之后readerCount是正数, 加锁成功</li><li>如果加完之后readerCount是负数, 说明被加了写锁, 陷入readerSem</li></ul><h3 id="解读锁"><a href="#解读锁" class="headerlink" title="解读锁"></a>解读锁</h3><ul><li>readerCount &gt; 0<br>readerCount - 1即可</li><li>readerCount &lt; 0<br>readerCount - 1, readerWait - 1<br>如果readerWait &#x3D; 0, 写锁就可以加上了</li></ul><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>给readerCount 无脑 - 1</li><li>如果readerCount是正数, 解锁成功</li><li>如果readerCount是负数, 有写锁在排队<ul><li>如果是readerWait的最后一个, 唤醒写协程</li></ul></li></ul><h2 id="使用经验-1"><a href="#使用经验-1" class="headerlink" title="使用经验"></a>使用经验</h2><ul><li>RW锁适合读多写少的场景, 减少锁冲突</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul><li>Mutex用来写协程之间互斥等待</li><li>读协程使用readerSem等待写锁的释放</li><li>写协程使用writerSem等待读锁的释放</li><li>readerCount记录读协程个数</li><li>readerWait记录写协程之前的读协程个数</li></ul><h1 id="相互等待-WaitGroup"><a href="#相互等待-WaitGroup" class="headerlink" title="相互等待 - WaitGroup"></a>相互等待 - WaitGroup</h1><p>一个(组)协程需要等待另一组协程完成<br><img src="/img/Pasted%20image%2020230521184025.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;<br>noCopy noCopy <span class="hljs-comment">// 特殊的结构体, 表示该结构体不能被拷贝  </span><br>state1 [<span class="hljs-number">3</span>]<span class="hljs-type">uint32</span> <span class="hljs-comment">// counter, waiter counter, sema</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230521205001.png"></p><h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h2><ul><li>如果被等待的协程没了, 直接返回</li><li>否则, waiter + 1, 陷入sema</li></ul><h2 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h2><ul><li>被等待协程做完, 给counter - 1</li><li>通过<code>wg.Add(-1)</code>实现</li></ul><h2 id="Add"><a href="#Add" class="headerlink" title="Add()"></a>Add()</h2><ul><li>add counter</li><li>被等待协程没做完, 或者没人在等待, 返回</li><li>被等待协程都做完, 且有人等待, 唤醒所有sema中的协程</li></ul><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><ul><li>WaitGroup:实现了一组协程等待另一组协程等待的协程</li><li>陷入sema并记录个数</li><li>被等待的协程计数归零时，唤醒所有sema中的协程</li></ul><h1 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h1><p>整个程序运行过程中, 代码只执行一次<br>用来进行一些初始化的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用</span><br>once := sync.Once&#123;&#125;<br><span class="hljs-keyword">go</span> once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;&#125;)<br><br><span class="hljs-comment">// 实现</span><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>done <span class="hljs-type">uint32</span><br>m Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>o.m.Lock()<br><span class="hljs-keyword">defer</span> o.m.Unlock()<br><span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>f()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先判断是否已经改值</li><li>没改, 尝试获取锁</li><li>获取到锁的协程执行业务, 改值, 解锁</li><li>冲突协程唤醒后直接返回</li></ul><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul><li>sync.Once实现了一段代码只执行一次</li><li>使用标志+mutex:实现了并发冲突的优化</li></ul><h1 id="锁常见问题"><a href="#锁常见问题" class="headerlink" title="锁常见问题"></a>锁常见问题</h1><h2 id="锁拷贝"><a href="#锁拷贝" class="headerlink" title="锁拷贝"></a>锁拷贝</h2><ul><li>锁拷贝可能导致锁的死锁问题</li><li>使用vet工具可以检测锁拷贝问题</li><li>vet还能检测可能的bug或者可疑的构造</li></ul><h2 id="RACE竞争检测"><a href="#RACE竞争检测" class="headerlink" title="RACE竞争检测"></a>RACE竞争检测</h2><ul><li>发现隐含的数据竞争问题</li><li>可能是加锁的建议</li><li>可能是bug的提醒</li></ul><h2 id="go-deadlock检测"><a href="#go-deadlock检测" class="headerlink" title="go-deadlock检测"></a>go-deadlock检测</h2><ul><li>检测可能的死锁</li><li>实际是检测获取锁的等待时间</li><li>用来排查bug和性能问题</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的协程</title>
    <link href="/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/09/02/Go%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要有协程"><a href="#为什么要有协程" class="headerlink" title="为什么要有协程"></a>为什么要有协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>操作系统程序的最小单位</li><li>进程用来占用内存空间</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>每个进程可以有多个线程</li><li>线程使用系统分配给进程的内存, 线程之间共享内存</li><li>线程用来占用CPU时间</li><li>线程的调度需要由系统进行, 开销较大</li></ul><h3 id="线程的问题"><a href="#线程的问题" class="headerlink" title="线程的问题"></a>线程的问题</h3><ul><li>线程本身占用资源大</li><li>线程的操作开销大</li><li>线程切换开销大</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>协程就是将一段程序的运行状态打包, 可以在线程之间调度</li><li>将生产流程打包, 使得流程不固定在生产线上</li><li>协程并不取代线程, 协程也要放在线程上运行</li><li>线程是协程的资源, 协程使用线程这个资源</li></ul><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><ul><li>资源利用</li><li>快速调度</li><li>超高并发</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>进程用于分配内存空间</li><li>线程用来分配CPU空间</li><li>协程用来精细利用线程</li><li>协程的本质是一段包含了运行状态的程序</li></ul><h2 id="协程的本质"><a href="#协程的本质" class="headerlink" title="协程的本质"></a>协程的本质</h2><p>协程在Go语言中的本质就是一个g结构体(位于runtime2.go). </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>stack stack <span class="hljs-comment">// 栈信息</span><br><span class="hljs-comment">// ...</span><br>sched gobuf <span class="hljs-comment">// 目前程序运行现场</span><br>atomicstatus <span class="hljs-type">uint32</span> <span class="hljs-comment">// 协程状态</span><br>goid <span class="hljs-type">int64</span> <span class="hljs-comment">// 协程的ID号  </span><br>&#125;<br><br><span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;<br>lo <span class="hljs-type">uintptr</span><br>hi <span class="hljs-type">uintptr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// stack pointer, 栈指针, 指向栈用到了什么地方</span><br>sp <span class="hljs-type">uintptr</span><br><span class="hljs-comment">// program counter, 程序计数器, 运行到了哪条代码</span><br>pc <span class="hljs-type">uintptr</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230520222112.png"><br>协程如何描述(runtime2.go下的struct m)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-keyword">go</span> *g <span class="hljs-comment">// go语言第一个协程, 操作调度器</span><br>curg *g <span class="hljs-comment">// 正在运行的协程</span><br>mOS <span class="hljs-comment">// 针对操作系统所记录的线程信息(os_linux / windows / darwin ...)</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协程如何执行"><a href="#协程如何执行" class="headerlink" title="协程如何执行"></a>协程如何执行</h2><h3 id="单线程循环-Go-0-x"><a href="#单线程循环-Go-0-x" class="headerlink" title="单线程循环(Go 0.x)"></a>单线程循环(Go 0.x)</h3><p><img src="/img/Pasted%20image%2020230520222715.png"><br><img src="/img/Pasted%20image%2020230520223748.png"></p><h3 id="多线程循环-Go-1-0"><a href="#多线程循环-Go-1-0" class="headerlink" title="多线程循环(Go 1.0)"></a>多线程循环(Go 1.0)</h3><p><img src="/img/Pasted%20image%2020230520223924.png"><br><img src="/img/Pasted%20image%2020230520224057.png"></p><h3 id="线程循环"><a href="#线程循环" class="headerlink" title="线程循环"></a>线程循环</h3><ul><li>操作系统并不知道Goroutine的存在</li><li>操作系统线程执行一个调度循环(Go代码或者会变组成)，顺序执行Goroutine</li><li>调度循环非常像线程池<br>问题:</li><li>协程顺序执行, 无法并发</li><li>多线程并发时, 会抢夺协程队列的全局锁</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>协程的本质是一个g结构体</li><li>结构体记录了协程栈、PC信息</li><li>最简情况下，线程执行标准调度循环，执行协程</li></ul><h2 id="G-M-P调度模型"><a href="#G-M-P调度模型" class="headerlink" title="G-M-P调度模型"></a>G-M-P调度模型</h2><p>前序的调度像是本地队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>m muintptr <span class="hljs-comment">// 指向相关的线程, 服务于一个线程</span><br><span class="hljs-comment">// 可执行的协程队列, 可无锁访问</span><br>runqhead <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队头</span><br>runqtail <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队尾</span><br>runq [<span class="hljs-number">256</span>]guintptr<br>runnext guintptr <span class="hljs-comment">// 下一个可用的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230520224937.png"><br><img src="/img/Pasted%20image%2020230520225028.png"><br>如果本地协程执行完成, 获取全局的锁, 取全局拉取协程<br><img src="/img/Pasted%20image%2020230520225134.png"></p><h3 id="P的作用"><a href="#P的作用" class="headerlink" title="P的作用"></a>P的作用</h3><ul><li>M与G之间的中介(送料器)</li><li>P持有一些G, 使得每次获取G的时候不用从全局找</li><li>大大减少了并发冲突的情况</li></ul><h3 id="任务窃取"><a href="#任务窃取" class="headerlink" title="任务窃取"></a>任务窃取</h3><p>本地(m)和全局的携程队列都没有任务, 可以去别的p中获取, 增加了线程利用率<br><img src="/img/Pasted%20image%2020230520225828.png"><br><img src="/img/Pasted%20image%2020230520225846.png"></p><h3 id="新建协程"><a href="#新建协程" class="headerlink" title="新建协程"></a>新建协程</h3><ul><li>随机寻找一个P</li><li>将新协程放入P的runnext(插队)</li><li>如果P本地队列满, 放入全局队列</li></ul><p>GMP模型减少了全局协程队列锁的获取</p><h2 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h2><h3 id="协程的饥饿问题"><a href="#协程的饥饿问题" class="headerlink" title="协程的饥饿问题"></a>协程的饥饿问题</h3><p><img src="/img/Pasted%20image%2020230520230310.png"><br>长协程会长期占用M, 导致其它饥饿 </p><h3 id="线程循环-触发切换"><a href="#线程循环-触发切换" class="headerlink" title="线程循环(触发切换)"></a>线程循环(触发切换)</h3><p><img src="/img/Pasted%20image%2020230520230549.png"><br> <img src="/img/Pasted%20image%2020230520230648.png"><br> 但全局队列可能会存在饥饿问题, 通过再添加一层循环解决.<br> 以一定的概率, 从全局队列拿任务到M中(代码中是每执行61次)<br> <img src="/img/Pasted%20image%2020230520230814.png"></p><h3 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h3><ul><li>主动挂起(runtime.gopark)<br><img src="/img/Pasted%20image%2020230520231107.png"><br>time.Sleep中会包含gopark操作</li><li>系统调用完成时<br><img src="/img/Pasted%20image%2020230520231320.png"></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>如果协程顺序执行，会有饥饿问题</li><li>协程执行中间，将协程挂起，执行其他协程</li><li>完成系统调用时挂起，也可以主动挂起</li><li>防止全局队列饥饿，本地队列随机抽取全局队列<br>永远不主动挂起, 也不系统调用, 如何处理?</li></ul><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><ul><li>有没有一个地方, 经常会被调用</li><li>涉及到调用其他方法都会调用 runtime.morestak()</li><li>morestack的本意是检查协程栈知否有足够的空间</li><li>调用方法时, 会被编译器插入morestack()</li></ul><h3 id="标记抢占"><a href="#标记抢占" class="headerlink" title="标记抢占"></a>标记抢占</h3><ul><li>系统检测到Goroutine运行超过10ms</li><li>将g.stackguard0置为0xfffffade</li></ul><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ul><li>执行morestack()时判断是否被抢占</li><li>如果被抢占, 回到schedule()</li><li>基于协作的抢占式调度<br><img src="/img/Pasted%20image%2020230521141053.png" alt="基于协作的抢占式调度"></li><li>如果任何函数调用(没有morestack), 则使用基于信号的抢占式调度</li></ul><h3 id="线程信号"><a href="#线程信号" class="headerlink" title="线程信号"></a>线程信号</h3><ul><li>操作系统中, 有很多基于信号的底层通信方式 eg. SIGPIPE &#x2F; SIGURG &#x2F; SIGHUP</li><li>线程可以注册对应信号的处理函数</li></ul><h3 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h3><ul><li>注册SIGURG信号的处理函数 </li><li>GC工作时, 向目标线程发送信号</li><li>线程收到信号, 会发生调度<br><img src="/img/Pasted%20image%2020230521141748.png"></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>基于系统调用和主动挂起，协程可能无法调度</li><li>基于<strong>协作</strong>的抢占式调度：业务主动调用morestack()</li><li>基于<strong>信号</strong>的抢占式调度：强制线程调用doSigPreempt()</li></ul><h2 id="协程开太多会怎么样"><a href="#协程开太多会怎么样" class="headerlink" title="协程开太多会怎么样"></a>协程开太多会怎么样</h2><p><code>panic: too many concurrent operations on a single file or socket (max 1048575)</code></p><ul><li>文件打开数限制</li><li>内存限制</li><li>调度开销过大</li></ul><h3 id="处理协程太多的方案"><a href="#处理协程太多的方案" class="headerlink" title="处理协程太多的方案"></a>处理协程太多的方案</h3><ul><li>优化业务逻辑</li><li>利用channel缓冲区(限制总数)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(i <span class="hljs-type">int</span>, ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>fmt.Println(i)<br>time.Sleep(time.Second)<br>&lt;- ch<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">3000</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; math.MaxInt32; i++ &#123;<br>c &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">go</span> do(i, c)<br>&#125;<br>time.Sleep(time.Hour)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>协程池(tunny)<br><img src="/img/Pasted%20image%2020230521151714.png"><ul><li>预创建一定数量的协程</li><li>将任务送入协程池队列</li><li>协程池不断取出可用协程, 执行任务</li><li>Go语言的线程, 已经相当于池化了</li><li>二级池化会增加系统复杂度</li><li>Go语言的初衷是希望协程即用即毁, 不要池化</li></ul></li><li>调整系统资源</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>太多的协程会给程序运行带来性能和稳定性问题</li><li>牺牲并发特性，利用channel缓冲</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><h3 id="为什么用协程"><a href="#为什么用协程" class="headerlink" title="为什么用协程"></a>为什么用协程</h3><ul><li>协程用来精细利用线程</li><li>协程可以支撑超高并发</li></ul><h3 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h3><ul><li>从runtime的角度看，协程是一个可以被调度的g结构体</li><li>从线程的角度看，协程是一段程序，自带执行现场</li></ul><h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><ul><li>通过P结构体，达成了缓存部分G的目的</li><li>P本质上是一个G的本地队列，避免全局并发等待</li><li>窃取式工作分配机制能够更加充分利用线程资源</li></ul><h3 id="协程并发-1"><a href="#协程并发-1" class="headerlink" title="协程并发"></a>协程并发</h3><ul><li>如果协程顺序执行，会有饥饿问题</li><li>协程执行中间，将协程挂起，执行其他协程</li><li>完成系统调用时挂起，也可以主动挂起</li><li>防止全局队列饥饿，本地队列随机抽取全局队列</li></ul><h3 id="抢占式调度-1"><a href="#抢占式调度-1" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><ul><li>基于系统调用和主动挂起，协程可能无法调度</li><li>基于<strong>协作</strong>的抢占式调度：业务主动调用morestack()</li><li>基于<strong>信号</strong>的抢占式调度：强制线程调用doSigPreempt()</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
      <tag>Goroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的包管理方式</title>
    <link href="/2023/09/01/Go%E4%B8%AD%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/09/01/Go%E4%B8%AD%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><p>本质上, 一个Go包就是一个项目的原码<br>gomod的作用: 将Go包和Git项目关联起来<br>Go包的版本就是git项目的Tag<br>gomod就是解决”需要哪个git项目的什么版本”</p><h2 id="使用Modules"><a href="#使用Modules" class="headerlink" title="使用Modules"></a>使用Modules</h2><ul><li>github.com&#x2F;Jeffail&#x2F;tunny<br><code>go get github.com/Jeffail/tunny</code><br><code>go get github.com/Jeffail/tunny@0.1.3</code></li></ul><h2 id="用本地文件替代"><a href="#用本地文件替代" class="headerlink" title="用本地文件替代"></a>用本地文件替代</h2><ul><li>go.mod 文件追加<br>replace  github.com&#x2F;Jeffail&#x2F;tunny &#x3D;&gt; xxx&#x2F;xxx</li><li>go vender 缓存到本地<br>go mod vendor<br>go build -mod vendor</li></ul><h2 id="创建Go-module"><a href="#创建Go-module" class="headerlink" title="创建Go module"></a>创建Go module</h2><p>创建go.mod即可</p><ul><li>删除本地的go.mod<br><code>go mod init github.com/bing-zhub/xxx</code></li><li>推送至代码仓库</li><li>增加新版本时, 在仓库打新Tag</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的数据结构</title>
    <link href="/2023/09/01/Go%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/09/01/Go%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="基本类型的字节数"><a href="#基本类型的字节数" class="headerlink" title="基本类型的字节数"></a>基本类型的字节数</h2><p>可以用Unsafe.Sizeof查看任何变量的字节大小</p><ul><li>int大小跟随系统字长</li><li>指针的大小也是系统字长</li></ul><h2 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h2><p>空结构体大小为0<br>但有地址, 但所有的空结构体(独立出现, 没有被其它struct引用)都指向同一地址(zerobase, 0x8a82f8)<br>当被内嵌在其它struct中, 地址不是zerobase<br>空结构体主要是为了节约内存,<br>比如使用map实现hashset </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// value 不占任何空间</span><br>hashSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>hashSet[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br></code></pre></td></tr></table></figure><p>比如用channel传输信号, 不想携带任何信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串本质上是个结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer<br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对string取Sizeof的时候, 取的是指针大小.<br>Data指针指向底层Byte数组<br>len表示byte数组的长度, 编码不同, 字符的个数也不同(UTF8下, 一个字符占三个字节)</p><h3 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h3><p>所有字符都是用Unicode字符集,使用UTF-8编码</p><ul><li>Unicode字符集<br>一种统一的字符集, 包含了绝多数文字的绝大多数字符, 14w个字符, 至少需要3字节(2^24)才能表示<br>英文字母排在前128个</li><li>UTF-8编码<br>Unicode的一种变长格式<br>128个US-ASCII字符只需一个字节编码<br>西方常用字符需要两个字节<br>其他字符3个字节, 极少4个字节</li></ul><h3 id="字符串遍历"><a href="#字符串遍历" class="headerlink" title="字符串遍历"></a>字符串遍历</h3><p>自动判断多个字节是不是一个字符的不同部分(runtime下的utf8.go实现, rune就是UTF-8编码)<br>字符串被range遍历的时候, 被解码成rune类型的字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;中国科学院&quot;</span><br><span class="hljs-comment">// 这样不正确</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;  <br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, s[i])  <br>&#125;<br><span class="hljs-comment">// 正确方式</span><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, c)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><ol><li>转为rune数组</li><li>切片</li><li>转为string<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s = <span class="hljs-type">string</span>([]<span class="hljs-type">rune</span>(s)[:<span class="hljs-number">3</span>]) <span class="hljs-comment">// 取前三个汉字</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>是一个结构体<br>切片的本质是对数组的引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>  array unsafe.Pointer<br>  <span class="hljs-built_in">len</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 长度</span><br>  <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 总容量</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片创建"><a href="#切片创建" class="headerlink" title="切片创建"></a>切片创建</h3><ul><li>根据数组创建<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">arr[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br>slice[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li><li>字面量创建: 编译时插入创建数组的代码<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></li><li>make: 运行时创建数组<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><ul><li>不扩容时, 只调整len(编译器负责)</li><li>扩容时, 编译时转为调用runtime.growslice()<br><code>&lt; 1024</code>的时候, 二倍增长, 将原数据复制过来.<br><code>&gt; 1024</code>的时候, 每次增加25%<br>切片扩容时, 并发不安全, 注意切片并发需要加锁</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>字符串与切片都是对底层数组的引用</li><li>字符串有UTF-8变长编码的特点</li><li>切片的容量和长度不同</li><li>切片追加时, 可能需要重新创建底层数组</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li>开放寻址法</li><li>拉链法<br><img src="/img/20230510221809.png" alt="20230510221809.png"><br>Go语言的map使用的是拉链法, 在<code>runtime.hmap</code>中, hmap被定义为<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>count <span class="hljs-type">int</span><br>flags <span class="hljs-type">uint8</span><br>B <span class="hljs-type">uint8</span><br>nooverflow <span class="hljs-type">uint16</span><br>hash0 <span class="hljs-type">uint32</span><br><br>buckets unsafe.Pointer<br>oldbuckets unsafe.Pointer<br>nevacuate <span class="hljs-type">uintptr</span><br>extra *mapextra<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/20230510222352.png" alt="20230510222352.png"><br><code>2^B</code>个bucket, b map is a bucket for a Go map<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// bucketCntBits = 3</span><br><span class="hljs-comment">// bucketCnt = 1 &lt;&lt; bucketCntBits</span><br>  tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="map的初始化"><a href="#map的初始化" class="headerlink" title="map的初始化"></a>map的初始化</h3><ul><li>make<br><code>m := make(map[string]int, 10)</code><br><img src="/img/20230510223101.png" alt="20230510223101.png"></li><li>字面量<br>元素少于25个时, 转化为简单赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-number">6</span>,<br>&#125;<br><span class="hljs-comment">// 转化为</span><br>hash := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br>hash[<span class="hljs-string">&quot;1&quot;</span>] = <span class="hljs-number">2</span><br>hash[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-number">4</span><br>hash[<span class="hljs-string">&quot;5&quot;</span>] = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>元素多于25个时, 转化为循环赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br><span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-number">1</span><br><span class="hljs-string">&quot;2&quot;</span> : <span class="hljs-number">2</span> <br>...<br><span class="hljs-string">&quot;26&quot;</span>: <span class="hljs-number">26</span><br>&#125;<br><span class="hljs-comment">// 转化为</span><br>hash := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>vstatk := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, ... , <span class="hljs-string">&quot;26&quot;</span>&#125;<br>vstatv := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ..., <span class="hljs-number">26</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(vstak); i++ &#123;<br>hash[vstatk[i]] = vstatk[i]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="map的访问"><a href="#map的访问" class="headerlink" title="map的访问"></a>map的访问</h3><ol><li>计算桶号<br><img src="/img/20230510224041.png" alt="20230510224041.png"></li><li>计算tophash<br><img src="/img/20230510223911.png" alt="20230510223911.png"></li><li>匹配<br> <img src="/img/20230510224212.png" alt="20230510224212.png"><br> 从第二个桶中找到tophash等于0x5c的kv, 看k是不是我们想要的, 如果是则返回v.<br> 如果碰撞, 继续线性查找, 如果该bucket也没有, 则去查找溢出桶, 如果都没有则该k不存在.<blockquote><p>写入也类似</p></blockquote></li></ol><h3 id="map扩容"><a href="#map扩容" class="headerlink" title="map扩容"></a>map扩容</h3><p>当hash碰撞过多的时候, 溢出桶数量增加, 会退化成一个链表<br><img src="/img/20230510224803.png" alt="20230510224803.png"><br>map溢出桶太多会导致严重的性能下降<br>runtime.mapassign()可能会触发扩容的情况</p><ol><li>装载因子超过6.5(品骏每个槽6.5个key)</li><li>使用了太多溢出桶(溢出桶超过了普通桶)</li></ol><h4 id="map的扩容类型"><a href="#map的扩容类型" class="headerlink" title="map的扩容类型"></a>map的扩容类型</h4><ul><li>等量扩容<br>数据不多但是溢出桶太多了(整理)</li><li>翻倍扩容<br>数据太多了</li></ul><p>扩容步骤</p><ol><li>创建一组新桶</li><li>oldbuckets指向原有的桶数组</li><li>buckets指向新的桶数组</li><li>map标记为扩容状态</li><li>将所有的数据从旧桶驱逐到新桶</li><li>采用渐进式驱逐</li><li>每次操作一个旧桶时, 将旧桶数据驱逐到新桶</li><li>读取时不进行驱逐, 只判断读取新桶还是旧桶</li><li>所有的旧桶驱逐完成后</li><li>oldbuckets回收</li></ol><h4 id="map的并发"><a href="#map的并发" class="headerlink" title="map的并发"></a>map的并发</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>_ = m[<span class="hljs-number">1</span>]<br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>m[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>&#125;<br>&#125;()<br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无法编译<code>fatal error: concurrent map read and map write</code><br>A协程在桶中读数据时, B协程驱逐了这个桶, 那么A协程就会读到错误的数据或者找不到数据<br><img src="/img/20230511203607.png" alt="20230511203607.png"><br>解决方案</p><ul><li>给map加锁(mutex)</li><li>使用sync.Map<br><img src="/img/20230511203912.png" alt="20230511203912.png"><br>追加”d”:D<br><img src="/img/20230511204247.png" alt="20230511204247.png"><br>追加后的读写(misses ++ ), 先去read没有找到d, amended为true, 去dirty查找, 找到对应kv, misses ++<br><img src="/img/20230511204503.png" alt="20230511204503.png"><br>dirty提升, <code>misses = len(dirty)</code>时, dirty提升为read的m, 置回初始状态<br><img src="/img/20230511210918.png" alt="20230511210918.png"><br>删除操作</li><li>正常删除<br><img src="/img/20230511211202.png" alt="20230511211202.png"><br>k置成nil后, GC会自动将v回收</li><li>追加后删除<br><img src="/img/20230511211420.png" alt="20230511211420.png"><br>后面需要提升的话, 要特殊处理<br><img src="/img/20230511211556.png" alt="20230511211556.png"><br>提升后被删key还需要特殊处理<br>不是读写分离, 而是普通读写和追加分离</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>Go语言使用拉链实现了hashmap</li><li>每一个桶中存储键哈希的前8位</li><li>桶超出8个数据, 就会存储到溢出桶中</li><li>装载系数或者溢出桶的增加, 会触发map扩容</li><li>扩容可能并不是增加桶数, 而是整理</li><li>map扩容采用渐进式, 桶被操作时才会重新分配</li><li>map才扩容的时候会有并发问题</li><li>sync.Map使用了两个Map, 分离了扩容问题</li><li>不会引发扩容的操作(查 改)使用read map</li><li>会引发扩容的操作(新增)使用dirty map</li><li>读多写多, 追加少的时候性能好</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口显式好还是隐式好?</p><h3 id="Go隐式接口特点"><a href="#Go隐式接口特点" class="headerlink" title="Go隐式接口特点"></a>Go隐式接口特点</h3><ul><li>只要实现了接口的全部方法, 就是自动实现接口</li><li>可以在不修改代码的情况下抽象出新的接口</li></ul><h3 id="接口的底层表示"><a href="#接口的底层表示" class="headerlink" title="接口的底层表示"></a>接口的底层表示</h3><p>底层使用<code>runtime.iface</code>表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span>&#123; <br>tab *itab <span class="hljs-comment">// 接口类型, 接口装载的类型, 实现了哪些方法</span><br>data unsafe.Pointer <span class="hljs-comment">// 指向结构体(数据)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><ul><li>类型断言是一个使用在接口值上的操作</li><li>可以将接口值转换为其它类型值(实现或者兼容接口)</li><li>还可以配合switch 进行类型判断<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c Car = Truck&#123;&#125;<br>t := c.(Truck)<br></code></pre></td></tr></table></figure>接受者为结构体的时候, 会自动添加一个接受者为指针的方法; 但如果用结构体指针实现了方法, 只会存在指针的.<br><img src="/img/20230511222155.png" alt="20230511222155.png"></li></ul><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>是eface<br>可以承载任何类型.<br>底层不是普通接口</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>作为任意类型的函数入参</li><li>函数调用的时候, 会新生成一个空接口, 再传参</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>Go的隐式接口更方便系统的扩展和重构</li><li>接口提和指针都可以实现接口</li><li>空接口值可以称在任何类型的数据</li></ul><h2 id="nil-空接口-空结构体"><a href="#nil-空接口-空结构体" class="headerlink" title="nil 空接口 空结构体"></a>nil 空接口 空结构体</h2><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><ul><li>nil是空, 但不一定是空指针</li><li>是pointer, channel, func, interface, map, slice其中之一的零值</li><li>每种类型的nil是不同的, 无法比较</li></ul><h3 id="空结构体-1"><a href="#空结构体-1" class="headerlink" title="空结构体"></a>空结构体</h3><ul><li>空结构体是Go中非常特殊的类型</li><li>空结构体的值不是nil</li><li>空结构体的指针也不是nil 但都是相同的(zerobase)</li></ul><h3 id="空接口-1"><a href="#空接口-1" class="headerlink" title="空接口"></a>空接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// a最初是空的eface</span><br>fmt.Println(a == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br><span class="hljs-keyword">var</span> c *<span class="hljs-type">int</span><br>a = c <span class="hljs-comment">// c赋给a之后, 数据为nil, 但类型变为*int, 不是nil</span><br>fmt.Println(c == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br>fmt.Println(a == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li>空接口不一定是”nil接口”</li><li>两个属性都是nil才是nil接口</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>nil是多个类型的零值, 或者空值</li><li>空结构体的指针和值都不是nil</li><li>空接口零值是nil, 一旦有了类型信息就不是nil</li></ul><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int32</span><br>num2 <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int16</span><br>num2 <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Pasted%20image%2020230520185105.png" alt="非内存对齐"><br><img src="/img/Pasted%20image%2020230520185306.png" alt="内存对齐"></p><ul><li>内存对齐: 提高内存操作效率, 有利于内存原子性</li></ul><h3 id="对齐系数"><a href="#对齐系数" class="headerlink" title="对齐系数"></a>对齐系数</h3><p><code>unsafe.Alignof()</code><br>对齐系数: 变量的内存地址必须被对齐系数整除<br>如果对齐系数为4, 变量内存地址必须是4的倍数</p><h3 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h3><ul><li><p>结构体对齐分为内部对齐和结构体之间对齐</p></li><li><p>内部对齐：考虑成员大小和成员的对齐系数</p><ul><li>指的是结构体内部成员的相对位置（偏移量）</li><li>每个成员的偏移量是自身大小与其对齐系数较小值的倍数</li><li>可以尝试通过调整成员顺序, 节约空间</li><li>结构体的对齐系数为成员最大的对齐系数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span> <span class="hljs-comment">// 大小1, 对齐系数1</span><br>b <span class="hljs-type">string</span> <span class="hljs-comment">// 大小16, 对齐系数8</span><br>c <span class="hljs-type">int16</span> <span class="hljs-comment">// 大小2, 对齐系数2, 必须保持顺序</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/Pasted%20image%2020230520185957.png" alt="结构体内部对齐, 顺序严格遵守"></li></ul></li><li><p>结构体长度填充：考虑自身对齐系数和系统字长</p><ul><li>指的是结构体通过增加长度，对齐系统字长</li><li>结构体长度是最大成员长度与系统字长较小的整数倍</li></ul></li></ul><h3 id="空结构体的对齐"><a href="#空结构体的对齐" class="headerlink" title="空结构体的对齐"></a>空结构体的对齐</h3><ul><li>空结构体单独出现时为zerobase</li><li>空结构体出现在<strong>结构体中</strong>时, 地址跟随前一个变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span><br>z <span class="hljs-keyword">struct</span>&#123;&#125;<br>c <span class="hljs-type">int16</span><br>b <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/Pasted%20image%2020230520190857.png" alt="空结构体出现在结构体中"></li><li>空结构体出现在<strong>结构体末尾</strong>时, 需要补齐字长<br><img src="/img/Pasted%20image%2020230520191107.png" alt="空结构体出现在结构体末尾"></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>提高内存操作效率，变量之间需要内存对齐</li><li>基本类型考虑对齐系数</li><li>结构体既需要内部对齐，又需要外部填充对</li><li>齐空结构体作为最后一个成员，需要填充对齐</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><h3 id="变量长度"><a href="#变量长度" class="headerlink" title="变量长度"></a>变量长度</h3><ul><li>Go中部分数据的长度与系统字长有关</li><li>空结构体不占用空间</li><li>空结构体与map结合可以实现nashset</li><li>空结构体与channel结合可以当作纯信号</li></ul><h3 id="字符串与切片"><a href="#字符串与切片" class="headerlink" title="字符串与切片"></a>字符串与切片</h3><ul><li>字符串与切片都是对底层数组的引用</li><li>字符串有UTF-8变长编码的特点</li><li>切片的容量和长度不同</li><li>切片追加时可能需要重建底层数组</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>Go语言使用拉链实现了hashmap</li><li>每一个桶中存储键哈希的前8位</li><li>桶超出8个数据，就会存储到溢出桶中</li></ul><h3 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a>map的扩容</h3><ul><li>装载系数或者谥出桶的增加，会触发map扩容</li><li>“扩容”可能并不是增加桶数，而是整理</li><li>map扩容采用<strong>渐进式</strong>，桶被操作时才会重新分配</li></ul><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><ul><li>map在扩容时会有并发问题</li><li>sync.Map使用了两个map,分离了扩容问题</li><li>不会引发扩容的操作（查、改）使用read map</li><li>可能引发扩容的操作(新增)，使用dirty map</li></ul><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><ul><li>Go的隐式接口更加方便系统的扩展和重构</li><li>结构体和指针都可以实现接口</li><li>空接口值可以承载任何类型的数据</li></ul><h3 id="nil-空结构体-空接口"><a href="#nil-空结构体-空接口" class="headerlink" title="nil&#x2F;空结构体&#x2F;空接口"></a>nil&#x2F;空结构体&#x2F;空接口</h3><ul><li>nil是多个类型的零值，或者空值</li><li>空结构体的指针和值都不是nil</li><li>空接口零值是nil,一旦有了类型信息就不是nil</li></ul><h3 id="内存对齐-1"><a href="#内存对齐-1" class="headerlink" title="内存对齐"></a>内存对齐</h3><ul><li>提高内存操作效率，变量之间需要内存对齐</li><li>基本类型考虑对齐系数</li><li>结构体既需要内部对齐，又需要外部填充对齐</li><li>空结构体作为最后一个成员，需要填充对齐</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go是不是面向对象</title>
    <link href="/2023/09/01/Go%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/09/01/Go%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>Go允许OO的编程风格<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> walk() &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Go的Struct可以看做是其他语言的Class</li><li>Go缺乏其它语言的继承结构</li><li>Go的接口与其它语言有很大差异</li></ul><h2 id="Go的”类”"><a href="#Go的”类”" class="headerlink" title="Go的”类”"></a>Go的”类”</h2><ul><li>其它语言, 往往用class表示一类数据</li><li>class的每一个实例称作”对象”</li><li>Go中用struct表示一类数据</li><li>struct的每一个实例并不是对象, 而是此类型的值</li><li>struct也可以定义方法</li></ul><h2 id="Go的继承"><a href="#Go的继承" class="headerlink" title="Go的继承"></a>Go的继承</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>Person<br>&#125;<br>m := Man&#123;&#125;<br>m.walk() <span class="hljs-comment">// 语法糖, 实际上是 m.People.walk()</span><br></code></pre></td></tr></table></figure><ul><li>Go没有继承关系</li><li>所谓Go的继承只是组合</li><li>组合中的匿名字段, 通过语法糖达成了类似继承的效果</li></ul><h2 id="Go的接口"><a href="#Go的接口" class="headerlink" title="Go的接口"></a>Go的接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> alive <span class="hljs-keyword">interface</span> &#123;<br>walk()<br>&#125;<br><br><span class="hljs-comment">// 实现alive接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p Person)</span></span> walk() &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>接口可以定义Go中的一组行为相似的struct</li><li>struct并不显式实现接口, 而是隐式实现</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Go没有对象, 没有类, 没有继承</li><li>Go通过组合匿名字段来达到类似继承的效果</li><li>通过以上手段去掉了面向对象中复杂而冗余的部分</li><li>保留了基本的面向对象特性</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go是如何运行的</title>
    <link href="/2023/09/01/Go%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <url>/2023/09/01/Go%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>并非是main方法<br>runtime包, <code>_rt0_linux_amd64.s</code>. 汇编程序<br><code>asm_amd64.s</code>, </p><h2 id="读取命令行参数"><a href="#读取命令行参数" class="headerlink" title="读取命令行参数"></a>读取命令行参数</h2><ul><li>复制参数数量argc和参数值argv到栈上</li></ul><h2 id="初始化g0执行栈"><a href="#初始化g0执行栈" class="headerlink" title="初始化g0执行栈"></a>初始化g0执行栈</h2><ul><li>g0是为了调度协程而产生的的协程</li><li>g0是每个Go程序的第一个协程</li></ul><h2 id="运行时检测"><a href="#运行时检测" class="headerlink" title="运行时检测"></a>运行时检测</h2><ul><li>检查各种类型的长度</li><li>检查指针操作</li><li>检查结构体字段的偏移量</li><li>检查atomic原子类型</li><li>检查CAS操作</li><li>检查栈的大小是否为2的幂次</li></ul><h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><ul><li>对命令行中的参数进行处理</li><li>参数数量赋值给<code>argc int32</code></li><li>参数值赋值给<code>argv **byte</code></li></ul><h2 id="调度器初始化-runtime-schedinit"><a href="#调度器初始化-runtime-schedinit" class="headerlink" title="调度器初始化 runtime.schedinit"></a>调度器初始化 runtime.schedinit</h2><ul><li>全局栈空间内存分配</li><li>加载命令行参数到os.Args</li><li>堆内存空间初始化</li><li>加载操作系统环境变量</li><li>初始化当前系统线程</li><li>垃圾回收器的参数初始化</li><li>算法初始化(map&#x2F;hash)</li><li>设置process数量</li></ul><h2 id="创建主协程"><a href="#创建主协程" class="headerlink" title="创建主协程"></a>创建主协程</h2><ul><li>创建一个新的协程, 执行runtime.main(此前已经有一个g0协程)</li><li>放入调度器等待调度</li></ul><h2 id="初始化M"><a href="#初始化M" class="headerlink" title="初始化M"></a>初始化M</h2><ul><li>初始化一个M, 用来调度主协程</li></ul><h2 id="主协程执行主函数"><a href="#主协程执行主函数" class="headerlink" title="主协程执行主函数"></a>主协程执行主函数</h2><ul><li>执行runtime包中的init方法</li><li>启动GC垃圾收集器</li><li>执行用户包依赖的init方法</li><li>执行用户主函数main.main()</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go启动时经历了检查, 各种初始化, 初始化协程调度的过程<br>main.main()也是在协程中运行的<br>Go程序的启动过程像一个虚拟机, 或框架.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
